From 09223af754f25acb079207c4d298d27dea5b372d Mon Sep 17 00:00:00 2001
From: Dmitrijs Martinovs <dmartinovs@maxlinear.com>
Date: Tue, 23 May 2023 10:49:21 +0300
Subject: [PATCH] WLANRTSYS-55434: Implement MXL proprietary configuration pipe
 parameters

---
 hostapd/config_file.c        | 256 +++++++++++++++++++++++++++++++++++
 hostapd/hostapd.conf         |   3 +
 src/ap/ap_config.c           |  47 ++++++-
 src/ap/ap_config.h           |  76 +++++++++++
 src/ap/ap_drv_ops.h          |  26 ++++
 src/ap/hostapd.c             | 232 ++++++++++++++++++++++++++++++-
 src/ap/hostapd.h             |  18 ++-
 src/ap/mxl_hostapd.c         |  69 ++++++++++
 src/common/defs.h            |  13 ++
 src/drivers/driver.h         |  25 ++++
 src/drivers/driver_nl80211.c |  54 ++++++++
 11 files changed, 812 insertions(+), 7 deletions(-)

diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 7b35a8715..99ca5f8bb 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -836,6 +836,18 @@ static int hostapd_parse_chanlist(struct hostapd_config *conf, char *val)
 	return 0;
 }
 
+static int hostapd_intlist_size(const char *val)
+{
+	int count = 0;
+	const char *pos = val;
+
+	while (*pos != '\0') {
+		if (*pos == ' ')
+			count++;
+		pos++;
+	}
+	return count + 1;
+}
 
 static int hostapd_parse_intlist(int **int_list, char *val)
 {
@@ -875,6 +887,32 @@ static int hostapd_parse_intlist(int **int_list, char *val)
 	return 0;
 }
 
+static int hostapd_fill_intlist(int *int_list, char *val, int exp_count)
+{
+	int count;
+	char *pos, *end;
+	pos = val;
+	count = 0;
+	while (*pos != '\0') {
+		if (*pos == ' ')
+			count++;
+		pos++;
+	}
+	if (exp_count != (count + 1))
+		return -1;
+	pos = val;
+	count = 0;
+	while (*pos != '\0') {
+		end = os_strchr(pos, ' ');
+		if (end)
+			*end = '\0';
+		int_list[count++] = atoi(pos);
+		if (!end)
+			break;
+		pos = end + 1;
+	}
+	return 0;
+}
 
 static int hostapd_config_bss(struct hostapd_config *conf, const char *ifname)
 {
@@ -3344,6 +3382,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		}
 	} else if (os_strcmp(buf, "acs_exclude_dfs") == 0) {
 		conf->acs_exclude_dfs = atoi(pos);
+	} else if (os_strcmp(buf, "acs_fils") == 0) {
+		conf->sFilsBeaconFlag = atoi(pos);
 	} else if (os_strcmp(buf, "op_class") == 0) {
 		conf->op_class = atoi(pos);
 	} else if (os_strcmp(buf, "channel") == 0) {
@@ -3555,6 +3595,35 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			conf->rate_type = BEACON_RATE_LEGACY;
 			conf->beacon_rate = val;
 		}
+	} else if (os_strcmp(buf, "management_frames_rate") == 0) {
+		int val = atoi(pos);
+		if ((val != MGMT_FRAMES_RATE_DISABLED) &&
+			!IS_VALID_RANGE(val, MGMT_FRAMES_RATE_ENABLED_MIN, MGMT_FRAMES_RATE_ENABLED_MAX))
+		{
+			wpa_printf(MSG_ERROR, "Line %d: invalid management_frames_rate %d (expected %d or [%d...%d])",
+					   line, val,
+					   MGMT_FRAMES_RATE_DISABLED,
+					   MGMT_FRAMES_RATE_ENABLED_MIN,
+					   MGMT_FRAMES_RATE_ENABLED_MAX);
+			return 1;
+		}
+		bss->management_frames_rate = val;
+	} else if (os_strcmp(buf, "dynamic_multicast_mode") == 0) {
+		int val = atoi(pos);
+		if (!((val >= DYNAMIC_MC_DISABLE) && (val <= DYNAMIC_MC_MODE_STATIC)))
+		{
+			wpa_printf(MSG_ERROR, "Line %d: invalid dynamic_multicast_mode : %d",line, val);
+			return 1;
+		}
+		bss->dynamic_multicast_mode = val;
+	} else if (os_strcmp(buf, "dynamic_multicast_rate") == 0) {
+		int val = atoi(pos);
+		if (!((val >= DYNAMIC_MC_RATE_MIN) && (val <= DYNAMIC_MC_RATE_MAX)))
+		{
+			wpa_printf(MSG_ERROR, "Line %d: invalid dynamic_multicast_rate : %d",line, val);
+			return 1;
+		}
+		bss->dynamic_multicast_rate = val;
 	} else if (os_strcmp(buf, "preamble") == 0) {
 		if (atoi(pos))
 			conf->preamble = SHORT_PREAMBLE;
@@ -3751,6 +3820,25 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		conf->he_phy_capab.he_su_beamformee = atoi(pos);
 	} else if (os_strcmp(buf, "he_mu_beamformer") == 0) {
 		conf->he_phy_capab.he_mu_beamformer = atoi(pos);
+	} else if (os_strcmp(buf, "sDynamicMuTypeDownLink") == 0) {
+		conf->sDynamicMuTypeDownLink = atoi(pos);
+	} else if (os_strcmp(buf, "sDynamicMuTypeUpLink") == 0) {
+		conf->sDynamicMuTypeUpLink = atoi(pos);
+	} else if (os_strcmp(buf, "sDynamicMuMinStationsInGroup") == 0) {
+		conf->sDynamicMuMinStationsInGroup = atoi(pos);
+	} else if (os_strcmp(buf, "sDynamicMuMaxStationsInGroup") == 0) {
+		conf->sDynamicMuMaxStationsInGroup  = atoi(pos);
+	} else if (os_strcmp(buf, "sDynamicMuCdbConfig") == 0) {
+		conf->sDynamicMuCdbConfig = atoi(pos);
+	} else if (os_strcmp(buf, "sFixedLtfGi") == 0) {
+		conf->sFixedLtfGi = atoi(pos);
+	} else if (os_strcmp(buf, "mgmt_frame_power_control") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, -20, 0)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid mgmt_frame_power_control %d", line, val);
+			return 1;
+		}
+		bss->mgmt_frame_power_control = val;
 	} else if (os_strcmp(buf, "he_bss_color") == 0) {
 		int val = atoi(pos);
 		if(!IS_VALID_RANGE(val, 1, HE_OPERATION_BSS_COLOR)) {
@@ -4893,6 +4981,153 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 #endif /* CONFIG_OWE */
 	} else if (os_strcmp(buf, "coloc_intf_reporting") == 0) {
 		bss->coloc_intf_reporting = atoi(pos);
+
+	} else if (os_strcmp(buf, "sAggrConfig") == 0) {
+		bss->sAggrConfigSize = hostapd_intlist_size(pos) * sizeof(int);
+		if(hostapd_parse_intlist(&bss->sAggrConfig, pos)){
+			bss->sAggrConfigSize = 0;
+			return 1;
+		}
+
+	} else if (os_strcmp(buf, "s11nProtection") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, N_PROTECTION_MIN, N_PROTECTION_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid s11nProtection %d",
+				line, val);
+			return 1;
+		}
+		bss->s11nProtection = val;
+
+	} else if (os_strcmp(buf, "ap_retry_limit") == 0) {
+		uint32_t ap_retry_limit = atoi(pos);
+		if (ap_retry_limit > AP_TX_RETRY_LIMIT_MAX) {
+			wpa_printf(MSG_ERROR, "Invalid AP retry limit value %d",
+				ap_retry_limit);
+			return 1;
+		}
+		conf->ap_retry_limit = ap_retry_limit;
+	} else if (os_strcmp(buf, "ap_retry_limit_data") == 0) {
+		uint32_t ap_retry_limit_data = atoi(pos);
+		if (ap_retry_limit_data > AP_TX_RETRY_LIMIT_MAX) {
+			wpa_printf(MSG_ERROR, "Invalid AP retry limit data value %d",
+					ap_retry_limit_data);
+			return 1;
+		}
+		conf->ap_retry_limit_data = ap_retry_limit_data;
+	} else if (os_strcmp(buf, "ap_retry_limit_exce") == 0) {
+		u8 ap_retry_limit_exce = atoi(pos);
+		if (ap_retry_limit_exce > AP_TX_EXCE_RETRY_LIMIT_DEFAULT) {
+			wpa_printf(MSG_ERROR, "Invalid AP exce retry limit value %d",
+					ap_retry_limit_exce);
+			return 1;
+		}
+		bss->ap_retry_limit_exce = ap_retry_limit_exce;
+	} else if (os_strcmp(buf, "sPowerSelection") == 0) {
+		conf->sPowerSelection = atoi(pos);
+
+	} else if (os_strcmp(buf, "sCoCPower") == 0) {
+		conf->sCoCPowerSize = hostapd_intlist_size(pos);
+		if(hostapd_parse_intlist(&conf->sCoCPower, pos))
+			return 1;
+
+	} else if (os_strcmp(buf, "sCoCAutoCfg") == 0) {
+		if(hostapd_parse_intlist(&conf->sCoCAutoCfg, pos))
+			return 1;
+
+	} else if (os_strcmp(buf, "sErpSet") == 0) {
+		if(hostapd_parse_intlist(&conf->sErpSet, pos))
+			return 1;
+
+	} else if (os_strcmp(buf, "sRadarRssiTh") == 0) {
+		conf->sRadarRssiTh = atoi(pos);
+
+	} else if (os_strcmp(buf, "sStationsStat") == 0) {
+		conf->sStationsStat = atoi(pos);
+
+	} else if (os_strcmp(buf, "sBfMode") == 0) {
+		conf->sBfMode = atoi(pos);
+
+	} else if (os_strcmp(buf, "sMaxMpduLen") == 0) {
+		conf->sMaxMpduLen = atoi(pos);
+
+	} else if (os_strcmp(buf, "sProbeReqCltMode") == 0) {
+		conf->sProbeReqCltMode = atoi(pos);
+
+	} else if (os_strcmp(buf, "sRTSmode") == 0) {
+		if (hostapd_fill_intlist(conf->sRTSmode, pos, ARRAY_SIZE(conf->sRTSmode))) {
+			wpa_printf(MSG_ERROR, "Line %d: wrong number of sRTSmode parameters, expected %d",
+				   line, (int)ARRAY_SIZE(conf->sRTSmode));
+			return 1;
+		}
+	} else if (os_strcmp(buf, "sFixedRateCfg") == 0) {
+		if(hostapd_parse_intlist(&conf->sFixedRateCfg, pos))
+			return 1;
+
+	} else if (os_strcmp(buf, "sQAMplus") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid sQAMplus %d",
+				line, val);
+			return 1;
+		}
+		conf->sQAMplus = val;
+
+	} else if (os_strcmp(buf, "sInterferDetThresh") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, INTERFERENCE_DET_THRESH_MIN, INTERFERENCE_DET_THRESH_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid interference detection threshold value %d",
+				   line, val);
+			return 1;
+		}
+		conf->sInterferDetThresh = val;
+	} else if (os_strcmp(buf, "sCcaAdapt") == 0) {
+		if(hostapd_fill_intlist(conf->sCcaAdapt, pos, ARRAY_SIZE(conf->sCcaAdapt))) {
+			wpa_printf(MSG_ERROR, "Line %d: wrong number of sCcaAdapt parameters, expected %d",
+				   line, (int)ARRAY_SIZE(conf->sCcaAdapt));
+			return 1;
+		}
+	} else if (os_strcmp(buf, "sFWRecovery") == 0) {
+		conf->sFWRecoverySize = hostapd_intlist_size(pos) * sizeof(int);
+		if(hostapd_parse_intlist(&conf->sFWRecovery, pos)){
+			conf->sFWRecoverySize = 0;
+			return 1;
+		}
+	} else if (os_strcmp(buf, "sConfigMRCoex") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, COEX_MODE_MIN, COEX_MODE_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid sConfigMRCoex '%s'",
+				line, buf);
+			return 1;
+		}
+		conf->sConfigMRCoex = val;
+
+	} else if (os_strcmp(buf, "sConfigMRCoexActiveTime") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, COEX_ACTIVE_TIME_MIN, COEX_ACTIVE_TIME_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid sConfigMRCoexActiveTime '%s'",
+				line, buf);
+			return 1;
+		}
+		conf->sConfigMRCoexActiveTime = val;
+
+	} else if (os_strcmp(buf, "sConfigMRCoexInactiveTime") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, COEX_INACTIVE_TIME_MIN, COEX_INACTIVE_TIME_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid sConfigMRCoexInactiveTime '%s'",
+				line, buf);
+			return 1;
+		}
+		conf->sConfigMRCoexInactiveTime = val;
+
+	} else if (os_strcmp(buf, "sConfigMRCoexCts2SelfActive") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid sConfigMRCoexCts2SelfActive '%s'",
+				line, buf);
+			return 1;
+		}
+		conf->sConfigMRCoexCts2SelfActive = val;
+
 	} else if (os_strcmp(buf, "multi_ap") == 0) {
 		int val = atoi(pos);
 
@@ -5121,6 +5356,20 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			return 1;
 		}
 #endif /* CONFIG_IEEE80211BE */
+	} else if (os_strcmp(buf, "mu_mimo_operation") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "line %d: invalid mu mimo opeartion %d", line, val);
+			return 1;
+		}
+		conf->sMuOperation = val;
+	} else if (os_strcmp(buf, "override_6g_mbssid_default_mode") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "line %d: invalid 6g mbssid default mode override value %d", line, val);
+			return 1;
+		}
+		conf->override_6g_mbssid_default_mode = val;
 	} else if (os_strcmp(buf, "owl") == 0) {
 		int val = atoi(pos);
 		if (!IS_VALID_BOOL_RANGE(val)) {
@@ -5186,6 +5435,13 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			wpa_printf(MSG_ERROR, "Num of BTWT schedules exceeds the limit %d", num_sched);
 		}
 #endif
+	} else if (os_strcmp(buf, "intra_vap_mcast") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid Intra-VAP multicast mode value %d", line, val);
+			return 1;
+		}
+		bss->intra_vap_mcast = val;
 	} else if (os_strcmp(buf, "ext_cap_max_num_msdus_in_amsdu") == 0) {
 		int val = atoi(pos);
 		if (!IS_VALID_RANGE(val, EXT_CAP_MAX_NUM_MSDU_IN_AMSDU_MIN, EXT_CAP_MAX_NUM_MSDU_IN_AMSDU_MAX)) {
diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
index 326737887..9f449c694 100644
--- a/hostapd/hostapd.conf
+++ b/hostapd/hostapd.conf
@@ -818,6 +818,9 @@ wmm_ac_vo_acm=0
 # setting use_sta_nsts=1.
 #use_sta_nsts=0
 
+# Management Frame Power Control for any SSID can be configured only within the range of 0 to -20 dB
+#mgmt_frame_power_control=0
+
 ##### IEEE 802.11ax related configuration #####################################
 
 #ieee80211ax: Whether IEEE 802.11ax (HE) is enabled
diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
index a255f0762..72e1c27a2 100644
--- a/src/ap/ap_config.c
+++ b/src/ap/ap_config.c
@@ -91,6 +91,7 @@ void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 	bss->beacon_int = 0; /* use interface's global beacon interval */
 
 	bss->dtim_period = 2;
+	bss->management_frames_rate = MGMT_FRAMES_RATE_DEFAULT;
 
 	bss->radius_server_auth_port = 1812;
 	bss->eap_sim_db_timeout = 1;
@@ -173,7 +174,11 @@ void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 #ifdef CONFIG_TESTING_OPTIONS
 	bss->sae_commit_status = -1;
 #endif /* CONFIG_TESTING_OPTIONS */
+	bss->sAggrConfigSize = 0; /* set the size to 0 to mark sAggrConfig as unintialized */
 
+	bss->s11nProtection = 1; /* enabled */
+
+	bss->ap_retry_limit_exce = AP_TX_EXCE_RETRY_LIMIT_DEFAULT;
 #ifdef CONFIG_PASN
 	/* comeback after 10 TUs */
 	bss->pasn_comeback_after = 10;
@@ -248,9 +253,18 @@ struct hostapd_config * hostapd_config_defaults(void)
 
 	conf->num_bss = 1;
 
+	conf->ap_retry_limit = AP_RETRY_INVALID;	/* init with invalid value. */
+	conf->ap_retry_limit_data = AP_RETRY_INVALID;	/* init with invalid value. */
 	conf->beacon_int = 100;
+	conf->sStationsStat = 1;
 	conf->rts_threshold = -2; /* use driver default: 2347 */
 	conf->fragm_threshold = -2; /* user driver default: 2346 */
+	conf->sQAMplus = -1;
+	conf->sConfigMRCoex = -1;
+	conf->sBfMode = -1;
+	conf->sProbeReqCltMode = 0;
+	conf->sMaxMpduLen = -1;
+
 	/* Set to invalid value means do not add Power Constraint IE */
 	conf->local_pwr_constraint = -1;
 
@@ -274,6 +288,26 @@ struct hostapd_config * hostapd_config_defaults(void)
 	conf->ap_table_max_size = 255;
 	conf->ap_table_expiration_time = 60;
 	conf->track_sta_max_age = 180;
+	conf->sPowerSelection = 0; /* 100% */
+	conf->sInterferDetThresh = INTERFERENCE_DET_THRESH_DEFAULT;
+	conf->sDynamicMuTypeDownLink = 3;
+	conf->sDynamicMuTypeUpLink = 1;
+	conf->sDynamicMuMinStationsInGroup = 2;
+	conf->sDynamicMuMaxStationsInGroup = 4;
+	conf->sDynamicMuCdbConfig = 0;
+	conf->sFixedLtfGi = GI_ILLEGAL_VALUE;
+
+	conf->sRTSmode[0] = 0;
+	conf->sRTSmode[1] = 0;
+
+	conf->sCcaAdapt[0] =  10;
+	conf->sCcaAdapt[1] =   5;
+	conf->sCcaAdapt[2] = -30;
+	conf->sCcaAdapt[3] =  10;
+	conf->sCcaAdapt[4] =   5;
+	conf->sCcaAdapt[5] =  30;
+	conf->sCcaAdapt[6] =  60;
+
 
 #ifdef CONFIG_TESTING_OPTIONS
 	conf->ignore_probe_probability = 0.0;
@@ -325,8 +359,11 @@ struct hostapd_config * hostapd_config_defaults(void)
 	conf->airtime_update_interval = AIRTIME_DEFAULT_UPDATE_INTERVAL;
 #endif /* CONFIG_AIRTIME_POLICY */
 
+	conf->sMuOperation = DEFAULT_MU_OPERATION;
+	conf->override_6g_mbssid_default_mode = 0;
 	conf->mbssid_aid_offset = NON_MULTIBSS_AID_OFFSET;
 	conf->ext_cap_max_num_msdus_in_amsdu = EXT_CAP_MAX_NUM_MSDU_IN_AMSDU_DEFAULT;
+	conf->sFilsBeaconFlag = 1; /* By Default we should receive/process the incoming Fils frame on 6G */
 #ifdef CONFIG_VENDOR_MXL
 	mxl_hostapd_config_defaults(conf);
 #endif /* CONFIG_VENDOR_MXL */
@@ -999,6 +1036,7 @@ void hostapd_config_free_bss(struct hostapd_bss_config *conf)
 
 	hostapd_config_free_sae_passwords(conf);
 
+	os_free(conf->sAggrConfig);
 #ifdef CONFIG_AIRTIME_POLICY
 	{
 		struct airtime_sta_weight *wt, *wt_prev;
@@ -1049,6 +1087,12 @@ void hostapd_config_free(struct hostapd_config *conf)
 	wpabuf_free(conf->lci);
 	wpabuf_free(conf->civic);
 
+	os_free(conf->sCoCPower);
+	os_free(conf->sCoCAutoCfg);
+	os_free(conf->sErpSet);
+	os_free(conf->sFixedRateCfg);
+	os_free(conf->sFWRecovery);
+
 	os_free(conf);
 }
 
@@ -1612,7 +1656,8 @@ int hostapd_config_check(struct hostapd_config *conf, int full_config)
 		conf->mbssid_aid_offset = MULTIBSS_AID_OFFSET;
 		wpa_printf(MSG_DEBUG, "mbssid_aid_offset is set to (%d)", conf->mbssid_aid_offset);
 	} else if (is_6ghz_op_class(conf->op_class) &&
-			   (conf->num_bss >= 3)) {
+			   (conf->num_bss >= MIN_NUM_BSS_IN_MBSSID_SET) &&
+			   (!conf->override_6g_mbssid_default_mode)) {
 				conf->multibss_enable = 1;
 				conf->mbssid_aid_offset = MULTIBSS_AID_OFFSET;
 	}
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index 5d0e4b106..a4c376c60 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -30,6 +30,8 @@ enum macaddr_acl {
 	USE_EXTERNAL_RADIUS_AUTH = 2
 };
 
+#define SRX_TH_VAL	-82 /* adaptive sensitivity threshold */
+
 /**
  * mesh_conf - local MBSS state and settings
  */
@@ -336,6 +338,9 @@ struct hostapd_bss_config {
 
 	u16 beacon_int;
 	int dtim_period;
+	int management_frames_rate;
+	int dynamic_multicast_mode;
+	int dynamic_multicast_rate;
 	unsigned int bss_load_update_period;
 	unsigned int chan_util_avg_period;
 	int enable_bss_load_ie;
@@ -837,6 +842,10 @@ struct hostapd_bss_config {
 #define FRONTHAUL_BSS 2
 	int multi_ap; /* bitmap of BACKHAUL_BSS, FRONTHAUL_BSS */
 
+	int *sAggrConfig; /*amsdu_mode ba_mode window_size*/
+	int sAggrConfigSize;
+	int s11nProtection;
+	u8 ap_retry_limit_exce;
 #ifdef CONFIG_AIRTIME_POLICY
 	unsigned int airtime_weight;
 	int airtime_limit;
@@ -1002,6 +1011,8 @@ struct hostapd_bss_config {
 	bool bcast_twt_config_sent;
 	broadcast_twt_schedules_t broadcast_twt_schedules;
 #endif
+	int intra_vap_mcast;
+	int mgmt_frame_power_control;
 #ifdef CONFIG_VENDOR_MXL
 	struct mxl_hostapd_bss_config mxl_bss_conf;
 #endif /* CONFIG_VENDOR_MXL */
@@ -1046,6 +1057,16 @@ struct spatial_reuse {
 #define BEACON_INTERVAL_MIN		10
 #define BEACON_INTERVAL_MAX		UINT16_MAX
 
+#define COC_AUTO_CONFIG			14
+#define ERP_SET_SIZE			10
+#define RTS_MODE_SIZE			2
+#define N_PROTECTION_MIN		0
+#define N_PROTECTION_MAX		4
+#define FIXED_RATE_CONFIG_SIZE	11
+#define CCA_ADAPT_SIZE			7
+#define DYNAMIC_MU_TYPE_SIZE	5
+#define GI_ILLEGAL_VALUE		(-1)
+
 #define BSS_COLOR_CHANGE_TIMEOUT_DEFAULT		DOT11BSS_COLOR_COLLISION_AP_PERIOD
 #define BSS_COLOR_CHANGE_TIMEOUT_RANDOM			(UINT8_MAX)
 #define BSS_COLOR_CHANGE_TIMEOUT_RANDOM_MIN		40
@@ -1070,6 +1091,10 @@ enum multibss_aid_offset {
 	MULTIBSS_AID_OFFSET = 64
 };
 
+#define MIN_NUM_BSS_IN_NON_MBSSID_SET	2 /* Non MultiBSS : Master(Dummy VAP) + one or more operational VAPs */
+#define MIN_NUM_BSS_IN_MBSSID_SET		3 /* MultiBSS: Master(Dummy VAP) + one TX VAP + one or more Non TX VAPs */
+#define NUM_NON_TX_VAPS(num_bss)		(num_bss - MIN_NUM_BSS_IN_NON_MBSSID_SET)
+
 #ifdef CONFIG_IEEE80211AX
 enum bcast_twt_wake_duration_unit {
 	TWT_WAKE_DURATION_UNIT_256US,
@@ -1215,6 +1240,29 @@ struct hostapd_config {
 	unsigned int num_acs_chan_bias;
 #endif /* CONFIG_ACS */
 
+	int sPowerSelection; /* tx power: 12%:9 25%:6 50%:3 75%:1 100%:0 */
+	int *sCoCPower;
+	int sCoCPowerSize;
+	int *sCoCAutoCfg;
+	int *sErpSet;
+	int sRadarRssiTh;
+	int sFilsBeaconFlag;
+	int sRTSmode[RTS_MODE_SIZE];
+	int *sFixedRateCfg;
+	int sInterferDetThresh;
+	int sCcaAdapt[CCA_ADAPT_SIZE];
+	int *sFWRecovery;
+	int sFWRecoverySize;
+	int sStationsStat;
+	int sQAMplus;
+	int sConfigMRCoex;
+	int sConfigMRCoexActiveTime;
+	int sConfigMRCoexInactiveTime;
+	int sConfigMRCoexCts2SelfActive;
+	int sBfMode;
+	int sProbeReqCltMode;
+	int sMaxMpduLen;
+
 	struct wpabuf *lci;
 	struct wpabuf *civic;
 	int stationary_ap;
@@ -1222,6 +1270,19 @@ struct hostapd_config {
 	int ieee80211ax;
 	u8 multibss_enable;
 	u8 mbssid_aid_offset;
+	int sDynamicMuTypeDownLink;
+	int sDynamicMuTypeUpLink;
+	int sDynamicMuMinStationsInGroup;
+	int sDynamicMuMaxStationsInGroup;
+	int sDynamicMuCdbConfig;
+	int sFixedLtfGi;
+#define AP_TX_EXCE_RETRY_LIMIT_DEFAULT  50
+#define AP_TX_RETRY_LIMIT_MAX  15
+#define AP_TX_RETRY_LIMIT_DEFAULT  3
+#define AP_TX_RETRY_LIMIT_DEFAULT_DATA  7
+#define AP_RETRY_INVALID	0xff
+	u8 ap_retry_limit;
+	u8 ap_retry_limit_data;
 #ifdef CONFIG_IEEE80211AX
 	struct he_phy_capabilities_info he_phy_capab;
 	struct he_operation he_op;
@@ -1290,6 +1351,12 @@ struct hostapd_config {
 		MBSSID_ENABLED = 1,
 		ENHANCED_MBSSID_ENABLED = 2,
 	} mbssid;
+
+#define DEFAULT_MU_OPERATION	1
+	int sMuOperation;
+	int override_6g_mbssid_default_mode;
+	int whm_cfg_flag;	/* WHM configuration bitfields */
+
 	u8 owl; /* Forwarding incoming probe reqests to upper layers */
 #ifdef CONFIG_IEEE80211AX
 	enum bcast_twt_wake_duration_unit btwt_wake_dur_unit;
@@ -1303,6 +1370,15 @@ struct hostapd_config {
 #endif /* CONFIG_VENDOR_MXL */
 };
 
+#define INTERFERENCE_DET_THRESH_MIN	-128
+#define INTERFERENCE_DET_THRESH_MAX	1
+#define INTERFERENCE_DET_THRESH_DEFAULT	-68
+#define COEX_MODE_MIN	0
+#define COEX_MODE_MAX	2
+#define COEX_ACTIVE_TIME_MIN	2
+#define COEX_ACTIVE_TIME_MAX	0x1fffff
+#define COEX_INACTIVE_TIME_MIN	2
+#define COEX_INACTIVE_TIME_MAX	32
 
 static inline enum oper_chan_width
 hostapd_get_oper_chwidth(struct hostapd_config *conf)
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index fe2870fda..e634b81ad 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -422,6 +422,15 @@ hostapd_drv_set_band(struct hostapd_data *hapd, u32 band_mask)
 	return hapd->driver->set_band(hapd->drv_priv, band_mask);
 }
 
+static inline int hostapd_drv_set_management_frames_rate(struct hostapd_data *hapd,
+														const u8 management_frames_rate)
+{
+	if (hapd->driver == NULL || hapd->driver->set_management_frames_rate == NULL)
+		return -ENOTSUP;
+
+	return hapd->driver->set_management_frames_rate(hapd->drv_priv, management_frames_rate);
+}
+
 static inline int hostapd_drv_sta_steer(struct hostapd_data *hapd,
 	struct multi_ap_blacklist* entry, const u8 *bssid)
 {
@@ -468,6 +477,23 @@ static inline int hostapd_drv_set_mbssid_vap_mode(struct hostapd_data *hapd,
 	return hapd->driver->set_mbssid_vap_mode(hapd->drv_priv, mbssid_vap);
 }
 
+static inline int hostapd_drv_set_dynamic_multicast_mode_rate(struct hostapd_data *hapd,
+																int dynamic_mc_mode, int dynamic_mc_rate)
+{
+	if (hapd->driver == NULL || hapd->driver->set_dynamic_mc_mode_rate == NULL)
+		return -ENOTSUP;
+
+	return hapd->driver->set_dynamic_mc_mode_rate(hapd->drv_priv, dynamic_mc_mode, dynamic_mc_rate);
+}
+
+static inline int hostapd_drv_set_whm_config(struct hostapd_data *hapd, int whm_cfg_flag)
+{
+	if (hapd->driver == NULL || hapd->driver->set_whm_config == NULL)
+		return -ENOTSUP;
+
+	return hapd->driver->set_whm_config(hapd->drv_priv, whm_cfg_flag);
+}
+
 static inline int hostapd_drv_set_mbssid_num_vaps_in_group(struct hostapd_data *hapd,
 	const u8 mbssid_num_vaps_in_group)
 {
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 503e76fc1..b4aeb8884 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -1294,8 +1294,20 @@ static int hostapd_pre_up_vendor_vap_cmd(struct hostapd_data *hapd)
 {
 	u8 multibss_vap_mode = NON_MULTIBSS_VAP_MODE;
 
+	/* Send vendor command before BSS setup is completed */
+	/* Multiple BSSID Set for 6GHz band*/
+	if (is_6ghz_op_class(hapd->iconf->op_class)) {
+		/* MultiBSSID Set enabled by default unless HE debug mode is enabled */
+		if ((hapd->iconf->num_bss >= MIN_NUM_BSS_IN_MBSSID_SET) && (!hapd->iconf->override_6g_mbssid_default_mode)) {
+			hapd->iconf->multibss_enable = 1;
+			hapd->iconf->mbssid_aid_offset = MULTIBSS_AID_OFFSET;
+			wpa_printf(MSG_DEBUG, "mbssid_aid_offset is set to (%d) for 6G interface",
+								   hapd->iconf->mbssid_aid_offset);
+		}
+	}
+
 	/* Multiple BSSID */
-	if(hapd->iconf->multibss_enable) {
+	if (hapd->iconf->multibss_enable) {
 		if (MULTIBSS_REFERENCE_BSS_IDX == hapd->conf->bss_idx) {
 					multibss_vap_mode = MULTIBSS_TRANSMITTED_VAP_MODE;
 		} else {
@@ -1323,7 +1335,31 @@ static int hostapd_pre_up_vendor_vap_cmd(struct hostapd_data *hapd)
 		}
 	}
 
+	/* Management Frames Rate */
+	if (hostapd_drv_set_management_frames_rate(hapd, (u8)hapd->conf->management_frames_rate) < 0)
+		wpa_printf(MSG_ERROR, "Failed to set Management Frames Rate");
+
+	/* Dynamic Multicast Rate */
+	/* Send NL command to driver */
+	if (hostapd_drv_set_dynamic_multicast_mode_rate(hapd,
+				hapd->conf->dynamic_multicast_mode,
+				hapd->conf->dynamic_multicast_rate) < 0) {
+		wpa_printf(MSG_ERROR, "Failed to set Dynamic Multicast Rate");
+	}
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_INTRA_VAP_MCAST,
+				  (u8 *)&hapd->conf->intra_vap_mcast, sizeof(hapd->conf->intra_vap_mcast),
+				  NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "Set Intra-VAP multicast mode failed");
+
+	if (is_6ghz_op_class(hapd->iconf->op_class)) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_FILS_BEACON_FLAG,
+					(u8*)&hapd->iconf->sFilsBeaconFlag, sizeof(hapd->iconf->sFilsBeaconFlag),
+					NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sFilsBeaconFlag failed");
+	}
 
+	/* Add next vendor command here */
 	return 0;
 }
 
@@ -1437,7 +1473,48 @@ static void hostapd_send_btwt_configuration(struct hostapd_data *hapd)
 
 static void hostapd_post_up_vendor_vap_cmd(struct hostapd_data *hapd, struct hostapd_bss_config *conf)
 {
-	UNUSED_VAR(conf);
+	int ap_exce_retry_limit;
+
+	if (conf->sAggrConfigSize) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_AGGR_CONFIG,
+				(u8*)conf->sAggrConfig, conf->sAggrConfigSize, NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sAggrConfig failed. sAggrConfigSize:%d", conf->sAggrConfigSize);
+	}
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_PROTECTION_METHOD,
+			(u8*)&conf->s11nProtection, sizeof(conf->s11nProtection),
+			NESTED_ATTR_NOT_USED, NULL)) {
+		wpa_printf(MSG_WARNING, "set s11nProtection failed");
+	}
+
+	if (!conf->bss_idx) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_MU_OPERATION,
+					(u8*)&hapd->iconf->sMuOperation, sizeof(hapd->iconf->sMuOperation),
+					NESTED_ATTR_NOT_USED, NULL)) {
+			wpa_printf(MSG_WARNING, "set sMuOperation failed");
+		}
+	}
+
+	if (!conf->bss_idx) {
+		if (hostapd_drv_set_whm_config(hapd, hapd->iconf->whm_cfg_flag)) {
+			wpa_printf(MSG_DEBUG, "Set WHM Config failed");
+		}
+	}
+
+	if (hapd->conf->disassoc_low_ack) {
+		ap_exce_retry_limit = conf->ap_retry_limit_exce;
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_AP_EXCE_RETRY_LIMIT,
+			(u8*)&ap_exce_retry_limit, sizeof(ap_exce_retry_limit), NESTED_ATTR_NOT_USED, NULL)) {
+			wpa_printf(MSG_WARNING, "set excessive retry cfg failed");
+		}
+	}
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_MGMT_FRAME_PWR_CTRL,
+			(u8*)&conf->mgmt_frame_power_control, sizeof(conf->mgmt_frame_power_control),
+			NESTED_ATTR_NOT_USED, NULL)) {
+		wpa_printf(MSG_WARNING, "set sMgmtFramePowerControl failed");
+	}
+
 #ifdef CONFIG_IEEE80211AX
 	/*Broadcast TWT default configuration sent to the Driver/FW for operational VAP and only in case there is a  *
 	 *single beaconing VAP, and if BTWT config, TWT Responder support and Broadcast TWT support are all enabled  */
@@ -2539,6 +2616,155 @@ static void hostapd_owe_update_trans(struct hostapd_iface *iface)
 #endif /* CONFIG_OWE */
 }
 
+/* hostapd_post_up_vendor_cmd_mu_type - read modify write for up/down_mu_type */
+static void hostapd_post_up_vendor_cmd_mu_type(struct hostapd_data *hapd, struct hostapd_config *conf)
+{
+	struct wpabuf *rsp = NULL;
+	int *dynamicMuConfig = 0;
+
+	rsp = wpabuf_alloc(DYNAMIC_MU_TYPE_SIZE * sizeof(int));
+	if (!rsp) {
+		wpa_printf(MSG_WARNING, "failed to allocate wpabuf");
+		return;
+	}
+	dynamicMuConfig = (int *)rsp->buf;
+
+	if (conf->sDynamicMuTypeDownLink >= 0)
+		dynamicMuConfig[0] = conf->sDynamicMuTypeDownLink;
+	if (conf->sDynamicMuTypeUpLink >= 0)
+		dynamicMuConfig[1] = conf->sDynamicMuTypeUpLink;
+	if (conf->sDynamicMuMinStationsInGroup >= 0)
+		dynamicMuConfig[2] = conf->sDynamicMuMinStationsInGroup;
+	if (conf->sDynamicMuMaxStationsInGroup >= 0)
+		dynamicMuConfig[3] = conf->sDynamicMuMaxStationsInGroup;
+	if (conf->sDynamicMuCdbConfig >= 0)
+		dynamicMuConfig[4] = conf->sDynamicMuCdbConfig;
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_DYNAMIC_MU_TYPE,
+		(u8*)dynamicMuConfig, DYNAMIC_MU_TYPE_SIZE * sizeof(int), NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set dynamic mu parameter failed");
+
+	wpabuf_free(rsp);
+}
+
+
+/* hostapd_post_up_vendor_cmd_guard_interval - validate guard interval value and write to driver */
+static void hostapd_post_up_vendor_cmd_guard_interval(struct hostapd_data *hapd, int sFixedLtfGi, int ieee80211ax, int ieee80211ac)
+{
+	int iwFormat[2] = {0, GI_ILLEGAL_VALUE}; /*auto, gi value*/
+
+	switch (sFixedLtfGi) {
+		case GI_ILLEGAL_VALUE:
+			return;
+
+		case GUARD_INTERVAL_400:
+			if (ieee80211ac && !ieee80211ax)
+				iwFormat[1] = GI_CP_MODE_SHORT_CP_SHORT_LTF;
+			break;
+
+		case GUARD_INTERVAL_800:
+			if (ieee80211ac || ieee80211ax)
+				iwFormat[1] = GI_CP_MODE_SHORT_CP_MED_LTF;
+			break;
+
+		case GUARD_INTERVAL_1600:
+			if (!ieee80211ac && ieee80211ax)
+				iwFormat[1] = GI_CP_MODE_MED_CP_MED_LTF;
+			break;
+
+		case GUARD_INTERVAL_3200:
+			if (!ieee80211ac && ieee80211ax)
+				iwFormat[1] = GI_CP_MODE_LONG_CP_LONG_LTF;
+			break;
+
+		case GUARD_INTERVAL_AUTO:
+			iwFormat[0] = 1;
+			iwFormat[1] = 0;
+			break;
+	}
+
+	if (iwFormat[1] == GI_ILLEGAL_VALUE) {
+		wpa_printf(MSG_WARNING, "illegal guard interval value %d\n", sFixedLtfGi);
+		return;
+	}
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_FIXED_LTF_AND_GI,
+		(u8*)iwFormat, sizeof(iwFormat), NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set guard interval failed");
+}
+
+static void hostapd_post_up_vendor_radio_cmd(struct hostapd_iface *iface)
+{
+	struct hostapd_data *hapd = iface->bss[0];
+	int ap_retry_limit_cfg[2];
+
+	if (iface->conf->sErpSet) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_ERP,
+						(u8*)iface->conf->sErpSet, ERP_SET_SIZE * sizeof(int),
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sErpSet failed");
+	}
+
+	if (iface->conf->sRadarRssiTh) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_RADAR_RSSI_TH,
+						(u8*)&iface->conf->sRadarRssiTh, sizeof(iface->conf->sRadarRssiTh),
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sRadarRssiTh failed");
+	}
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_RTS_MODE,
+					(u8*)iface->conf->sRTSmode, sizeof(iface->conf->sRTSmode),
+					NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set sRTSmode failed");
+
+
+	if (iface->conf->sFixedRateCfg) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_FIXED_RATE,
+						(u8*)iface->conf->sFixedRateCfg, FIXED_RATE_CONFIG_SIZE  * sizeof(int),
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sFixedRateCfg failed");
+	}
+
+	if (iface->conf->sQAMplus != -1) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_QAMPLUS_MODE,
+				(u8*)&iface->conf->sQAMplus, sizeof(iface->conf->sQAMplus),
+				NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sQAMplus failed");
+	}
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_CCA_ADAPT,
+					(u8*)iface->conf->sCcaAdapt, sizeof(iface->conf->sCcaAdapt),
+					NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set sCcaAdapt failed");
+
+	if (iface->conf->sFWRecovery) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_FW_RECOVERY,
+						(u8*)iface->conf->sFWRecovery, iface->conf->sFWRecoverySize,
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sFWRecovery failed");
+	}
+
+	/* Set AP retry limit only if user configured this */
+	ap_retry_limit_cfg[0] = iface->conf->ap_retry_limit;
+	ap_retry_limit_cfg[1] = iface->conf->ap_retry_limit_data;
+	if ((ap_retry_limit_cfg[0] != AP_RETRY_INVALID) ||
+			(ap_retry_limit_cfg[1] != AP_RETRY_INVALID)) {
+
+		if (ap_retry_limit_cfg[0] == AP_RETRY_INVALID)
+			ap_retry_limit_cfg[0] = AP_TX_RETRY_LIMIT_DEFAULT;
+
+		if (ap_retry_limit_cfg[1] == AP_RETRY_INVALID)
+			ap_retry_limit_cfg[1] = AP_TX_RETRY_LIMIT_DEFAULT_DATA;
+
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_AP_RETRY_LIMIT,
+					(u8*)ap_retry_limit_cfg, sizeof(ap_retry_limit_cfg),
+					NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set ap_retry_limit %d failed", iface->conf->ap_retry_limit);
+	}
+
+	hostapd_post_up_vendor_cmd_mu_type(hapd, iface->conf);
+	hostapd_post_up_vendor_cmd_guard_interval(hapd, iface->conf->sFixedLtfGi, iface->conf->ieee80211ax, iface->conf->ieee80211ac);
+}
 
 static void hostapd_interface_setup_failure_handler(void *eloop_ctx,
 						    void *timeout_ctx)
@@ -2553,7 +2779,6 @@ static void hostapd_interface_setup_failure_handler(void *eloop_ctx,
 		hapd->setup_complete_cb(hapd->setup_complete_cb_ctx);
 }
 
-
 static void hostapd_prepare_csa_deauth_frame(struct hostapd_data *hapd, u8 *mgmt_frame_buf, u8 *mgmt_frame_buf_len)
 {
 	errno_t err;
@@ -2959,6 +3184,7 @@ dfs_offload:
 	if (iface->interfaces && iface->interfaces->count > 1)
 		ieee802_11_set_beacons(iface);
 
+	hostapd_post_up_vendor_radio_cmd(iface);
 	return 0;
 
 fail:
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index 781d9b307..4c7d444ff 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -29,9 +29,21 @@
 	((hapd->conf->oce & OCE_AP) && \
 	 (hapd->iface->drv_flags & WPA_DRIVER_FLAGS_OCE_AP))
 
-#define MIN_NUM_BSS_IN_NON_MBSSID_SET	2 /* Non MultiBSS : Master(Dummy VAP) + one or more operational VAPs */
-#define MIN_NUM_BSS_IN_MBSSID_SET		3 /* MultiBSS: Master(Dummy VAP) + one TX VAP + one or more Non TX VAPs */
-#define NUM_NON_TX_VAPS(num_bss)		(num_bss - MIN_NUM_BSS_IN_NON_MBSSID_SET)
+typedef enum {
+	GUARD_INTERVAL_400	= 0x01,
+	GUARD_INTERVAL_800	= 0x02,
+	GUARD_INTERVAL_1600	= 0x04,
+	GUARD_INTERVAL_3200	= 0x08,
+	GUARD_INTERVAL_AUTO	= 0x10,
+} GUARD_INTERVAL_t;
+
+typedef enum {
+	GI_CP_MODE_SHORT_CP_SHORT_LTF	= 0,
+	GI_CP_MODE_MED_CP_SHORT_LTF		= 1,
+	GI_CP_MODE_SHORT_CP_MED_LTF		= 2,
+	GI_CP_MODE_MED_CP_MED_LTF		= 3,
+	GI_CP_MODE_LONG_CP_LONG_LTF		= 5,
+} GI_CP_MODE_t;
 
 struct wpa_ctrl_dst;
 struct radius_server_data;
diff --git a/src/ap/mxl_hostapd.c b/src/ap/mxl_hostapd.c
index c390908cd..983377a6d 100644
--- a/src/ap/mxl_hostapd.c
+++ b/src/ap/mxl_hostapd.c
@@ -373,12 +373,57 @@ void mxl_hostapd_driver_init(struct hostapd_iface *iface, struct wpa_init_params
 
 void mxl_hostapd_setup_interface_pre(struct hostapd_iface *iface)
 {
+	int srxThVal = SRX_TH_VAL;
 	struct hostapd_data *hapd = iface->bss[0];
 	struct mxl_hostapd_iface *mxl_iface = &iface->mxl_iface;
 	struct mxl_hostapd_config *mxl_conf = &iface->conf->mxl_conf;
 
 	iface->mxl_iface.sb_dfs_cntr = 0;
 
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_TX_POWER_LIMIT_OFFSET,
+					(u8*)&iface->conf->sPowerSelection, sizeof(iface->conf->sPowerSelection),
+					NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set sPowerSelection failed");
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_RX_THRESHOLD,
+					(u8*)&srxThVal, sizeof(srxThVal), NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set srxThVal failed");
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_STATIONS_STATISTICS,
+					(u8*)&iface->conf->sStationsStat,
+					sizeof(iface->conf->sStationsStat), NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set sStationsStat failed");
+
+	if (iface->conf->sConfigMRCoex != -1) {
+		int sConfigMRCoex[4] = {iface->conf->sConfigMRCoex, -1, -1, -1};
+		if (iface->conf->sConfigMRCoexActiveTime) {
+			sConfigMRCoex[1] = iface->conf->sConfigMRCoexActiveTime;
+		}
+		if (iface->conf->sConfigMRCoexInactiveTime) {
+			sConfigMRCoex[2] = iface->conf->sConfigMRCoexInactiveTime;
+		}
+		if (iface->conf->sConfigMRCoexCts2SelfActive) {
+			sConfigMRCoex[3] = iface->conf->sConfigMRCoexCts2SelfActive;
+		}
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_COEX_CFG,
+						(u8*)sConfigMRCoex, sizeof(sConfigMRCoex), NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sConfigMRCoex failed");
+	}
+
+	if (iface->conf->sCoCPower) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_COC_POWER_MODE,
+						(u8*)iface->conf->sCoCPower, iface->conf->sCoCPowerSize * sizeof(int),
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sCoCPower failed");
+	}
+
+	if (iface->conf->sCoCAutoCfg) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_COC_AUTO_PARAMS,
+						(u8*)iface->conf->sCoCAutoCfg, COC_AUTO_CONFIG * sizeof(int),
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sCoCAutoCfg failed");
+	}
+
 	if (mxl_iface->allow_scan_during_cac == -1) {
 		if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_ALLOW_SCAN_DURING_CAC,
 				       &mxl_conf->allow_scan_during_cac, sizeof(mxl_conf->allow_scan_during_cac)))
@@ -387,6 +432,30 @@ void mxl_hostapd_setup_interface_pre(struct hostapd_iface *iface)
 			mxl_iface->allow_scan_during_cac = mxl_conf->allow_scan_during_cac;
 
 	}
+
+	if (iface->conf->sBfMode != -1) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_BF_MODE,
+						(u8*)&iface->conf->sBfMode, sizeof(iface->conf->sBfMode),
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sBfMode failed");
+	}
+
+	if (iface->conf->sMaxMpduLen != -1) {
+		if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_MAX_MPDU_LENGTH,
+						(u8*)&iface->conf->sMaxMpduLen, sizeof(iface->conf->sMaxMpduLen),
+						NESTED_ATTR_NOT_USED, NULL))
+			wpa_printf(MSG_WARNING, "set sMaxMpduLen failed");
+	}
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_CLT_PROBE_REQS_MODE,
+					(u8*)&iface->conf->sProbeReqCltMode, sizeof(iface->conf->sProbeReqCltMode),
+					NESTED_ATTR_NOT_USED, NULL))
+		wpa_printf(MSG_WARNING, "set sProbeReqCltMode failed");
+
+	if (hostapd_drv_vendor_cmd(hapd, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_INTERFER_THRESH,
+					(u8*)&iface->conf->sInterferDetThresh, sizeof(iface->conf->sInterferDetThresh),
+					NESTED_ATTR_NOT_USED,NULL))
+		wpa_printf(MSG_WARNING, "set sInterferDetThresh failed");
 }
 
 int mxl_hostapd_get_secondary_offset(int primary, int bandwidth, int center_idx)
diff --git a/src/common/defs.h b/src/common/defs.h
index def69b020..a1cde10d9 100644
--- a/src/common/defs.h
+++ b/src/common/defs.h
@@ -437,9 +437,22 @@ enum beacon_rate_type {
 	BEACON_RATE_HE
 };
 
+#define MGMT_FRAMES_RATE_DISABLED		0xFF
+#define MGMT_FRAMES_RATE_ENABLED_MIN	0
+#define MGMT_FRAMES_RATE_ENABLED_MAX	7
+#define MGMT_FRAMES_RATE_DEFAULT		MGMT_FRAMES_RATE_DISABLED
 enum eap_proxy_sim_state {
 	SIM_STATE_ERROR,
 };
+enum dynamic_multicast_mode {
+	DYNAMIC_MC_DISABLE		= 0,
+	DYNAMIC_MC_MODE_DYNAMIC	= 1,
+	DYNAMIC_MC_MODE_STATIC	= 2,
+};
+enum dynamic_mc_rate {
+	DYNAMIC_MC_RATE_MIN	= 1,
+	DYNAMIC_MC_RATE_MAX	= 54,
+};
 
 #define OCE_STA BIT(0)
 #define OCE_STA_CFON BIT(1)
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index dce9d4c19..0400fb714 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -5197,6 +5197,14 @@ struct wpa_driver_ops {
 	 */
 	int (*link_add)(void *priv, u8 link_id, const u8 *addr);
 
+	/**
+	 * set_management_frames_rate - Set management frames rate
+	 * @priv: Private driver interface data
+	 * @management_frames_rate - value of management frames rate
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int(*set_management_frames_rate)(void *priv, const u8 management_frames_rate);
+
 	/**
 	 * sta_steer - Steer station to required VAP
 	 * @priv: Private driver interface data
@@ -5232,6 +5240,15 @@ struct wpa_driver_ops {
 	 */
 	int(*set_mbssid_vap_mode)(void *priv, const u8 mbssid_vap);
 
+	/**
+	 * set_dynamic_mc_mode_rate - Set Dynamic multicast mode and rate on VAP
+	 * @priv: Private driver interface data
+	 * @dynamic_mc_mode: 0 - Disable, 1 - Dynamic, 2 - Static
+	 * @dynamic_mc_rate: Rate for dynamic multicast
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int(*set_dynamic_mc_mode_rate)(void *priv, int dynamic_mc_mode, int dynamic_mc_rate);
+
 	/**
 	 * set_mbssid_num_vaps_in_group - Set number of VAPs in MultiBSSID group
 	 * @priv: Private driver interface data
@@ -5240,6 +5257,14 @@ struct wpa_driver_ops {
 	 */
 	int(*set_mbssid_num_vaps_in_group)(void *priv, const u8 mbssid_num_vaps_in_group);
 
+	/**
+	 * set_whm_config - enable/disable whm in driver and fw
+	 * @priv: Private driver interface data
+	 * @whm_cfg_flag : whm config
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*set_whm_config)(void *priv, int whm_cfg_flag);
+
 	/**
 	 * get_tx_power_20mhz - get tx power for 20mhz bandwidth
 	 * @priv: Private driver interface data
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 23a293250..90c03b73d 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -69,6 +69,11 @@ enum nlmsgerr_attrs {
 #endif
 
 
+static int nl80211_vendor_cmd(void *priv, unsigned int vendor_id,
+							  unsigned int subcmd, const u8 *data,
+							  size_t data_len, enum nested_attr nested_attr,
+							  struct wpabuf *buf);
+
 #ifdef ANDROID
 /* system/core/libnl_2 does not include nl_socket_set_nonblocking() */
 #undef nl_socket_set_nonblocking
@@ -8153,6 +8158,37 @@ static int i802_read_sta_data(struct i802_bss *bss,
 				  NULL, NULL, NULL);
 }
 
+int nl80211_set_management_frames_rate(void *priv, const u8 management_frames_rate)
+{
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "nl80211: sending SET_MGMT_FRAMES_RATE: %u", management_frames_rate);
+
+	ret = nl80211_vendor_cmd(priv, OUI_LTQ, LTQ_NL80211_VENDOR_SUBCMD_SET_MGMT_FRAMES_RATE,
+							 &management_frames_rate, 1, NESTED_ATTR_NOT_USED, NULL);
+
+	if (ret < 0) {
+		wpa_printf(MSG_ERROR, "nl80211: sending SET_MGMT_FRAMES_RATE failed: %i (%s)",
+				   ret, strerror(-ret));
+	}
+	return ret;
+}
+
+int nl80211_set_dynamic_mc_mode_rate(void *priv, int mode, int rate)
+{
+	int ret;
+	int dynamic_multicast_cfg[] = {mode, rate};
+
+	ret = nl80211_vendor_cmd(priv, OUI_LTQ,
+					LTQ_NL80211_VENDOR_SUBCMD_SET_FAST_DYNAMIC_MC_RATE,
+					(u8 *)dynamic_multicast_cfg, sizeof(dynamic_multicast_cfg),
+					NESTED_ATTR_NOT_USED, NULL);
+	if (ret < 0)
+		wpa_printf(MSG_ERROR,
+			   "nl80211: SET_FAST_DYNAMIC_MC_RATE CMD failed: %i (%s)",
+			   ret, strerror(-ret));
+	return ret;
+}
 
 static int i802_set_tx_queue_params(void *priv, int queue, int aifs,
 				    int cw_min, int cw_max, int burst_time,
@@ -14071,6 +14107,21 @@ static int nl80211_sta_allow(void *priv, const u8 *stations, int count)
 	return final_ret;
 }
 
+int nl80211_set_whm_config(void *priv, int whm_cfg_flag)
+{
+	int ret;
+
+	ret = nl80211_vendor_cmd(priv, OUI_LTQ,
+				 LTQ_NL80211_VENDOR_SUBCMD_SET_WHM_CONFIG,
+				 (u8 *) &whm_cfg_flag, sizeof(whm_cfg_flag),
+				 NESTED_ATTR_NOT_USED, NULL);
+	if (ret < 0)
+		wpa_printf(MSG_ERROR,
+			   "nl80211: SET_WHM_CONFIG CMD failed: %i (%s)",
+			   ret, strerror(-ret));
+	return ret;
+}
+
 static int nl80211_unconnected_sta(void *priv, struct intel_vendor_unconnected_sta_req_cfg *req)
 {
 	int res = 0;
@@ -14313,6 +14364,7 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.update_connect_params = nl80211_update_connection_params,
 	.send_external_auth_status = nl80211_send_external_auth_status,
 	.set_4addr_mode = nl80211_set_4addr_mode,
+	.set_management_frames_rate = nl80211_set_management_frames_rate,
 	.sta_steer = nl80211_sta_steer,
 	.sta_allow = nl80211_sta_allow,
 	.unconnected_sta = nl80211_unconnected_sta,
@@ -14320,11 +14372,13 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.set_mbssid_num_vaps_in_group = nl80211_set_mbssid_num_vaps_in_group,
 	.get_tx_power_20mhz = nl80211_get_tx_power_20mhz,
 	.set_bss_load = nl80211_set_bss_load,
+	.set_dynamic_mc_mode_rate = nl80211_set_dynamic_mc_mode_rate,
 #ifdef CONFIG_DPP
 	.dpp_listen = nl80211_dpp_listen,
 #endif /* CONFIG_DPP */
 	.get_sta_mlo_info = nl80211_get_sta_mlo_info,
 	.link_add = nl80211_link_add,
+	.set_whm_config = nl80211_set_whm_config,
 #ifdef CONFIG_TESTING_OPTIONS
 	.register_frame = testing_nl80211_register_frame,
 	.radio_disable = testing_nl80211_radio_disable,
-- 
2.43.0

