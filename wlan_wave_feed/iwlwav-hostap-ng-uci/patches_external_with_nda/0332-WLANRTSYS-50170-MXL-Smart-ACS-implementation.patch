From 001b9eee856fc3ecf31648ef3498d0b93fb5a892 Mon Sep 17 00:00:00 2001
From: spatel <spatel@maxlinear.com>
Date: Thu, 10 Oct 2024 15:42:40 +0530
Subject: [PATCH] WLANRTSYS-50170 [MXL] Smart ACS implementation

---
 LICENSE                               |  144 +
 hostapd/Makefile                      |    8 +
 hostapd/config_file.c                 |    3 +
 hostapd/ctrl_iface.c                  |   30 +
 hostapd/main.c                        |    5 +-
 hostapd/mxl_config.c                  |   29 +-
 hostapd/mxl_config_proprietary.c      |  480 ++++
 hostapd/mxl_ctrl_iface.c              |   14 +-
 hostapd/mxl_ctrl_iface.h              |    8 +
 hostapd/mxl_ctrl_iface_proprietary.c  |  368 +++
 hostapd/mxl_hostapd_cli.c             |    2 +-
 hostapd/mxl_hostapd_cli.h             |   31 +
 hostapd/mxl_hostapd_cli_proprietary.c |   99 +
 src/ap/acs.c                          |   38 +
 src/ap/ap_config.c                    |   14 +-
 src/ap/ap_drv_ops.c                   |   10 +-
 src/ap/dfs.c                          |   14 +
 src/ap/drv_callbacks.c                |    7 +
 src/ap/hostapd.c                      |   33 +
 src/ap/hostapd.h                      |    6 +
 src/ap/hw_features.c                  |   10 +
 src/ap/hw_features.h                  |    7 +
 src/ap/ieee802_11_ht.c                |   10 +
 src/ap/mxl_acs.c                      | 3802 +++++++++++++++++++++++++
 src/ap/mxl_acs.h                      |  179 ++
 src/ap/mxl_coexistence.c              |    9 +
 src/ap/mxl_config.h                   |   81 +-
 src/ap/mxl_dfs_common.c               |   32 +-
 src/ap/mxl_dfs_file.c                 |    1 -
 src/ap/mxl_events.c                   |   53 +
 src/ap/mxl_hostapd.c                  |   23 +
 src/ap/mxl_hostapd.h                  |   56 +
 src/ap/mxl_hostapd_proprietary.c      |   40 +
 src/ap/mxl_rrm.c                      |    5 +-
 src/ap/mxl_sub_band_dfs.c             |   39 +
 src/ap/mxl_zwdfs.c                    |   73 +-
 src/ap/mxl_zwdfs.h                    |    2 +
 src/common/ieee802_11_common.c        |    7 +
 src/common/ieee802_11_common.h        |    6 +
 src/common/mxl_defs.h                 |    5 +
 src/common/mxl_ieee802_11_common.c    |   18 +
 src/common/mxl_ieee802_11_common.h    |    4 +
 src/common/mxl_ieee802_11_defs.h      |    2 +-
 src/common/mxl_vendor.h               |    3 +
 src/common/vendor_cmds_copy.h         |   29 +
 src/drivers/driver.h                  |    4 +
 src/drivers/driver_nl80211.c          |   27 +
 src/drivers/driver_nl80211.h          |    4 +
 src/drivers/driver_nl80211_event.c    |   21 +-
 src/drivers/driver_nl80211_scan.c     |    7 +
 src/drivers/mxl_driver_nl80211.c      |   15 +
 src/drivers/mxl_driver_nl80211.h      |    3 +
 wpa_supplicant/Makefile               |    3 +
 wpa_supplicant/mxl_supplicant.c       |   18 +
 wpa_supplicant/mxl_supplicant.h       |    3 +
 wpa_supplicant/scan.c                 |   13 +
 wpa_supplicant/wpa_supplicant.c       |    3 +
 wpa_supplicant/wpa_supplicant_i.h     |    3 +
 58 files changed, 5945 insertions(+), 18 deletions(-)
 create mode 100644 LICENSE
 create mode 100644 hostapd/mxl_config_proprietary.c
 create mode 100644 hostapd/mxl_ctrl_iface_proprietary.c
 create mode 100644 hostapd/mxl_hostapd_cli_proprietary.c
 create mode 100644 src/ap/mxl_acs.c
 create mode 100644 src/ap/mxl_acs.h
 create mode 100644 src/ap/mxl_hostapd_proprietary.c

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 000000000..1e7c3b556
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,144 @@
+LICENSE
+
+All files that have the prefix mxl_ in their name are bound by the license
+that appears in this LICENSE file, following the title "MaxLinear Software 
+License Agreement".
+
+All other files are bound by the wpa_supplicant and hostapd license that is 
+described in the file named README.
+
+
+
+			MaxLinear Software License Agreement
+
+
+1.	Introduction and Acceptance.  This Software License Agreement (this
+"Agreement") is a legal agreement between you (either an individual or an
+entity) and MaxLinear, Inc. ("MaxLinear") regarding the use of the MaxLinear
+software accompanying this Agreement, which includes documentation provided in
+"online" or electronic form (together, the "Software"). MAXLINEAR PROVIDES THE
+SOFTWARE SOLELY ON THE TERMS AND CONDITIONS SET FORTH IN THIS AGREEMENT AND ON
+THE CONDITION THAT YOU ACCEPT AND COMPLY WITH THEM. BY DOWNLOADING,
+DISTRIBUTING, MODIFYING OR OTHERWISE USING THE SOFTWARE, YOU (A) ACCEPT THIS
+AGREEMENT AND AGREE THAT YOU ARE LEGALLY BOUND BY ITS TERMS; AND (B) REPRESENT
+AND WARRANT THAT: (I) YOU ARE OF LEGAL AGE TO ENTER INTO A BINDING AGREEMENT;
+AND (II) IF YOUR ARE A CORPORATION, GOVERNMENTAL ORGANIZATION OR OTHER LEGAL
+ENTITY, YOU HAVE THE RIGHT, POWER AND AUTHORITY TO ENTER INTO THIS AGREEMENT
+ON BEHALF OF SUCH ENTITY AND BIND SUCH ENTITY TO THESE TERMS. IF YOU DO NOT
+AGREE TO THE TERMS OF THIS AGREEMENT, MAXLINEAR WILL NOT AND DOES NOT LICENSE
+THE SOFTWARE TO YOU AND YOU MUST NOT DOWNLOAD, INSTALL OR OTHERWISE USE THE
+SOFTWARE OR DOCUMENTATION.
+
+2.	Grant of License.  Subject to your compliance with the restrictions set
+forth in this Agreement, MaxLinear hereby grants to you a non-exclusive,
+non-transferable license during the Term to install, copy, use, distribute in
+binary form only, and host the Software. If you received the Software from
+MaxLinear in source code format, you may also modify the Software.
+
+3.	Ownership.  The license granted to you in Section 2 is not a transfer or
+sale of MaxLinear's ownership rights in or to the Software. Except for the
+license granted in Section 2, MaxLinear retains all right, title and interest
+(including all intellectual property rights) in and to the Software. The
+Software is protected by applicable intellectual property laws, including
+United States copyright laws and international treaties.
+
+4.	Third Party Materials. The Software may include software, content,
+data or other materials, including related documentation and open source
+software, that are owned by one or more third parties and that are subject to
+separate licensee terms ("Third-Party Licenses"). A list of all materials, if
+any, can be found the documentation for the Software. You acknowledge and agree
+that such third party materials subject to Third-Party Licenses are not licensed
+to you pursuant to the provisions of this Agreement and that this Agreement
+shall not be construed to grant any such right and/or license. You shall have
+only such rights and/or licenses, if any, to use such third party materials as
+set forth in the applicable Third-Party Licenses.
+
+5.	License Restrictions.  You may not remove or destroy any copyright
+notices or other proprietary markings. You may use the Software only with or on
+MaxLinear silicon products. Any other use, modification, translation, or
+compilation of the Software is prohibited. You may not use, modify, host, or
+distribute the Software so that any part of the Software becomes subject to
+any license that requires, as a condition of use, modification, hosting, or
+distribution, that (a) the Software, in whole or in part, be disclosed or
+distributed in source code form or (b) any third party have the right to
+modify the Software, in whole or in part.
+
+6.	Feedback.  If you provide any feedback to MaxLinear concerning the
+functionality and performance of the Software, including identifying potential
+errors and improvements ("Feedback"), such Feedback shall be owned by
+MaxLinear. You hereby assign to MaxLinear all right, title, and interest in
+and to the Feedback, and MaxLinear is free to use the Feedback without any
+payment or restriction.
+
+7.	Confidentiality.  You must hold in the strictest confidence the Software
+and any related materials or information including, but not limited to, any
+Feedback, technical data, research, product plans, or know-how provided by
+MaxLinear to you, directly or indirectly in writing, orally or by inspection
+of tangible objects ("Confidential Information"). You will not disclose any
+Confidential Information to third parties, including any of your employees who
+do not have a need to know such information, and you will take reasonable
+measures to protect the secrecy of, and to avoid disclosure and unauthorized
+use of, the Confidential Information. You will immediately notify the
+MaxLinear in the event of any unauthorized or suspected use or disclosure of
+the Confidential Information. To protect the Confidential Information
+contained in the Software, you may not reverse engineer, decompile, or
+disassemble the Software, except to the extent the foregoing restriction is
+expressly prohibited by applicable law.
+
+8.	Termination.  This Agreement will terminate upon the earlier of:
+(a) your failure to comply with any term of this Agreement; or (b) return,
+destruction, or deletion of all copies of the Software in your possession.
+MaxLinear's rights and your obligations will survive the termination of this
+Agreement. The "Term"? means the period beginning on when this Agreement becomes
+effective until the termination of this Agreement. Upon termination of this
+Agreement for any reason, you will delete from all of your computer libraries or
+storage devices or otherwise destroy all copies of the Software and derivatives
+thereof.
+
+9.	NO OTHER WARRANTIES.  THE SOFTWARE IS PROVIDED ON AN "AS IS"?BASIS. YOU
+ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
+INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
+FROM THE SOFTWARE. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+MAXLINEAR DISCLAIMS ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY, QUALITY, ACCURACY,
+TITLE, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE WITH RESPECT TO
+THE SOFTWARE AND THE ACCOMPANYING WRITTEN MATERIALS. THERE IS NO WARRANTY
+AGAINST INTERFERENCE WITH THE ENJOYMENT OF THE SOFTWARE OR AGAINST
+INFRINGEMENT. THERE IS NO WARRANTY THAT THE SOFTWARE OR MAXLINEAR'S EFFORTS
+WILL FULFILL ANY OF YOUR PARTICULAR PURPOSES OR NEEDS.
+
+10.	LIMITATION OF LIABILITY.  UNDER NO CIRCUMSTANCES WILL MAXLINEAR BE
+LIABLE FOR ANY CONSEQUENTIAL, SPECIAL, INDIRECT, INCIDENTAL OR PUNITIVE DAMAGES
+WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS
+PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, LOSS OF DATA OR
+OTHER SUCH PECUNIARY LOSS) ARISING OUT OF THE USE OR INABILITY TO USE THE
+SOFTWARE, EVEN IF MAXLINEAR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES. IN NO EVENT WILL MAXLINEAR'S AGGREGATE LIABILITY FOR DAMAGES ARISING
+OUT OF THIS AGREEMENT EXCEED $5. THE FOREGOING EXCLUSIONS AND LIMITATIONS OF
+LIABILITY AND DAMAGES WILL NOT APPLY TO CONSEQUENTIAL DAMAGES FOR PERSONAL
+INJURY.
+
+11.	Indemnification.  You will indemnify, hold harmless, and defend
+MaxLinear (including all of its officers, employees, directors, subsidiaries,
+representatives, affiliates, and agents) and MaxLinear's suppliers from and
+against any damages (including attorney's fees and expenses), claims, and
+lawsuits that arise or result from your use of the Software.
+
+12.	Trademarks.  Certain of the product and MaxLinear names used in this
+Agreement, the Software may constitute trademarks of MaxLinear or third
+parties. You are not authorized to use any such trademarks.
+
+13.	Export Restrictions.  YOU UNDERSTAND AND AGREE THAT THE SOFTWARE IS
+SUBJECT TO UNITED STATES AND OTHER APPLICABLE EXPORT-RELATED LAWS AND
+REGULATIONS AND THAT YOU MAY NOT EXPORT, RE-EXPORT OR TRANSFER THE SOFTWARE OR
+ANY DIRECT PRODUCT OF THE SOFTWARE EXCEPT AS PERMITTED UNDER THOSE LAWS.
+WITHOUT LIMITING THE FOREGOING, EXPORT, RE-EXPORT, OR TRANSFER OF THE SOFTWARE
+TO CUBA, IRAN, NORTH KOREA, SYRIA, RUSSIA, BELARUS, AND THE REGIONS OF CRIMEA,
+LNR, AND DNR OF UKRAINE IS PROHIBITED.
+
+14.	General.  This Agreement is governed by the laws of the State of
+California, without reference to its conflict of laws principles. This
+Agreement is the entire agreement between you and MaxLinear and supersedes any
+other communications with respect to the Software. If any provision of this
+Agreement is held invalid or unenforceable, the remainder of this Agreement
+will continue in full force and effect.
diff --git a/hostapd/Makefile b/hostapd/Makefile
index bea6b4104..20f4f5874 100644
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -409,6 +409,14 @@ OBJS += ../src/ap/mxl_sta_info.o
 OBJS += ../src/ap/mxl_utils.o
 OBJS += ../src/ap/mxl_wmm.o
 OBJS += ../src/ap/mxl_csa.o
+ifndef CONFIG_MXL_OSS_BUILD
+CFLAGS+= -DCONFIG_VENDOR_MXL_PROPRIETARY
+OBJS += ../src/ap/mxl_acs.o
+OBJS_c += mxl_hostapd_cli_proprietary.o
+OBJS += mxl_config_proprietary.o
+OBJS += mxl_ctrl_iface_proprietary.o
+OBJS += ../src/ap/mxl_hostapd_proprietary.o
+endif
 ifdef CONFIG_AFC
 OBJS += ../src/ap/mxl_afc.o
 endif
diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index d862e3912..954d1658c 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -3979,6 +3979,9 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			conf->channel = atoi(pos);
 			conf->acs = conf->channel == 0;
 		}
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		mxl_hostapd_config_fill_acs(conf, pos);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #ifdef CONFIG_ACS
 	} else if (os_strcmp(buf, "acs_unii4") == 0) {
 		int val = atoi(pos);
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 337017af4..3d58a03a6 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -2978,6 +2978,14 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 		settings.freq_params.eht_enabled = iface->conf->ieee80211be;
 	}
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	/* Set this flag to enable bg CAC after bg ACS*/
+	if (settings.freq_params.freq == 0) {
+		iface->mxl_iface.dfs_bg_cac = true;
+	}
+
+	if (settings.freq_params.freq != 0)
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	ret = hostapd_ctrl_check_freq_params(&settings.freq_params,
 					     settings.punct_bitmap);
 	if (ret) {
@@ -3048,6 +3056,13 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 		break;
 	}
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	iface->conf->mxl_conf.acs_scan_mode = !!os_strstr(pos, " acs_scan_mode");
+	ret = mxl_hostapd_ctrl_iface_check_acs(iface, &settings, bandwidth);
+	if (ret <= 0)
+		return ret;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	if (settings.freq_params.center_freq1)
 		dfs_range += hostapd_is_dfs_overlap(
 			iface, bandwidth, settings.freq_params.center_freq1);
@@ -3134,7 +3149,10 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 			   settings.freq_params.bandwidth,
 			   settings.freq_params.center_freq1);
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
 		/* Perform CAC and switch channel */
+		iface->conf->acs = 0;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		if (!iface->cac_started && switch_type_scan)
 			iface->block_tx = true;
 		hostapd_switch_channel_fallback(iface, &settings.freq_params);
@@ -3166,6 +3184,9 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 
 #endif /* CONFIG_VENDOR_MXL */
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	iface->conf->acs = 0;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	return 0;
 #else /* NEED_AP_MLME */
 	return -1;
@@ -5076,6 +5097,10 @@ static int hostapd_ctrl_iface_get_radio_state (enum hostapd_iface_state state)
 	switch (state) {
 	case HAPD_IFACE_ENABLED:
 		return 1;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	case HAPD_IFACE_ACS_DONE:
+		return 2;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	default:
 		return 0;
 	}
@@ -8239,6 +8264,11 @@ void hostapd_global_ctrl_iface_deinit(struct hapd_interfaces *interfaces)
 	os_free(interfaces->global_iface_path);
 	interfaces->global_iface_path = NULL;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	/* Free RNR Info */
+	mxl_ieee80211_rnr_info_delete(&interfaces->rnr_scan_6g_ap_info);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	dl_list_for_each_safe(dst, prev, &interfaces->global_ctrl_dst,
 			      struct wpa_ctrl_dst, list)
 		os_free(dst);
diff --git a/hostapd/main.c b/hostapd/main.c
index 5ac01bf03..53db09285 100644
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -263,7 +263,6 @@ static int hostapd_driver_init(struct hostapd_iface *iface)
 	params.ifname = hapd->conf->iface;
 	params.driver_params = hapd->iconf->driver_params;
 	params.use_pae_group_addr = hapd->conf->use_pae_group_addr;
-
 #ifdef CONFIG_VENDOR_MXL
 	mxl_hostapd_driver_init(iface, &params);
 #endif /* CONFIG_VENDOR_MXL */
@@ -827,6 +826,10 @@ int main(int argc, char *argv[])
 		return -1;
 #endif /* CONFIG_DPP */
 
+#ifdef CONFIG_VENDOR_MXL
+	dl_list_init(&interfaces.rnr_scan_6g_ap_info);
+#endif /* CONFIG_VENDOR_MXL */
+
 	for (;;) {
 		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:vg:G:q");
 		if (c < 0)
diff --git a/hostapd/mxl_config.c b/hostapd/mxl_config.c
index 1fdc2df97..43fdb9d95 100644
--- a/hostapd/mxl_config.c
+++ b/hostapd/mxl_config.c
@@ -13,6 +13,7 @@
 
 #include "utils/includes.h"
 #include "utils/common.h"
+#include "ap/hostapd.h"
 #include "ap/ap_config.h"
 #include "utils/mxl_common.h"
 #include "ap/mxl_config.h"
@@ -1560,7 +1561,6 @@ int mxl_hostapd_config_fill (struct hostapd_config *conf,
 {
 	struct mxl_hostapd_config *mxl_conf = &conf->mxl_conf;
 	struct mxl_hostapd_bss_config *mxl_bss_conf = &bss->mxl_bss_conf;
-	(void)mxl_bss_conf;
 
 	if (os_strcmp(buf, "scan_passive_dwell") == 0) {
 		int val = atoi(pos);
@@ -1691,6 +1691,10 @@ int mxl_hostapd_config_fill (struct hostapd_config *conf,
 			if (*pos != '\0') pos++;
 		}
 		pos = start;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	} else if(mxl_config_check_smart_acs_config(conf, bss, buf, pos, line)) {
+		return 1;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	} else if  (os_strcmp(buf, "allow_scan_during_cac") == 0) {
 		int val = atoi(pos);
 		if (!IS_VALID_BOOL_RANGE(val)) {
@@ -2002,6 +2006,10 @@ void mxl_hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 	/* no need to initlize with 0 or NULL - this is done by hostapd with memset */
 	struct mxl_hostapd_bss_config *mxl_bss_conf = &bss->mxl_bss_conf;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	mxl_bss_conf->scan_timeout = SCAN_TIMEOUT_DEFAULT;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	/* Soft Block ACL */
 	mxl_bss_conf->soft_block_acl_enable = SOFT_BLOCK_ENABLE_DEFAULT;
 	mxl_bss_conf->soft_block_acl_wait_time = SOFT_BLOCK_WAIT_TIME_DEFAULT;
@@ -2034,7 +2042,7 @@ void mxl_hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 	mxl_bss_conf->disable_pbac = false;
 }
 
-void mxl_hostapd_config_defaults(struct hostapd_config *conf)
+int mxl_hostapd_config_defaults(struct hostapd_config *conf)
 {
 
 #ifdef CONFIG_EPCS_MXL
@@ -2076,6 +2084,12 @@ void mxl_hostapd_config_defaults(struct hostapd_config *conf)
 	mxl_conf->epcs_wmm_ac_params[3] = epcs_ac_vo;
 #endif /* CONFIG_EPCS_MXL */
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if(mxl_hostapd_acs_config_defaults(conf)) {
+		return 1;
+	}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+	
 	/* Advertisement protocol IE */
 	conf->adv_proto_query_resp_len = ADV_PROTO_QUERY_RESP_LEN_DEFAULT;
 	/* To check client mode */
@@ -2101,6 +2115,7 @@ void mxl_hostapd_config_defaults(struct hostapd_config *conf)
 	mxl_conf->nlmsg_default_size = 8 * 1024;
 #endif
 
+	return 0;
 }
 
 void mxl_hostapd_config_free_bss(struct hostapd_bss_config *bss)
@@ -2114,6 +2129,10 @@ void mxl_hostapd_config_free(struct hostapd_config *conf)
 {
 	struct mxl_hostapd_config *mxl_conf = &conf->mxl_conf;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+        mxl_hostapd_config_free_acs(conf);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	os_free(mxl_conf->dfs_channels_state_file);
 }
 
@@ -2136,6 +2155,12 @@ int mxl_hostapd_config_check_bss_6g(struct hostapd_bss_config *bss) {
 int mxl_hostapd_config_check(struct hostapd_config *conf, int full_config)
 {
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if(mxl_hostapd_config_check_acs(conf,full_config)) {
+		return -1;
+	}
+#endif
+
 #ifdef CONFIG_IEEE80211BE_MXL_MLO
 	int i;
 	if (!conf->ieee80211be) {
diff --git a/hostapd/mxl_config_proprietary.c b/hostapd/mxl_config_proprietary.c
new file mode 100644
index 000000000..ed680d8ae
--- /dev/null
+++ b/hostapd/mxl_config_proprietary.c
@@ -0,0 +1,480 @@
+/******************************************************************************
+
+         Copyright (c) 2024, MaxLinear, Inc.
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+#include "utils/includes.h"
+#ifndef CONFIG_NATIVE_WINDOWS
+#include <grp.h>
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+#include "utils/common.h"
+#include "utils/uuid.h"
+#include "utils/crc32.h"
+#include "common/ieee802_11_defs.h"
+#include "common/sae.h"
+#include "drivers/driver.h"
+#include "ap/ap_config.h"
+#include "ap/hostapd.h"
+#include "ap/beacon.h"
+#include "ap/ap_drv_ops.h"
+
+static int hostapd_parse_opt_ch_list(int **int_list, char *val, int *ch_count, int op_class)
+{
+#define MAX_OPT_CH_LIST 5
+	int *list;
+	int count;
+	char *pos, *end;
+
+	os_free(*int_list);
+	*int_list = NULL;
+
+	pos = val;
+	count = 0;
+	while (*pos != '\0') {
+		if (*pos == ' ')
+			count++;
+		pos++;
+	}
+
+	if (count >= MAX_OPT_CH_LIST) {
+		wpa_printf(MSG_ERROR," %d exceeds MAX number of 6G Optional Channel List, Max allowed : %d", count, MAX_OPT_CH_LIST);
+		return -1;
+	}
+
+	list = os_malloc(sizeof(int) * (count + 2));
+	if (list == NULL)
+		return -1;
+	pos = val;
+	count = 0;
+	while (*pos != '\0') {
+		end = os_strchr(pos, ' ');
+		if (end)
+			*end = '\0'; /* WARN: input buf is modified */
+
+		/* Skip PSC channels */
+		if (is_6ghz_psc_frequency(hostapd_chan_to_freq(atoi(pos), op_class))) {
+			goto skip_psc;
+		}
+
+		/* accept only 6G - 20MHz channels */
+		if(center_idx_to_bw_6ghz(atoi(pos)) != 0) {
+			wpa_printf(MSG_ERROR,"Invalid scan channel for 6G - %d",atoi(pos));
+			os_free(list);
+			return -1;
+		}
+
+		list[count++] = atoi(pos);
+skip_psc:
+		if (!end)
+			break;
+		pos = end + 1;
+	}
+	list[count] = -1;
+
+	*ch_count = count;
+	*int_list = list;
+	return 0;
+}
+
+static int hostapd_parse_opclass_ch_list(struct acs_exclude **op_list, char *val, int *ch_count)
+{
+	struct acs_exclude *list;
+	int count=0, slash=0, coma=0, num=0;
+	char *pos, *end, *ch;
+
+	os_free(*op_list);
+	*op_list = NULL;
+
+	pos = val;
+	count = 0;
+	while (*pos != '\0') {
+		if (*pos == '/') {
+			coma = 0;
+			num = 0;
+			slash++;
+		}
+		else
+			num++;
+
+		if (*pos == ',') {
+			if (slash > 1) {
+				return -1;
+			}
+			slash = 0;
+			num = 0;
+			coma++;
+			count++;
+		}
+
+		if (num > 3 || coma > 1) {
+			return -1;
+		}
+
+		pos++;
+	}
+
+	list = os_malloc(sizeof(struct acs_exclude) * count);
+	if (list == NULL) {
+		return -1;
+	}
+	pos = val;
+	count = 0;
+	while (*pos != '\0') {
+		end = os_strchr(pos, ',');
+		if (end)
+			*end = '\0'; /* WARN: input buf is modified */
+
+		ch = os_strchr(pos, '/');
+		if (ch != NULL) {
+			list[count].op_class = atoi(pos);
+			list[count].channel = atoi(ch + 1);
+			count++;
+		}
+
+		if (!end)
+			break;
+		pos = end + 1;
+	}
+
+	*ch_count = count;
+	*op_list = list;
+	return 0;
+}
+
+int mxl_config_check_smart_acs_config(struct hostapd_config *conf, struct hostapd_bss_config *bss, const char *buf, char* pos, int line)
+{
+	struct mxl_hostapd_config *mxl_conf = &conf->mxl_conf;
+	struct mxl_hostapd_bss_config *mxl_bss_conf = &bss->mxl_bss_conf;
+	if (os_strcmp(buf, "acs_smart_info_file") == 0) {
+		os_free(mxl_conf->acs_smart_info_file);
+		mxl_conf->acs_smart_info_file = os_strdup(pos);
+	} else if (os_strcmp(buf, "acs_history_file") == 0) {
+		os_free(mxl_conf->acs_history_file);
+		mxl_conf->acs_history_file = os_strdup(pos);
+	} else if (os_strcmp(buf, "acs_use24overlapped") == 0) {
+		int val = atoi(pos);
+		mxl_conf->acs_use24overlapped = val;
+	} else if (os_strcmp(buf, "acs_bg_scan_do_switch") == 0) {
+		int val = atoi(pos);
+		if ((val != 0) && (val != 1)) {
+			wpa_printf(MSG_ERROR, "Line %d: Wrong value of acs_bg_scan_do_switch %d, must be 0 or 1",
+				line, val);
+			return 0;
+		}
+		mxl_conf->acs_bg_scan_do_switch = val;
+	} else if (os_strcmp(buf, "acs_update_do_switch") == 0) {
+		int val = atoi(pos);
+		if ((val != 0) && (val != 1)) {
+			wpa_printf(MSG_ERROR, "Line %d: Wrong value of acs_update_do_switch %d, must be 0 or 1",
+				line, val);
+			return 0;
+		}
+		mxl_conf->acs_update_do_switch = val;
+	}  else if (os_strcmp(buf, "acs_fallback_chan") == 0) {
+		if (3 != sscanf(pos, "%d %d %d", &mxl_conf->acs_fallback_chan.primary,
+						 &mxl_conf->acs_fallback_chan.secondary,
+						 &mxl_conf->acs_fallback_chan.width)) {
+			wpa_printf(MSG_ERROR, "Line %d: ACS SMART: invalid fallback channel %s",
+				line, pos);
+			return 0;
+		}
+	} else if (os_strcmp(buf, "acs_penalty_factors") == 0) {
+		int i = 0;
+		if (mxl_hostapd_parse_intlist(&mxl_conf->acs_penalty_factors, pos)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid ACS penalty factors list", line);
+			return 0;
+		}
+		/* it would be great to adopt a rule that "int-lists" contain their
+		 * element count in the member at index 0, then we wouldn't have to count...
+		*/
+		while (mxl_conf->acs_penalty_factors[i] >= 0)
+			i++;
+		if (i != ACS_NUM_PENALTY_FACTORS) {
+			wpa_printf(MSG_ERROR, "Line %d: ACS penalty factors list has %i elements instead of %i",
+				line, i, ACS_NUM_PENALTY_FACTORS);
+			return 0;
+		}
+		for (i = 0; i < ACS_NUM_PENALTY_FACTORS; i++) {
+			if (!IS_VALID_RANGE(mxl_conf->acs_penalty_factors[i], ACS_PEN_MIN, ACS_PEN_MAX)) {
+				wpa_printf(MSG_ERROR, "Line %d: Invalid ACS penalty factor %d, must be %d..%d",
+					line, mxl_conf->acs_penalty_factors[i], ACS_PEN_MIN, ACS_PEN_MAX);
+				return 0;
+			}
+		}
+	} else if (os_strcmp(buf, "acs_chan_cust_penalty") == 0) {
+		char *cur_pos = pos;
+
+		while (cur_pos) {
+			int penalty, chan;
+
+			if (sscanf(cur_pos, "%d:%d", &chan, &penalty)) {
+				if (!IS_VALID_RANGE(chan, 0 , ACS_MAX_CHANNELS)) {
+					wpa_printf(MSG_ERROR, "Line %d: invalid ACS channel penalty, channel out of range", line);
+					return 0;
+				}
+				if (!IS_VALID_RANGE(penalty, ACS_PEN_MIN, ACS_PEN_MAX)) {
+					wpa_printf(MSG_ERROR, "Line %d: invalid ACS channel penalty, penalty out of range", line);
+					return 0;
+				}
+				mxl_conf->acs_chan_cust_penalty[chan] = penalty;
+			}
+
+			cur_pos = strchr(cur_pos, ',');
+			if (cur_pos) cur_pos++;
+		}
+	} else if (os_strcmp(buf, "acs_noise_threshold") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, ACS_NOISE_THR_MIN, ACS_NOISE_THR_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: ACS invalid noise threshold %d", line, val);
+			return 0;
+		}
+		mxl_conf->acs_noise_threshold = val;
+	} else if (os_strcmp(buf, "acs_policy") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid channel selection mode %d", line, val);
+			return 0;
+		}
+		mxl_conf->acs_policy = val;
+	} else if (os_strcmp(buf, "acs_switch_thresh") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, 0, ACS_SWITCH_THRESHOLD)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid channel switch threshold %d", line, val);
+			return 0;
+		}
+		mxl_conf->acs_switch_thresh = val;
+	} else if (os_strcmp(buf, "acs_grp_priorities_throughput") == 0) {
+		int i = 0;
+		if (mxl_hostapd_parse_intlist(&mxl_conf->acs_grp_priorities_throughput, pos)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid ACS group priorities list (throughput policy)", line);
+			return 0;
+		}
+		for (i = 0; i < ACS_NUM_GRP_PRIORITIES; i++) {
+			if (!IS_VALID_RANGE(mxl_conf->acs_grp_priorities_throughput[i], 0, ACS_NUM_GRP_PRIORITIES - 1)) {
+				wpa_printf(MSG_ERROR, "Line %d: invalid ACS group priorities list entry (throughput policy) %i, priority > %i",
+					line, i, ACS_NUM_GRP_PRIORITIES);
+				return 0;
+			}
+			mxl_conf->acs_grp_prio_tp_map[mxl_conf->acs_grp_priorities_throughput[i]] = i;
+		}
+	} else if (os_strcmp(buf, "acs_grp_priorities_reach") == 0) {
+		int i = 0;
+		if (mxl_hostapd_parse_intlist(&mxl_conf->acs_grp_priorities_reach, pos)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid ACS group priorities list (reach policy)", line);
+			return 0;
+		}
+		for (i = 0; i < ACS_NUM_GRP_PRIORITIES; i++) {
+			if (!IS_VALID_RANGE(mxl_conf->acs_grp_priorities_reach[i], 0, ACS_NUM_GRP_PRIORITIES - 1)) {
+				wpa_printf(MSG_ERROR, "Line %d: invalid ACS group priorities list entry (reach policy) %i, priority > %i",
+					line, i, ACS_NUM_GRP_PRIORITIES);
+				return 0;
+			}
+			mxl_conf->acs_grp_prio_reach_map[mxl_conf->acs_grp_priorities_reach[i]] = i;
+		}
+	} else if (os_strcmp(buf, "acs_bw_comparison") == 0) {
+		int val = atoi(pos);
+		if(!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid BW comparison value %d, range is 0..1", line, val);
+			return 0;
+		}
+		mxl_conf->acs_bw_comparison = val;
+	} else if ((os_strcmp(buf, "acs_6g_opt_ch_list") == 0) && is_6ghz_op_class(conf->op_class)) {
+		if (hostapd_parse_opt_ch_list(&mxl_conf->acs_6g_opt_ch_list, pos, &mxl_conf->acs_6g_opt_ch_count, conf->op_class)) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid acs_6g_opt_ch_list value", line);
+			return 0;
+		}
+	} else if ((os_strcmp(buf, "acs_rnr_scan_timeout") == 0) && is_6ghz_op_class(conf->op_class)) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, 0, 30)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid acs_rnr_scan_timeout %d",line, val);
+			return 0;
+		}
+		mxl_conf->acs_rnr_scan_timeout = val;
+	} else if (os_strcmp(buf, "acs_strict_chanlist") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid acs_strict_chanlist value %d, range is 0..1", line, val);
+			return 0;
+		}
+		mxl_conf->acs_strict_chanlist = val;
+	} else if (os_strcmp(buf, "acs_chanlist_all_chans") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid acs_chanlist_all_chans value %d, range is 0..1", line, val);
+			return 0;
+		}
+		mxl_conf->acs_chanlist_all_chans = val;
+	} else if (os_strcmp(buf, "acs_scan_mode") == 0) {
+		mxl_conf->acs_scan_mode = atoi(pos);
+	} else if (os_strcmp(buf, "scan_timeout") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, SCAN_TIMEOUT_MIN, SCAN_TIMEOUT_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid scan timeout %d, must be between %d..%d",
+				line, val, SCAN_TIMEOUT_MIN, SCAN_TIMEOUT_MAX);
+			return 0;
+		}
+		mxl_bss_conf->scan_timeout = (u32)val;
+	} else if (os_strcmp(buf, "acs_bgscan_interval") == 0) {
+		u_int16_t val = (u16)atoi(pos);
+		if (!IS_VALID_RANGE(val, ACS_BGSCAN_INT_MIN, ACS_BGSCAN_INT_MAX) && val != 0) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid acs bgscan interval %d, must be between %d..%d",
+				line, val, ACS_BGSCAN_INT_MIN, ACS_BGSCAN_INT_MAX);
+			return 0;
+		}
+		mxl_conf->acs_bgscan_interval = val;
+	} else if (os_strcmp(buf, "acs_exclude_opclass_ch_list") == 0) {
+		if (hostapd_parse_opclass_ch_list(&mxl_conf->acs_exclude_opclass_ch_list, pos, &mxl_conf->acs_exclude_opclass_ch_count)) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid acs_exclude_opclass_ch_list value", line);
+			return 0;
+		}
+	} else {
+		return 0;
+	}
+	return 1;
+}
+
+#define ACS_NUM_GRP_PRIORITIES_SIZE (sizeof(int) * ACS_NUM_GRP_PRIORITIES)
+
+int mxl_hostapd_acs_config_defaults(struct hostapd_config *conf)
+{
+#ifdef CONFIG_ACS
+	int i;
+	int grp_priorities_throughput[ACS_NUM_GRP_PRIORITIES] = { 3, 2, 1, 0 };
+	int grp_priorities_reach[ACS_NUM_GRP_PRIORITIES] = { 0, 1, 2, 3 };
+	int acs_penalty_factors[ACS_NUM_PENALTY_FACTORS] = {ACS_PEN_DEFAULT, ACS_PEN_DEFAULT, ACS_PEN_DEFAULT, ACS_PEN_DEFAULT_WBSS};
+	struct hostapd_bss_config *bss = conf->bss[0];
+#endif /* CONFIG_ACS */
+
+	/* no need to initlize with 0 or NULL - this is done by hostapd with memset */
+	struct mxl_hostapd_config *mxl_conf = &conf->mxl_conf;
+
+	mxl_conf->ScanRssiTh = SCAN_RSSI_THRESHOLD_DEFAULT;
+
+#ifdef CONFIG_ACS
+	conf->acs_num_scans = 1; /* override open source parameter value */
+	mxl_conf->acs_algo = ACS_ALGO_SMART;
+
+	mxl_conf->acs_rnr_scan_timeout = 2; /* seconds */
+
+	/* SmartACS */
+	mxl_conf->acs_smart_info_file = strdup("/tmp/acs_smart_info.txt");
+	mxl_conf->acs_history_file = strdup("/tmp/acs_history.txt");
+	mxl_conf->acs_init_done = 0;
+	mxl_conf->acs_use24overlapped = 0;
+	mxl_conf->acs_bg_scan_do_switch = 0;
+	mxl_conf->acs_update_do_switch = 1;
+	mxl_conf->acs_noise_threshold = ACS_NOISE_THR_DEFAULT;
+	mxl_conf->acs_bgscan_interval = 0;
+
+	for (i = 0; i < ACS_MAX_CHANNELS; i++)
+		mxl_conf->acs_chan_cust_penalty[i] = ACS_PEN_DEFAULT;
+
+	mxl_conf->acs_fallback_chan.primary = 1;
+	mxl_conf->acs_fallback_chan.secondary = 0;
+	mxl_conf->acs_fallback_chan.width = 20;
+
+	mxl_conf->acs_penalty_factors = os_malloc(sizeof(acs_penalty_factors));
+	if (NULL == mxl_conf->acs_penalty_factors)
+		goto alloc_fail;
+	if (EOK != memcpy_s(mxl_conf->acs_penalty_factors, sizeof(acs_penalty_factors),
+			acs_penalty_factors, sizeof(acs_penalty_factors)))
+		goto memcpy_fail;
+
+	mxl_conf->acs_grp_priorities_throughput = os_malloc(ACS_NUM_GRP_PRIORITIES_SIZE);
+	if (NULL == mxl_conf->acs_grp_priorities_throughput)
+		goto alloc_fail;
+	if (EOK != memcpy_s(mxl_conf->acs_grp_priorities_throughput, ACS_NUM_GRP_PRIORITIES_SIZE,
+			grp_priorities_throughput, sizeof(grp_priorities_throughput)))
+		goto memcpy_fail;
+
+	for (i = 0; i < ACS_NUM_GRP_PRIORITIES; i++) {
+		mxl_conf->acs_grp_prio_tp_map[mxl_conf->acs_grp_priorities_throughput[i]] = i;
+	}
+
+	mxl_conf->acs_grp_priorities_reach = os_malloc(ACS_NUM_GRP_PRIORITIES_SIZE);
+	if (NULL == mxl_conf->acs_grp_priorities_reach)
+		goto alloc_fail;
+	if (EOK != memcpy_s(mxl_conf->acs_grp_priorities_reach, ACS_NUM_GRP_PRIORITIES_SIZE,
+			grp_priorities_reach, sizeof(grp_priorities_reach)))
+		goto memcpy_fail;
+
+	for (i = 0; i < ACS_NUM_GRP_PRIORITIES; i++) {
+		mxl_conf->acs_grp_prio_reach_map[mxl_conf->acs_grp_priorities_reach[i]] = i;
+	}
+
+	mxl_conf->acs_policy = 0;
+	mxl_conf->acs_switch_thresh = 20;
+	mxl_conf->acs_bw_comparison  =  0;
+
+	goto continue_no_fail;
+
+alloc_fail:
+	wpa_printf(MSG_ERROR, "Failed to allocate memory for configuration data.");
+
+memcpy_fail:
+	wpa_printf(MSG_ERROR, "%s: memcpy_s error", __func__);
+	if (mxl_conf->acs_grp_priorities_reach) os_free(mxl_conf->acs_grp_priorities_reach);
+	if (mxl_conf->acs_grp_priorities_throughput) os_free(mxl_conf->acs_grp_priorities_throughput);
+	if (mxl_conf->acs_penalty_factors) os_free(mxl_conf->acs_penalty_factors);
+	if (mxl_conf->acs_smart_info_file) os_free(mxl_conf->acs_smart_info_file);
+	if (mxl_conf->acs_history_file) os_free(mxl_conf->acs_history_file);
+
+	os_free(conf->bss);
+	os_free(conf);
+	os_free(bss->radius);
+	os_free(bss);
+	return 1;
+continue_no_fail:
+#endif /* CONFIG_ACS */
+
+	return 0;
+}
+
+void mxl_hostapd_config_free_acs(struct hostapd_config *conf)
+{
+#ifdef CONFIG_ACS
+	struct mxl_hostapd_config *mxl_conf = &conf->mxl_conf;
+	/* SmartACS */
+	os_free(mxl_conf->acs_smart_info_file);
+	os_free(mxl_conf->acs_history_file);
+	os_free(mxl_conf->acs_penalty_factors);
+	os_free(mxl_conf->acs_grp_priorities_throughput);
+	os_free(mxl_conf->acs_grp_priorities_reach);
+	os_free(mxl_conf->acs_6g_opt_ch_list);
+	os_free(mxl_conf->acs_exclude_opclass_ch_list);
+#endif /* CONFIG_ACS */
+
+}
+
+int mxl_hostapd_config_check_acs(struct hostapd_config *conf, int full_config)
+{
+	if (full_config && (conf->hw_mode == HOSTAPD_MODE_IEEE80211A) &&
+		!is_6ghz_op_class(conf->op_class) && (conf->mxl_conf.acs_fallback_chan.primary == 1))
+		conf->mxl_conf.acs_fallback_chan.primary = 36;
+
+	if (full_config && conf->mxl_conf.dup_beacon.enabled &&
+		conf->he_beacon && is_6ghz_op_class(conf->op_class)) {
+		wpa_printf(MSG_ERROR,
+				"Cannot enable both Duplicate Beacon and HE beacon at the same time");
+		return 1;
+	}
+	return 0;
+}
+
+void mxl_hostapd_config_fill_acs(struct hostapd_config *conf, char *pos)
+{
+	if (!os_strcmp(pos, "acs_survey")) {
+		conf->mxl_conf.acs_algo = ACS_ALGO_SURVEY;
+	} else if(!os_strcmp(pos, "acs_smart")) {
+		conf->mxl_conf.acs_algo = ACS_ALGO_SMART;
+		conf->acs = 1;
+		conf->channel = 0;
+	} else if (os_strcmp(pos, "first_non_dfs") == 0) {
+		conf->channel = FIRST_NON_DFS_CHAN;
+		conf->acs = 0;
+	}
+}
diff --git a/hostapd/mxl_ctrl_iface.c b/hostapd/mxl_ctrl_iface.c
index a8748e493..f16f2a9e4 100644
--- a/hostapd/mxl_ctrl_iface.c
+++ b/hostapd/mxl_ctrl_iface.c
@@ -25,6 +25,9 @@
 #include "common/mxl_ieee802_11_common.h"
 #include "ap/mxl_config.h"
 #include "ap/mxl_hostapd.h"
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "ap/mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #include "drivers/mxl_driver_nl80211.h"
 #include "mxl_ctrl_iface.h"
 #include "ap/mxl_softblock.h"
@@ -3112,7 +3115,12 @@ int mxl_hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      int *reply_len)
 {
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
 	/* Return 1 if buf matched any ctrl iface command, 0 otherwise */
+	if (mxl_hostapd_ctrl_iface_receive_process_acs(hapd, buf, reply, reply_size, reply_len)) {
+		return 1;
+	}
+#endif
 	if (os_strncmp(buf, "GET_HW_FEATURES", 15) == 0) {
 		*reply_len = mxl_hostapd_ctrl_iface_get_hw_features(hapd->iface, NULL, reply, reply_size);
 	} else if (os_strncmp(buf, "SET_FAILSAFE_CHAN ", 18) == 0) {
@@ -3805,7 +3813,11 @@ int mxl_hostapd_ctrl_iface_set_beacon(struct hostapd_data *hapd)
 {
 	enum hostapd_iface_state istate = hapd->iface->state;
 
-	if (istate == HAPD_IFACE_ENABLED) {
+	if ((istate == HAPD_IFACE_ENABLED)
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	    || (hapd->iface->mxl_iface.acs_bgscan)
+#endif
+	) {
 		if (hapd->iconf->multibss_enable)
 			return mxl_hostapd_ctrl_iface_update_mbss_beacon(hapd);
 		else
diff --git a/hostapd/mxl_ctrl_iface.h b/hostapd/mxl_ctrl_iface.h
index 505c43632..751685422 100644
--- a/hostapd/mxl_ctrl_iface.h
+++ b/hostapd/mxl_ctrl_iface.h
@@ -39,4 +39,12 @@ int mxl_hostapd_handle_wmm_ac_params(struct hostapd_data *hapd, char *cmd, char
 bool mxl_hostapd_ctrl_iface_is_channel_allowed(struct hostapd_iface *iface);
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+int mxl_hostapd_ctrl_iface_receive_process_acs(struct hostapd_data *hapd,
+                                              char *buf, char *reply,
+                                              int reply_size,
+                                              int *reply_len);
+int mxl_hostapd_ctrl_iface_check_acs(struct hostapd_iface *iface, const struct csa_settings *settings, enum chan_width bandwidth);
+int mxl_hostapd_ctrl_iface_acs_start(struct hostapd_iface *iface, enum chan_width bw);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #endif /* MXL_CTRL_IFACE_H */
diff --git a/hostapd/mxl_ctrl_iface_proprietary.c b/hostapd/mxl_ctrl_iface_proprietary.c
new file mode 100644
index 000000000..483ab7042
--- /dev/null
+++ b/hostapd/mxl_ctrl_iface_proprietary.c
@@ -0,0 +1,368 @@
+/******************************************************************************
+
+         Copyright (c) 2024, MaxLinear, Inc.
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+#include <stdio.h>
+#include <stddef.h>
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "ap/ap_config.h"
+#include "ap/hostapd.h"
+#include "ap/beacon.h"
+#include "ap/ap_drv_ops.h"
+#include "ap/mxl_config.h"
+#include "ap/mxl_hostapd.h"
+#include "ap/mxl_acs.h"
+#include "drivers/mxl_driver_nl80211.h"
+#include "mxl_ctrl_iface.h"
+
+#ifdef CONFIG_ACS
+static int mxl_hostapd_ctrl_iface_acs_recalc(struct hostapd_iface *iface)
+{
+	struct intel_vendor_channel_data ch_data;
+
+	memset(&ch_data, 0, sizeof(ch_data));
+	mxl_hostapd_update_channel_data(iface, (const u8 *)&ch_data, sizeof(ch_data));
+	return 0;
+}
+
+static int mxl_hostapd_ctrl_iface_acs_report(struct hostapd_iface *iface,
+				  const char *cmd, char *buf, size_t buflen,
+				  bool skip_excluded_ch)
+{
+	int ret = 0, len = 0, i;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	if (!candidates)
+		return -1;
+
+	for (i = 0; i < iface->mxl_iface.num_candidates; i++) {
+		/* skip excluded channels */
+		if (skip_excluded_ch) {
+			if (candidates[i].exclude_reason != ACS_NO_EXCLUSION)
+				continue;
+
+			if (candidates[i].rank < 0)
+				continue;
+		}
+
+		ret = sprintf_s(buf + len, buflen - len, "Ch=%d BW=%d",
+				candidates[i].primary,
+				candidates[i].width);
+		if (ret <= 0)
+			break;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, " DFS=%d",
+			candidates[i].radar_affected);
+		if (ret <= 0)
+			break;
+		len += ret;
+
+		if (candidates[i].filled_mask & CHDATA_TX_POWER) {
+			ret = sprintf_s(buf + len, buflen - len, " pow=%d",
+					candidates[i].tx_power);
+			if (ret <= 0)
+				break;
+			len += ret;
+		}
+
+		ret = sprintf_s(buf + len, buflen - len, " bss=%d",
+				candidates[i].num_bss);
+		if (ret <= 0)
+			break;
+		len += ret;
+		ret = sprintf_s(buf + len, buflen - len, " pri=%d",
+				candidates[i].num_bss_pri);
+		if (ret <= 0)
+			break;
+		len += ret;
+
+		if (candidates[i].filled_mask & CHDATA_LOAD) {
+			ret = sprintf_s(buf + len, buflen - len, " load=%d",
+					candidates[i].channel_load[PRI_20]);
+			if (ret <= 0)
+				break;
+			len += ret;
+		}
+
+		ret = sprintf_s(buf + len, buflen - len, " rank=%d",
+				candidates[i].rank);
+		if (ret <= 0)
+			break;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, "\n");
+		if (ret <= 0)
+			break;
+		len += ret;
+	}
+
+	return len;
+}
+
+static void mxl_hostapd_ctrl_iface_reset_acs_state(struct hostapd_data *hapd, char *cmd)
+{
+	hapd->iface->mxl_iface.num_candidates = 0;
+	hapd->iconf->mxl_conf.acs_init_done = 0;
+}
+
+static int mxl_hostapd_ctrl_iface_acs_bgscan(struct hostapd_data *hapd,
+				  char *buf, char *reply, size_t reply_len)
+{
+	int ret=-1;
+	u16 acs_bgscan_interval = -1;
+
+	if (sscanf(buf, " %hu", &acs_bgscan_interval) != 1) {
+		wpa_printf(MSG_ERROR, "ACS_BG_SCAN: not triggered cause of invalid interval");
+		return -1;
+	}
+
+
+	/* bg_acs_scan params prerequisite fill */
+	hapd->iface->conf->mxl_conf.acs_bgscan_interval = acs_bgscan_interval;
+	acs_bgscan_interval *= 60;
+
+	if (eloop_is_timeout_registered(mxl_acs_bgscan_timer_cb, hapd, NULL)) {
+		wpa_printf(MSG_DEBUG, "acs_bgscan removing existing timer handler");
+		eloop_cancel_timeout(mxl_acs_bgscan_timer_cb, hapd, NULL);
+	}
+
+	if (acs_bgscan_interval != 0) {
+		hapd->iface->mxl_iface.dfs_bg_cac = true;
+		ret = mxl_acs_check_bgscan(hapd->iface);
+		if (ret == 0) {
+			wpa_printf(MSG_DEBUG, "acs_bgscan starting a new background scan with timer value %d", acs_bgscan_interval);
+			eloop_register_timeout(acs_bgscan_interval, 0, mxl_acs_bgscan_timer_cb,
+					hapd, NULL);
+		} else {
+			wpa_printf(MSG_DEBUG, "failed to start acs_bgscan");
+		}
+	} else {
+		hapd->iface->mxl_iface.dfs_bg_cac = false;
+		wpa_printf(MSG_DEBUG, "acs_bgscan timer cancelled and removed");
+	}
+
+	ret = sprintf_s(reply, reply_len, "OK\n",acs_bgscan_interval);
+
+	return ret;
+}
+
+static int mxl_hostapd_ctrl_iface_acs_ex_op_list(struct hostapd_data *hapd,
+				  char *buf, char *reply, size_t reply_len)
+{
+	int ret=-1;
+	char chlist[128];
+	struct mxl_hostapd_config *mxl_conf = &hapd->iface->conf->mxl_conf;
+	struct acs_exclude **op_list = &mxl_conf->acs_exclude_opclass_ch_list;
+	struct acs_exclude *list;
+	int count=0, slash=0, coma=0, num=0;
+	char *pos, *end, *ch;
+
+	if (sscanf(buf, " %s", chlist) != 1) {
+		wpa_printf(MSG_ERROR, "ACS Invalid exclude opclass channel list");
+		goto fail;
+	}
+
+	/* fill the hapd_list */
+	os_free(*op_list);
+	*op_list = NULL;
+
+	pos = chlist;
+	count = 0;
+	while (*pos != '\0') {
+		if (*pos == '/') {
+			coma = 0;
+			num = 0;
+			slash++;
+		}
+		else
+			num++;
+
+		if (*pos == ',') {
+			if (slash > 1) {
+				goto fail;
+			}
+			slash = 0;
+			num = 0;
+			coma++;
+			count++;
+		}
+
+		if (num > 3 || coma > 1) {
+			goto fail;
+		}
+
+		pos++;
+	}
+
+	list = os_malloc(sizeof(struct acs_exclude) * count+1);
+	if (list == NULL) {
+		wpa_printf(MSG_INFO, "ACS exclude list failed to allocate memory");
+		goto fail;
+	}
+	pos = chlist;
+	count = 0;
+	while (*pos != '\0') {
+		end = os_strchr(pos, ',');
+		if (end)
+			*end = '\0'; /* WARN: input buf is modified */
+
+		ch = os_strchr(pos, '/');
+		if (ch != NULL) {
+			list[count].op_class = atoi(pos);
+			list[count].channel = atoi(ch + 1);
+			count++;
+		}
+
+		if (!end)
+			break;
+		pos = end + 1;
+	}
+
+	mxl_conf->acs_exclude_opclass_ch_count = count;
+	*op_list = list;
+
+	ret = sprintf_s(reply, reply_len, "OK\n");
+
+	return ret;
+fail:
+	ret = sprintf_s(reply, reply_len, "Fail\n");
+	return ret;
+}
+#endif /* CONFIG_ACS */
+
+int mxl_hostapd_ctrl_iface_receive_process_acs(struct hostapd_data *hapd,
+					      char *buf, char *reply,
+					      int reply_size,
+					      int *reply_len)
+{
+
+	/* Return 1 if buf matched any ctrl iface command, 0 otherwise */
+	if (os_strncmp(buf, "ACS_RECALC", 10) == 0) {
+		if (mxl_hostapd_ctrl_iface_acs_recalc(hapd->iface))
+			*reply_len = -1;
+	} else if (os_strncmp(buf, "GET_ACS_REPORT_ALL_CH", 21) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_acs_report(hapd->iface, NULL, reply, reply_size, false);
+	} else if (os_strncmp(buf, "GET_ACS_REPORT", 14) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_acs_report(hapd->iface, NULL, reply, reply_size, true);
+	} else if (os_strncmp(buf, "RESET_ACS_STATE", 15) == 0) {
+		mxl_hostapd_ctrl_iface_reset_acs_state(hapd, buf + 15);
+	} else if (os_strncmp(buf, "ACS_BG_SCAN_INTERVAL", 20) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_acs_bgscan(hapd, buf + 20, reply, reply_size);
+	} else if (os_strncmp(buf, "ACS_EX_OP_LIST", 14) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_acs_ex_op_list(hapd, buf + 14, reply, reply_size);
+	} else {
+		return 0;
+	}
+	return 1;
+}
+
+/**
+ * @brief Starts ACS if required and possible
+ * @return 1 if ACS will not be started, 0 on ACS started and -1 on error
+ */
+int mxl_hostapd_ctrl_iface_check_acs(struct hostapd_iface *iface, const struct csa_settings *settings, enum chan_width bandwidth)
+{
+	if (settings->freq_params.freq)
+		return 1;
+
+	if ((iface->state == HAPD_IFACE_DFS)) {
+		wpa_printf(MSG_INFO, "chan_switch: CAC in progress - restarting interfaces");
+		iface->conf->acs = 1;
+		if (hostapd_disable_iface(iface) < 0) {
+			wpa_printf(MSG_ERROR, "chan_switch: Disabling of interface failed");
+			return -1;
+		}
+		if (hostapd_enable_iface(iface) < 0) {
+			wpa_printf(MSG_ERROR, "chan_switch: Enabling of interface failed");
+			return -1;
+		}
+		return 0;
+	}
+
+	if ((iface->state != HAPD_IFACE_ENABLED) && (iface->state != HAPD_IFACE_ACS_DONE)) {
+		wpa_printf(MSG_ERROR, "chan_switch: Cannot initiate ACS during interface state %s", hostapd_state_text(iface->state));
+		return -1;
+	}
+
+	if (settings->freq_params.bandwidth == 0)
+		bandwidth = CHAN_WIDTH_UNKNOWN; // Keep previous value
+
+	return mxl_hostapd_ctrl_iface_acs_start(iface, bandwidth);
+}
+
+static int mxl_hostapd_update_6g_op_class_from_bw(enum oper_chan_width chwidth, int secondary)
+{
+	switch (chwidth) {
+	case CONF_OPER_CHWIDTH_80MHZ:
+		return 133;
+	case CONF_OPER_CHWIDTH_160MHZ:
+		return 134;
+	case CONF_OPER_CHWIDTH_80P80MHZ:
+		return 135;
+	case CONF_OPER_CHWIDTH_320MHZ:
+		return 137;
+	default:
+		if (secondary)
+			return 132;
+		else
+			return 131;
+	}
+}
+
+int mxl_hostapd_ctrl_iface_acs_start(struct hostapd_iface *iface, enum chan_width bw)
+{
+	enum oper_chan_width chwidth;
+
+	iface->conf->channel = 0;
+
+	if (bw != CHAN_WIDTH_UNKNOWN) {
+		iface->conf->secondary_channel = 0;
+		if (bw > CHAN_WIDTH_20)
+			iface->conf->secondary_channel = 1;
+	}
+
+	switch (bw) {
+	case CHAN_WIDTH_80:
+		chwidth = CONF_OPER_CHWIDTH_80MHZ;
+		break;
+	case CHAN_WIDTH_80P80:
+		chwidth = CONF_OPER_CHWIDTH_80P80MHZ;
+		iface->conf->vht_capab |= VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;
+		break;
+	case CHAN_WIDTH_160:
+		chwidth = CONF_OPER_CHWIDTH_160MHZ;
+		iface->conf->vht_capab |= VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
+		break;
+	case CHAN_WIDTH_320:
+		chwidth = CONF_OPER_CHWIDTH_320MHZ;
+		break;
+	case CHAN_WIDTH_20_NOHT:
+	case CHAN_WIDTH_20:
+	case CHAN_WIDTH_40:
+		chwidth = CONF_OPER_CHWIDTH_USE_HT;
+		break;
+	default:
+		chwidth = hostapd_get_oper_chwidth(iface->conf);
+		break;
+	}
+
+	/* To not re-set oper_chwidth on interface startup based on old op_class in setup_interface2() */
+	if (is_6ghz_op_class(iface->conf->op_class))
+		iface->conf->op_class = mxl_hostapd_update_6g_op_class_from_bw(chwidth, iface->conf->secondary_channel);
+	else
+		iface->conf->op_class = 0;
+
+	hostapd_set_oper_chwidth(iface->conf, chwidth);
+	mxl_hostapd_update_user_conf_cw(iface);
+
+	if (iface->state == HAPD_IFACE_ENABLED)
+		iface->mxl_iface.acs_reenable_iface = 1;
+
+	return mxl_acs_start(iface);
+}
diff --git a/hostapd/mxl_hostapd_cli.c b/hostapd/mxl_hostapd_cli.c
index bbf1098ff..75e1e1108 100644
--- a/hostapd/mxl_hostapd_cli.c
+++ b/hostapd/mxl_hostapd_cli.c
@@ -38,7 +38,7 @@ int mxl_hostapd_cli_cmd_deny_macacl(struct wpa_ctrl *ctrl, int argc,
 
 #ifdef CONFIG_ACS
 int mxl_hostapd_cli_cmd_reset_acs_state(struct wpa_ctrl *ctrl, int argc,
-                char *argv[])
+		char *argv[])
 {
 	char cmd[64];
 	int res;
diff --git a/hostapd/mxl_hostapd_cli.h b/hostapd/mxl_hostapd_cli.h
index 7cfe7e97d..19be2f73a 100644
--- a/hostapd/mxl_hostapd_cli.h
+++ b/hostapd/mxl_hostapd_cli.h
@@ -35,6 +35,7 @@ int mxl_wpa_ctrl_command(struct wpa_ctrl *ctrl, const char *cmd);
 
 #define MXL_HOSTAPD_ADD_VENDOR_CLI \
 	MXL_CLI_COMMANDS_ACS		\
+	MXL_CLI_COMMANDS_ACS_PROPRIETARY \
 	MXL_CLI_COMMANDS_AFC		\
 	MXL_CLI_COMMANDS_EPCS		\
 	MXL_CLI_COMMANDS_MLO		\
@@ -113,8 +114,38 @@ int mxl_wpa_ctrl_command(struct wpa_ctrl *ctrl, const char *cmd);
 	{ "reset_acs_state", mxl_hostapd_cli_cmd_reset_acs_state, NULL,           \
 	  " = reset acs state" },                                                 \
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+int mxl_hostapd_cli_cmd_acs_recalc(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+
+int mxl_hostapd_cli_cmd_acs_report(struct wpa_ctrl *ctrl,
+				      int argc, char *argv[]);
+
+int mxl_hostapd_cli_cmd_acs_report_all_ch(struct wpa_ctrl *ctrl,
+					     int argc, char *argv[]);
+
+int mxl_hostapd_cli_cmd_acs_bgscan(struct wpa_ctrl *ctrl,
+                                        int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_acs_ex_op_ch_list(struct wpa_ctrl *ctrl,
+                                        int argc, char *argv[]);
+#define MXL_CLI_COMMANDS_ACS_PROPRIETARY \
+        { "acs_recalc", mxl_hostapd_cli_cmd_acs_recalc, NULL,                     \
+          " = smart acs recalc" },                                                \
+        { "acs_bgscan_interval", mxl_hostapd_cli_cmd_acs_bgscan, NULL,            \
+          "<interval_in_minutes> 0 means acs_bgscan disabled"},                   \
+        { "acs_report", mxl_hostapd_cli_cmd_acs_report, NULL,                     \
+          "get ACS report" },                                                     \
+        { "acs_report_all_ch", mxl_hostapd_cli_cmd_acs_report_all_ch, NULL,       \
+          "get ACS report for all channels (channel filter is disabled)" },       \
+        { "acs_ex_op_ch_list", mxl_hostapd_cli_cmd_acs_ex_op_ch_list, NULL,       \
+          "set ACS excluded channel list for mentioned op_class)" },              \
+
+#else /* CONFIG_VENDOR_MXL_PROPRIETARY */
+#define MXL_CLI_COMMANDS_ACS_PROPRIETARY
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 #else /* CONFIG_ACS */
 #define MXL_CLI_COMMANDS_ACS
+#define MXL_CLI_COMMANDS_ACS_PROPRIETARY
 #endif /* CONFIG_ACS */
 
 #ifdef CONFIG_AFC
diff --git a/hostapd/mxl_hostapd_cli_proprietary.c b/hostapd/mxl_hostapd_cli_proprietary.c
new file mode 100644
index 000000000..c5d61a43d
--- /dev/null
+++ b/hostapd/mxl_hostapd_cli_proprietary.c
@@ -0,0 +1,99 @@
+/******************************************************************************
+
+         Copyright (c) 2024, MaxLinear, Inc.
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+
+#include "includes.h"
+#include "common/wpa_ctrl.h"
+#include "mxl_hostapd_cli.h"
+
+#ifdef CONFIG_ACS
+int mxl_hostapd_cli_cmd_acs_recalc(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	return mxl_wpa_ctrl_command(ctrl, "ACS_RECALC");
+}
+
+int mxl_hostapd_cli_cmd_acs_report(struct wpa_ctrl *ctrl,
+				      int argc, char *argv[])
+{
+	char cmd[18];
+	int res;
+
+	if (argc != 0) {
+		printf("acs_report doesn't require parameters\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "GET_ACS_REPORT");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+	return mxl_wpa_ctrl_command(ctrl, cmd);
+}
+
+int mxl_hostapd_cli_cmd_acs_ex_op_ch_list(struct wpa_ctrl *ctrl,
+					int argc, char *argv[])
+{
+	char cmd[128];
+	int res;
+
+	if (argc < 1 || argc > 1) {
+		printf("acs_opclass_list is invalid");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "ACS_EX_OP_LIST %s", argv[0]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	return mxl_wpa_ctrl_command(ctrl, cmd);
+}
+
+int mxl_hostapd_cli_cmd_acs_bgscan(struct wpa_ctrl *ctrl,
+					int argc, char *argv[])
+{
+	char cmd[32];
+	int res;
+
+	if (argc < 1 || argc > 1) {
+		printf("acs_bgscan requires interval value");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "ACS_BG_SCAN_INTERVAL %s", argv[0]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	return mxl_wpa_ctrl_command(ctrl, cmd);
+}
+
+int mxl_hostapd_cli_cmd_acs_report_all_ch(struct wpa_ctrl *ctrl,
+					     int argc, char *argv[])
+{
+	char cmd[25];
+	int res;
+
+	if (argc != 0) {
+		printf("acs_report_all_ch doesn't require parameters\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "GET_ACS_REPORT_ALL_CH");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+	return mxl_wpa_ctrl_command(ctrl, cmd);
+}
+
+#endif /* CONFIG_ACS */
+
diff --git a/src/ap/acs.c b/src/ap/acs.c
index b38175760..9a3d24844 100644
--- a/src/ap/acs.c
+++ b/src/ap/acs.c
@@ -21,6 +21,9 @@
 #include "ap_config.h"
 #include "hw_features.h"
 #include "acs.h"
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 /*
  * Automatic Channel Selection
@@ -342,6 +345,10 @@ void acs_cleanup(struct hostapd_iface *iface)
 {
 	int i;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	mxl_acs_cleanup(iface);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	for (i = 0; i < iface->num_hw_features; i++)
 		acs_cleanup_mode(&iface->hw_features[i]);
 
@@ -1313,6 +1320,12 @@ static int * acs_request_scan_add_freqs(struct hostapd_iface *iface,
 		    iface->conf->country[2] == 0x4f)
 			continue;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRITARY
+		if (mxl_acs_should_skip_freq(iface, chan)) {
+			continue;
+		}
+#endif /* CONFIG_VENDOR_MXL_PROPRITARY */
+
 		*freq++ = chan->freq;
 	}
 
@@ -1327,6 +1340,8 @@ static int acs_request_scan(struct hostapd_iface *iface)
 	int num_channels;
 	struct hostapd_hw_modes *mode;
 
+	wpa_printf(MSG_DEBUG, "ACS: acs_request_scan for op_class : %d", iface->conf->op_class);
+
 	os_memset(&params, 0, sizeof(params));
 
 	num_channels = 0;
@@ -1357,13 +1372,31 @@ static int acs_request_scan(struct hostapd_iface *iface)
 	}
 
 	iface->scan_cb = acs_scan_complete;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if(mxl_acs_is_smart(iface)) {
+		iface->scan_cb = mxl_smart_acs_scan_complete;
+		mxl_acs_init_defaults(iface);
+	}
+	iface->mxl_iface.in_scan = 1;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	wpa_printf(MSG_DEBUG, "ACS: Scanning %d / %d",
 		   iface->acs_num_completed_scans + 1,
 		   iface->conf->acs_num_scans);
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	int res;
+	res = mxl_hostapd_check_and_abort_scan(iface);
+	if(res != 1) {
+		os_free(params.freqs);
+		return res;
+	}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	if (hostapd_driver_scan(iface->bss[0], &params) < 0) {
 		wpa_printf(MSG_ERROR, "ACS: Failed to request initial scan");
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		iface->mxl_iface.in_scan = 0;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		acs_cleanup(iface);
 		os_free(params.freqs);
 		return -1;
@@ -1399,8 +1432,13 @@ enum hostapd_chan_status acs_init(struct hostapd_iface *iface)
 
 	acs_cleanup(iface);
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if (mxl_acs_init(iface) < 0)
+		return HOSTAPD_CHAN_INVALID;
+#else /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	if (acs_request_scan(iface) < 0)
 		return HOSTAPD_CHAN_INVALID;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	hostapd_set_state(iface, HAPD_IFACE_ACS);
 	wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, ACS_EVENT_STARTED);
diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
index f7dc26620..70aaab12f 100644
--- a/src/ap/ap_config.c
+++ b/src/ap/ap_config.c
@@ -432,7 +432,9 @@ struct hostapd_config * hostapd_config_defaults(void)
 	conf->sFilsBeaconFlag = 1; /* By Default we should receive/process the incoming Fils frame on 6G */
 	conf->whm_cfg_flag = DEFAULT_WHM;
 #ifdef CONFIG_VENDOR_MXL
-	mxl_hostapd_config_defaults(conf);
+	if(mxl_hostapd_config_defaults(conf)) {
+		return NULL;
+	}
 #endif /* CONFIG_VENDOR_MXL */
 	return conf;
 }
@@ -1193,6 +1195,10 @@ void hostapd_config_free(struct hostapd_config *conf)
 	os_free(conf->sFixedRateCfg);
 	os_free(conf->sFWRecovery);
 
+#ifdef CONFIG_VENDOR_MXL
+	mxl_hostapd_config_free(conf);
+#endif /* CONFIG_VENDOR_MXL */
+
 	os_free(conf);
 }
 
@@ -1774,6 +1780,12 @@ int hostapd_config_check(struct hostapd_config *conf, int full_config)
 			return -1;
 	}
 
+#ifdef CONFIG_VENDOR_MXL
+	if(mxl_hostapd_config_check(conf, full_config)) {
+		return -1;
+	}
+#endif /* CONFIG_VENDOR_MXL */
+
 	if(conf->multibss_enable) {
 		conf->mbssid_aid_offset = MULTIBSS_AID_OFFSET;
 		wpa_printf(MSG_DEBUG, "mbssid_aid_offset is set to (%d)", conf->mbssid_aid_offset);
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index 2a71fe0de..973aacc47 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -616,8 +616,16 @@ int hostapd_set_freq(struct hostapd_data *hapd, enum hostapd_hw_mode mode,
 				    &cmode->he_capab[IEEE80211_MODE_AP] : NULL,
 				    cmode ?
 				    &cmode->eht_capab[IEEE80211_MODE_AP] :
-				    NULL))
+				    NULL)) {
+		wpa_printf(MSG_ERROR, "hostapd_set_freq_params failed: mode=%i, freq=%i, "
+				"channel=%i, ht_enabled=%i, vht_enabled=%i,  he_enabled %i, "
+				"sec_channel_offset=%i, oper_chcwidth=%i, "
+				"center_segment0=%i, center_segment1=%i",
+				mode, freq, channel, ht_enabled, vht_enabled, he_enabled,
+				sec_channel_offset, oper_chwidth, center_segment0,
+				center_segment1);
 		return -1;
+	}
 
 	if (hapd->driver == NULL)
 		return 0;
diff --git a/src/ap/dfs.c b/src/ap/dfs.c
index 4d67b9986..dabfff4c5 100644
--- a/src/ap/dfs.c
+++ b/src/ap/dfs.c
@@ -18,6 +18,9 @@
 #include "drivers/driver.h"
 #include "dfs.h"
 #ifdef CONFIG_VENDOR_MXL
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #include "mxl_dfs_common.h"
 #include "mxl_dfs_file.h"
 #include "mxl_zwdfs.h"
@@ -754,6 +757,10 @@ static int set_dfs_state(struct hostapd_iface *iface, int freq, int ht_enabled,
 		}
 	}
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	mxl_acs_update_radar(iface);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	return ret;
 }
 
@@ -937,6 +944,13 @@ int hostapd_handle_dfs(struct hostapd_iface *iface)
 		hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
 		iface->dfs_cac_ms / 1000);
 
+#ifdef CONFIG_VENDOR_MXL
+	res = mxl_acs_request_bg_cac(iface);
+	if (res > 0) {
+		wpa_printf(MSG_INFO, "ACS req_bg_cac started");
+		return res;
+	}
+#endif /* CONFIG_VENDOR_MXL */
 	res = hostapd_start_dfs_cac(
 		iface, iface->conf->hw_mode, iface->freq, iface->conf->channel,
 		iface->conf->ieee80211n, iface->conf->ieee80211ac,
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index ca001bf52..56e1ce23e 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -44,6 +44,9 @@
 #include "neighbor_db.h"
 #ifdef CONFIG_VENDOR_MXL
 #include "wpa_auth_i.h"
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #include "mxl_dfs_common.h"
 #include "../hostapd/mxl_ctrl_iface.h"
 #include "mxl_beacon.h"
@@ -2478,8 +2481,12 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		michael_mic_failure(hapd, data->michael_mic_failure.src, 1);
 		break;
 	case EVENT_SCAN_RESULTS:
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		mxl_event_scan_results(hapd, data);
+#else
 		if (hapd->iface->scan_cb)
 			hapd->iface->scan_cb(hapd->iface);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		break;
 	case EVENT_WPS_BUTTON_PUSHED:
 		hostapd_wps_button_pushed(hapd, NULL);
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index a47dd7a0d..e5ef6af88 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -2451,6 +2451,12 @@ hostapd_change_country(struct hostapd_iface *iface, struct channel_list_changed
 		return 0;
 	}
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if(mxl_hostapd_change_country(iface,info) < 0)
+		return -1;
+	return 0;
+#endif
+
 	/* Update channels and flags */
 	if (hostapd_get_hw_features(iface)) {
 		wpa_printf(MSG_ERROR, "Failed to get new regulatory data");
@@ -3380,6 +3386,11 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 			}
 			iface->set_freq_done = 1;
 		} else {
+#ifdef CONFIG_VENDOR_MXL
+			res = mxl_acs_set_bg_cac(iface);
+			if (res)
+				return 0;
+#endif /* CONFIG_VENDOR_MXL */
 			struct csa_settings settings;
 			memset(&settings, 0, sizeof(settings));
 			if (hostapd_set_freq_params(&settings.freq_params,
@@ -4416,9 +4427,19 @@ static int hostapd_add_bss(struct hostapd_iface *iface,
 
 	/* Set up BSS will be done after interface enabled */
 	if (iface->state != HAPD_IFACE_ENABLED) {
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
 #ifdef CONFIG_ACS
+		/* In case non-initial ACS is running: do reconf (which will
+		 * cancel ACS scan), and after scan aborted restart the ACS again */
+		if (iface->mxl_iface.acs_bgscan)
+			iface->mxl_iface.retrigger_acs = true;
+		else
+			return 0;
+#else
 		return 0;
 #endif /* CONFIG_ACS */
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+		return 0;
 	}
 
 	if (hostapd_setup_bss(hapd, false, true)) {
@@ -4672,6 +4693,7 @@ int hostapd_disable_iface(struct hostapd_iface *hapd_iface)
 	if (hapd_iface->radar_background.cac_started) {
 		mxl_hostapd_set_zwdfs_antenna(hapd_iface->bss[0], 0);
 	}
+	mxl_acs_set_bg_cac(hapd_iface);
 #endif /* CONFIG_VENDOR_MXL */
 
 	/* same as hostapd_interface_deinit without deinitializing ctrl-iface */
@@ -5231,6 +5253,10 @@ const char * hostapd_state_text(enum hostapd_iface_state s)
 		return "COUNTRY_UPDATE";
 	case HAPD_IFACE_ACS:
 		return "ACS";
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	case HAPD_IFACE_ACS_DONE:
+		return "ACS_DONE";
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	case HAPD_IFACE_HT_SCAN:
 		return "HT_SCAN";
 	case HAPD_IFACE_DFS:
@@ -5308,6 +5334,9 @@ void hostapd_set_state(struct hostapd_iface *iface, enum hostapd_iface_state s)
 	wpa_printf(MSG_INFO, "%s: interface state %s->%s",
 		   iface->conf ? iface->conf->bss[0]->iface : "N/A",
 		   hostapd_state_text(iface->state), hostapd_state_text(s));
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	mxl_hostapd_set_state_pre(iface, s);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	iface->state = s;
 
 	if(HAPD_IFACE_ENABLED == s)
@@ -6208,6 +6237,10 @@ int hostapd_get_psd_val(struct hostapd_iface *iface, u8 *val)
 
 void hostapd_handle_acs_whm_warning (struct hostapd_iface *iface)
 {
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	wpa_printf(MSG_ERROR,"WHM-ACS: current ACS state %d, num_candidates %d num_bss %d acs_num_completed_scans %d",
+			iface->state, iface->mxl_iface.num_candidates, iface->mxl_iface.acs_num_bss, iface->acs_num_completed_scans);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	hostapd_drv_set_whm_trigger(iface->bss[0], WHM_HOSTAP_ACS_FAILURE);
 }
 
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index e8737f039..2bd2fe58b 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -115,6 +115,9 @@ struct hapd_interfaces {
 	struct mxl_hapd_interfaces mxl_interfaces;
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
+#ifdef CONFIG_VENDOR_MXL
+	struct dl_list rnr_scan_6g_ap_info; /* struct rnr_scan_ap_info  */
+#endif /* CONFIG_VENDOR_MXL */
 #ifdef UBUS_SUPPORT
 	struct ubus_object ubus;
 #endif /* UBUS_SUPPORT */
@@ -564,6 +567,9 @@ struct hostapd_iface {
 		HAPD_IFACE_DISABLED,
 		HAPD_IFACE_COUNTRY_UPDATE,
 		HAPD_IFACE_ACS,
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		HAPD_IFACE_ACS_DONE,
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		HAPD_IFACE_HT_SCAN,
 		HAPD_IFACE_DFS,
 		HAPD_IFACE_NO_IR,
diff --git a/src/ap/hw_features.c b/src/ap/hw_features.c
index 87586a0fb..d2b3b47a5 100644
--- a/src/ap/hw_features.c
+++ b/src/ap/hw_features.c
@@ -1183,6 +1183,12 @@ int hostapd_is_usable_chans(struct hostapd_iface *iface)
 	if (!iface->conf->ht40_plus_minus_allowed)
 		return err;
 
+#if defined(CONFIG_VENDOR_MXL_PROPRIETARY) && defined(CONFIG_ACS)
+	/* ACS smart have already updated valid secondary channel */
+	if (mxl_acs_is_smart(iface) && iface->conf->mxl_conf.acs_init_done)
+		return 0;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY && CONFIG_ACS */
+
 	/* Both HT40+ and HT40- are set, pick a valid secondary channel */
 	secondary_freq = iface->freq + 20;
 	err = hostapd_is_usable_chan(iface, secondary_freq, 0);
@@ -1318,6 +1324,8 @@ static void hostapd_notify_bad_chans(struct hostapd_iface *iface)
 }
 
 
+#ifdef CONFIG_ACS
+#ifndef CONFIG_VENDOR_MXL_PROPRIETARY
 int hostapd_acs_completed(struct hostapd_iface *iface, int err)
 {
 	int ret = -1;
@@ -1360,6 +1368,8 @@ int hostapd_acs_completed(struct hostapd_iface *iface, int err)
 out:
 	return hostapd_setup_interface_complete(iface, ret);
 }
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+#endif /* CONFIG_ACS */
 
 
 /**
diff --git a/src/ap/hw_features.h b/src/ap/hw_features.h
index 2c9373469..ee47ec4dd 100644
--- a/src/ap/hw_features.h
+++ b/src/ap/hw_features.h
@@ -16,7 +16,14 @@ void hostapd_free_hw_features(struct hostapd_hw_modes *hw_features,
 			      size_t num_hw_features);
 int hostapd_get_hw_features(struct hostapd_iface *iface);
 int hostapd_csa_update_hwmode(struct hostapd_iface *iface);
+#ifdef CONFIG_ACS
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+int mxl_hostapd_acs_completed(struct hostapd_iface *iface, int err, int set_channel);
+static inline int hostapd_acs_completed(struct hostapd_iface *iface, int err) { return mxl_hostapd_acs_completed(iface, err, 1); };
+#else
 int hostapd_acs_completed(struct hostapd_iface *iface, int err);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+#endif /* CONFIG_ACS */
 int hostapd_select_hw_mode(struct hostapd_iface *iface);
 const char * hostapd_hw_mode_txt(int mode);
 int hostapd_hw_get_freq(struct hostapd_data *hapd, int chan);
diff --git a/src/ap/ieee802_11_ht.c b/src/ap/ieee802_11_ht.c
index f44dbd5d8..06e6eda87 100644
--- a/src/ap/ieee802_11_ht.c
+++ b/src/ap/ieee802_11_ht.c
@@ -21,6 +21,9 @@
 #include "ap_drv_ops.h"
 #ifdef CONFIG_VENDOR_MXL
 #include "mxl_coexistence.h"
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #endif
 
 
@@ -377,6 +380,13 @@ void hostapd_2040_coex_action(struct hostapd_data *hapd,
 		for (i = 0; i < ielen - 1; i++) {
 			u8 chan = ic_report->variable[i];
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#ifdef CONFIG_ACS
+			if (mxl_acs_is_smart(iface) && iface->conf->mxl_conf.acs_init_done)
+				mxl_acs_update_intolerant_channels(iface, chan);
+#endif /* CONFIG_ACS */
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 			if (chan == iface->conf->channel)
 				continue; /* matching own primary channel */
 			if (is_40_allowed(iface, chan))
diff --git a/src/ap/mxl_acs.c b/src/ap/mxl_acs.c
new file mode 100644
index 000000000..9b7e81281
--- /dev/null
+++ b/src/ap/mxl_acs.c
@@ -0,0 +1,3802 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+         Copyright 2016 - 2020 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+
+#include <limits.h>
+#include <assert.h>
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "utils/common.h"
+#include "hostapd.h"
+#include "hw_features.h"
+#include "ap_drv_ops.h"
+#include "common/hw_features_common.h"
+#include "common/wpa_ctrl.h"
+#include "acs.h"
+#include "common/mxl_ieee802_11_common.h"
+#include "mxl_acs.h"
+#include "dfs.h"
+#include "mxl_dfs_common.h"
+#ifdef CONFIG_AFC
+#include "mxl_afc.h"
+#endif
+
+#define HOSTAPD_CHAN_NO_80MHZ   0x20000000
+#define HOSTAPD_CHAN_NO_160MHZ  0x40000000
+
+#define FILS_FIXED_LEN 12
+#define MXL_OUI_LEN 3
+#define FILS_PRIMARY_CHANNEL_OFFSET 1
+#define FILS_CHANNEL_CENTRE_FREQUENCY_SEG1_OFFSET 11
+#define FILS_LENGTH_SUBFIELD_SIZE 1
+
+#define FILS_CHANNEL_CENTRE_FREQUENCY_SEG1 ((u8) BIT(1))
+#define FILS_PRIMARY_CHANNEL_PRESENCE_INDICATOR ((u8) BIT(2))
+#define FILS_LEN_PRESENCE_INDICATOR ((u8) BIT(4))
+#define FILS_CAPABALITY_PRESENCE_INDICATOR ((u8) BIT(5))
+#define FILS_SHORT_SSID_INDICATOR ((u8) BIT(6))
+#define FILS_SSID_LEN ((u8) (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4)))
+#define FILS_BSS_OPERATING_CHANNEL_WIDTH ((u8) (BIT(2) | BIT(3) | BIT(4)))
+
+enum {
+	ACS_POLICY_THROUGHPUT,
+	ACS_POLICY_REACH
+};
+
+/* Channel Selection Penalty factors */
+enum penalty_factor_e {
+	K_CWI,
+	K_CL,
+	K_TX_POWER,
+	K_NUMOFBSS
+};
+
+enum {
+	CALIB_20,
+	CALIB_40,
+	CALIB_80,
+	CALIB_160
+};
+
+enum {
+	CW_20 = 0,
+	CW_40,
+	CW_80,
+	CW_160,
+	CW_80_80
+};
+
+channel_pair g_channel_pairs_40_24G[NUM_CHAN_PAIRS_40_24G] =
+{
+	{  1,  5 },
+	{  5,  1 },
+	{  2,  6 },
+	{  6,  2 },
+	{  3,  7 },
+	{  7,  3 },
+	{  4,  8 },
+	{  8,  4 },
+	{  5,  9 },
+	{  9,  5 },
+	{  6, 10 },
+	{ 10,  6 },
+	{  7, 11 },
+	{ 11,  7 },
+	{  8, 12 },
+	{ 12,  8 },
+	{  9, 13 },
+	{ 13,  9 }
+};
+
+channel_pair g_channel_pairs_40_5G[NUM_CHAN_PAIRS_40_5G] =
+{
+	{  36, 40 },
+	{  40, 36 },
+	{  44, 48 },
+	{  48, 44 },
+	{  52, 56 },
+	{  56, 52 },
+	{  60, 64 },
+	{  64, 60 },
+	{ 100,104 },
+	{ 104,100 },
+	{ 108,112 },
+	{ 112,108 },
+	{ 116,120 },
+	{ 120,116 },
+	{ 124,128 },
+	{ 128,124 },
+	{ 132,136 },
+	{ 136,132 },
+	{ 140,144 },
+	{ 144,140 },
+	{ 149,153 },
+	{ 153,149 },
+	{ 157,161 },
+	{ 161,157 }
+};
+
+mxl_acs_chan g_channels80[NUM_CHAN_PAIRS_80] =
+{
+	{  42,  36, 40, 5000 + 36 * 5 },
+	{  42,  40, 36, 5000 + 36 * 5 },
+	{  42,  44, 48, 5000 + 36 * 5 },
+	{  42,  48, 44, 5000 + 36 * 5 },
+
+	{  58,  52, 56, 5000 + 52 * 5 },
+	{  58,  56, 52, 5000 + 52 * 5 },
+	{  58,  60, 64, 5000 + 52 * 5 },
+	{  58,  64, 60, 5000 + 52 * 5 },
+
+	{ 106, 100, 104, 5000 + 100 * 5 },
+	{ 106, 104, 100, 5000 + 100 * 5 },
+	{ 106, 108, 112, 5000 + 100 * 5 },
+	{ 106, 112, 108, 5000 + 100 * 5 },
+
+	{ 122, 116, 120, 5000 + 116 * 5 },
+	{ 122, 120, 116, 5000 + 116 * 5 },
+	{ 122, 124, 128, 5000 + 116 * 5 },
+	{ 122, 128, 124, 5000 + 116 * 5 },
+
+	{ 138, 132, 136, 5000 + 132 * 5 },
+	{ 138, 136, 132, 5000 + 132 * 5 },
+	{ 138, 140, 144, 5000 + 132 * 5 },
+	{ 138, 144, 140, 5000 + 132 * 5 },
+
+	{ 155, 149, 153, 5000 + 149 * 5 },
+	{ 155, 153, 149, 5000 + 149 * 5 },
+	{ 155, 157, 161, 5000 + 149 * 5 },
+	{ 155, 161, 157, 5000 + 149 * 5 }
+};
+
+mxl_acs_chan g_channels160[NUM_CHAN_PAIRS_160] =
+{
+	{  50,  36,  40, 5000 +  36 * 5 },
+	{  50,  40,  36, 5000 +  36 * 5 },
+	{  50,  44,  48, 5000 +  36 * 5 },
+	{  50,  48,  44, 5000 +  36 * 5 },
+	{  50,  52,  56, 5000 +  36 * 5 },
+	{  50,  56,  52, 5000 +  36 * 5 },
+	{  50,  60,  64, 5000 +  36 * 5 },
+	{  50,  64,  60, 5000 +  36 * 5 },
+
+	{ 114, 100, 104, 5000 + 100 * 5 },
+	{ 114, 104, 100, 5000 + 100 * 5 },
+	{ 114, 108, 112, 5000 + 100 * 5 },
+	{ 114, 112, 108, 5000 + 100 * 5 },
+	{ 114, 116, 120, 5000 + 100 * 5 },
+	{ 114, 120, 116, 5000 + 100 * 5 },
+	{ 114, 124, 128, 5000 + 100 * 5 },
+	{ 114, 128, 124, 5000 + 100 * 5 }
+};
+
+channel_pair g_channel_pairs_40_6G[NUM_CHAN_PAIRS_40_6G] =
+{
+	{ 1 ,5 },      { 5, 1 },
+	{ 9 ,13 },     { 13, 9 },
+	{ 17 ,21 },    { 21, 17 },
+	{ 25 ,29 },    { 29, 25 },
+	{ 33 ,37 },    { 37, 33 },
+	{ 41 ,45 },    { 45, 41 },
+	{ 49 ,53 },    { 53, 49 },
+	{ 57 ,61 },    { 61, 57 },
+	{ 65 ,69 },    { 69, 65 },
+	{ 73 ,77 },    { 77, 73 },
+	{ 81 ,85 },    { 85, 81 },
+	{ 89 ,93 },    { 93, 89 },
+	{ 97 ,101 },   { 101, 97 },
+	{ 105 ,109 },  { 109, 105 },
+	{ 113 ,117 },  { 117, 113 },
+	{ 121 ,125 },  { 125, 121 },
+	{ 129 ,133 },  { 133, 129 },
+	{ 137 ,141 },  { 141, 137 },
+	{ 145 ,149 },  { 149, 145 },
+	{ 153 ,157 },  { 157, 153 },
+	{ 161 ,165 },  { 165, 161 },
+	{ 169 ,173 },  { 173, 169 },
+	{ 177 ,181 },  { 181, 177 },
+	{ 185 ,189 },  { 189, 185 },
+	{ 193 ,197 },  { 197, 193 },
+	{ 201 ,205 },  { 205, 201 },
+	{ 209 ,213 },  { 213, 209 },
+	{ 217 ,221 },  { 221, 217 },
+	{ 225 ,229 },  { 229, 225 }
+};
+
+mxl_acs_chan g_channels80_6G[NUM_CHAN_PAIRS_80_6G] =
+{
+	{ 7,  1,  5, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 7,  9, 13, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 7,  5,  1, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 7, 13,  9, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+
+	{ 23, 17, 21, STARTING_6G_FREQ_IN_MHZ + 17*5 },
+	{ 23, 25, 29, STARTING_6G_FREQ_IN_MHZ + 17*5 },
+	{ 23, 21, 17, STARTING_6G_FREQ_IN_MHZ + 17*5 },
+	{ 23, 29, 25, STARTING_6G_FREQ_IN_MHZ + 17*5 },
+
+	{ 39, 33, 37, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 39, 41, 45, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 39, 37, 33, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 39, 45, 41, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+
+	{ 55, 49, 53, STARTING_6G_FREQ_IN_MHZ + 49*5 },
+	{ 55, 57, 61, STARTING_6G_FREQ_IN_MHZ + 49*5 },
+	{ 55, 53, 49, STARTING_6G_FREQ_IN_MHZ + 49*5 },
+	{ 55, 61, 57, STARTING_6G_FREQ_IN_MHZ + 49*5 },
+
+	{ 71, 65, 69, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 71, 73, 77, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 71, 69, 65, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 71, 77, 73, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+
+	{ 87, 81, 85, STARTING_6G_FREQ_IN_MHZ + 81*5 },
+	{ 87, 89, 93, STARTING_6G_FREQ_IN_MHZ + 81*5 },
+	{ 87, 85, 81, STARTING_6G_FREQ_IN_MHZ + 81*5 },
+	{ 87, 93, 89, STARTING_6G_FREQ_IN_MHZ + 81*5 },
+
+	{ 103,  97, 101, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 103, 105, 109, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 103, 101,  97, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 103, 109, 105, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+
+	{ 119, 113, 117, STARTING_6G_FREQ_IN_MHZ + 113*5 },
+	{ 119, 121, 125, STARTING_6G_FREQ_IN_MHZ + 113*5 },
+	{ 119, 117, 113, STARTING_6G_FREQ_IN_MHZ + 113*5 },
+	{ 119, 125, 121, STARTING_6G_FREQ_IN_MHZ + 113*5 },
+
+	{ 135, 129, 133, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 135, 137, 141, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 135, 133, 129, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 135, 141, 137, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+
+	{ 151, 145, 149, STARTING_6G_FREQ_IN_MHZ + 145*5 },
+	{ 151, 153, 157, STARTING_6G_FREQ_IN_MHZ + 145*5 },
+	{ 151, 149, 145, STARTING_6G_FREQ_IN_MHZ + 145*5 },
+	{ 151, 157, 153, STARTING_6G_FREQ_IN_MHZ + 145*5 },
+
+	{ 167, 161, 165, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 167, 169, 173, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 167, 165, 161, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 167, 173, 169, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+
+	{ 183, 177, 181, STARTING_6G_FREQ_IN_MHZ + 177*5 },
+	{ 183, 185, 189, STARTING_6G_FREQ_IN_MHZ + 177*5 },
+	{ 183, 181, 177, STARTING_6G_FREQ_IN_MHZ + 177*5 },
+	{ 183, 189, 185, STARTING_6G_FREQ_IN_MHZ + 177*5 },
+
+	{ 199, 193, 197, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 199, 201, 205, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 199, 197, 193, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 199, 205, 201, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+
+	{ 215, 209, 213, STARTING_6G_FREQ_IN_MHZ + 209*5 },
+	{ 215, 217, 221, STARTING_6G_FREQ_IN_MHZ + 209*5 },
+	{ 215, 213, 209, STARTING_6G_FREQ_IN_MHZ + 209*5 },
+	{ 215, 221, 217, STARTING_6G_FREQ_IN_MHZ + 209*5 }
+};
+
+mxl_acs_chan g_channels160_6G[NUM_CHAN_PAIRS_160_6G] =
+{
+	{ 15,  1,  5, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 15,  9, 13, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 15, 17, 21, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 15, 25, 29, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 15,  5,  1, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 15, 13,  9, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 15, 21, 17, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+	{ 15, 29, 25, STARTING_6G_FREQ_IN_MHZ + 1*5 },
+		
+	{ 47, 33, 37, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 47, 41, 45, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 47, 49, 53, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 47, 57, 61, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 47, 37, 33, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 47, 45, 41, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 47, 53, 49, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	{ 47, 61, 57, STARTING_6G_FREQ_IN_MHZ + 33*5 },
+	
+	{ 79, 65, 69, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 79, 73, 77, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 79, 81, 85, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 79, 89, 93, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 79, 69, 65, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 79, 77, 73, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 79, 85, 81, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+	{ 79, 93, 89, STARTING_6G_FREQ_IN_MHZ + 65*5 },
+
+	{ 111,  97, 101, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 111, 105, 109, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 111, 113, 117, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 111, 121, 125, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 111, 101,  97, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 111, 109, 105, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 111, 117, 113, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+	{ 111, 125, 121, STARTING_6G_FREQ_IN_MHZ + 97*5 },
+
+	{ 143, 129, 133, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 143, 137, 141, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 143, 145, 149, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 143, 153, 157, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 143, 133, 129, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 143, 141, 137, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 143, 149, 145, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	{ 143, 157, 153, STARTING_6G_FREQ_IN_MHZ + 129*5 },
+	
+	{ 175, 161, 165, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 175, 169, 173, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 175, 177, 181, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 175, 185, 189, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 175, 165, 161, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 175, 173, 169, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 175, 181, 177, STARTING_6G_FREQ_IN_MHZ + 161*5 },
+	{ 175, 189, 185, STARTING_6G_FREQ_IN_MHZ + 161*5 },	
+
+	{ 207, 193, 197, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 207, 201, 205, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 207, 209, 213, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 207, 217, 221, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 207, 197, 193, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 207, 205, 201, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 207, 213, 209, STARTING_6G_FREQ_IN_MHZ + 193*5 },
+	{ 207, 221, 217, STARTING_6G_FREQ_IN_MHZ + 193*5 }
+};
+
+static void acs_push_chandef(struct hostapd_iface *iface, mxl_acs_chandef *chan);
+static void acs_pop_chandef(struct hostapd_iface *iface, mxl_acs_chandef *chan);
+enum hostapd_chan_status mxl_hostapd_check_chans(struct hostapd_iface *iface);
+void mxl_hostapd_notify_bad_chans(struct hostapd_iface *iface);
+struct hostapd_channel_data * mxl_hostapd_get_mode_channel(struct hostapd_iface *iface, unsigned int freq);
+
+/* Defines to parse 6GHz HE Oper IE or FILS frames from neighbor BSSes */
+#define HE_OPER_CHANWIDTH_20	0
+#define HE_OPER_CHANWIDTH_40	1
+#define HE_OPER_CHANWIDTH_80	2
+#define HE_OPER_CHANWIDTH_160	3
+
+#define CF0_AND_CF1_IDX_DIFF_IN_160_MHZ 8
+
+enum acs_cwi_map_e
+{
+	ACS_CWI_MAP_VAL,
+	ACS_CWI_MAP_PEN,
+
+	ACS_CWI_MAP_SIZE,
+};
+
+#define ACS_DEFAULT_CWI				-128
+#define ACS_CWI_PENALTY_MIN			0
+#define ACS_CWI_PENALTY_MAX			100
+#define ACS_CWI_PEN_MAP_NUM_COLS	19
+#define ACS_CWI_PEN_MAP_NUM_ROWS	ACS_CWI_MAP_SIZE
+#define ACS_CWI_MAP_VAL_FIRST_IDX	0
+#define ACS_CWI_MAP_VAL_LAST_IDX	(ACS_CWI_PEN_MAP_NUM_COLS - 1)
+
+/* if cwi < -87, penalty is 0
+   if cwi > -69, penalty is 100
+   others cwi values to penalty value are mapped in the table below */
+int acs_cwi_val_penalty_map[ACS_CWI_PEN_MAP_NUM_ROWS][ACS_CWI_PEN_MAP_NUM_COLS] = {
+	{-87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77, -76, -75, -74, -73, -72, -71, -70, -69}, /* CWI */
+	{  1,   1,   2,   4,   5,   7,   9,  12,  15,  20,  27,  35,  45,  60,  70,  80,  85,  90,  95}, /* Penalty */
+};
+
+static int acs_get_cwi_penalty(int cwi_noise)
+{
+	int i;
+
+	if (cwi_noise < acs_cwi_val_penalty_map[ACS_CWI_MAP_VAL][ACS_CWI_MAP_VAL_FIRST_IDX])
+		return ACS_CWI_PENALTY_MIN;
+	if (cwi_noise > acs_cwi_val_penalty_map[ACS_CWI_MAP_VAL][ACS_CWI_MAP_VAL_LAST_IDX])
+		return ACS_CWI_PENALTY_MAX;
+
+	for (i = 0; i < ACS_CWI_PEN_MAP_NUM_COLS; i++) {
+		if (acs_cwi_val_penalty_map[ACS_CWI_MAP_VAL][i] == cwi_noise)
+			return acs_cwi_val_penalty_map[ACS_CWI_MAP_PEN][i];
+	}
+
+	wpa_printf(MSG_ERROR, "ACS: Penalty for CWI %d could not be mapped", cwi_noise);
+	return ACS_CWI_PENALTY_MAX;
+}
+
+enum acs_bss_map_e
+{
+	ACS_BSS_LOW_VAL,
+	ACS_BSS_HIGH_VAL,
+	ACS_BSS_MAP_PEN,
+
+	ACS_BSS_NUM_SIZE,
+};
+
+#define ACS_BSS_PENALTY_MIN			0
+#define ACS_BSS_PENALTY_MAX			100
+#define ACS_BSS_PEN_MAP_NUM_COLS	14
+#define ACS_BSS_PEN_MAP_NUM_ROWS	ACS_BSS_NUM_SIZE
+#define ACS_BSS_MAP_VAL_FIRST_IDX	0
+#define ACS_BSS_MAP_VAL_LAST_IDX	(ACS_BSS_PEN_MAP_NUM_COLS - 1)
+
+/* if bss rssi < -84, penalty is 0
+   if bss rssi > -15, penalty is 100
+   others bss rssi value ranges to penalty value are mapped in the table below */
+int acs_bss_rssi_penalty_map[ACS_BSS_PEN_MAP_NUM_ROWS][ACS_BSS_PEN_MAP_NUM_COLS] = {
+	{-84, -79, -74, -69, -64, -59, -54, -49, -44, -39, -34, -29, -24, -19}, /* RSSI low range mark */
+	{-80, -75, -70, -65, -60, -55, -50, -45, -40, -35, -30, -25, -20, -15}, /* RSSI high range mark */
+	{ 20,  40,  60,  80,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99}, /* Penalty */
+};
+
+static int acs_get_bss_rssi_penalty(int rssi)
+{
+	int i;
+
+	if (rssi < acs_bss_rssi_penalty_map[ACS_BSS_LOW_VAL][ACS_BSS_MAP_VAL_FIRST_IDX])
+		return ACS_BSS_PENALTY_MIN;
+	if (rssi > acs_bss_rssi_penalty_map[ACS_BSS_HIGH_VAL][ACS_BSS_MAP_VAL_LAST_IDX])
+		return ACS_BSS_PENALTY_MAX;
+
+	for (i = 0; i < ACS_BSS_PEN_MAP_NUM_COLS; i++) {
+		if ((rssi >= acs_bss_rssi_penalty_map[ACS_BSS_LOW_VAL][i]) &&
+			(rssi <= acs_bss_rssi_penalty_map[ACS_BSS_HIGH_VAL][i]))
+			return acs_bss_rssi_penalty_map[ACS_BSS_MAP_PEN][i];
+	}
+	wpa_printf(MSG_ERROR, "ACS: Penalty for BSS RSSI %d could not be mapped", rssi);
+	return ACS_BSS_PENALTY_MAX;
+}
+
+/* Open file for writing/appending. If opened for appending and it is bigger
+ * than 10K, file is saved with filename .0 at the end and a new empty file is
+ * created. */
+static FILE * acs_write_file(const char *name, bool append)
+{
+#define ACS_MAX_LOG_SIZE	102400 /* 100K */
+
+	FILE *fp;
+	long int sz;
+	int res;
+	char *bak_file;
+	size_t new_size;
+	rsize_t len;
+
+	if (!append)
+		return fopen(name, "w");
+	fp = fopen(name, "a+");
+	if (!fp) {
+		wpa_printf(MSG_ERROR, "ACS: cannot open file [%s]. %s", name,
+			strerror(errno));
+		return fp;
+	}
+	res = fseek(fp, 0L, SEEK_END);
+	if (res == -1) {
+		wpa_printf(MSG_ERROR, "ACS: cannot set file position indicator of file [%s]. %s",
+			name, strerror(errno));
+		fclose(fp);
+		return NULL;
+	}
+	sz = ftell(fp);
+	if (sz == -1) {
+		wpa_printf(MSG_ERROR, "ACS: cannot tell size of file [%s]. %s", name,
+			strerror(errno));
+		fclose(fp);
+		return NULL;
+	}
+	if (sz > ACS_MAX_LOG_SIZE) {
+		fclose(fp);
+		len = strnlen_s(name, RSIZE_MAX_STR);
+		if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, RSIZE_MAX_STR - 1)) {
+			wpa_printf(MSG_ERROR, "acs_write_file - wrong len");
+			return NULL;
+		}
+		new_size = len + 3;
+		bak_file = os_malloc(new_size);
+		if (bak_file == NULL)
+			return NULL;
+		res = sprintf_s(bak_file, new_size, "%s.0", name);
+		if (res <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, res);
+			fclose(fp);
+			os_free(bak_file);
+			return NULL;
+		}
+		remove(bak_file);
+		res = rename(name, bak_file);
+		os_free(bak_file);
+		if (res == -1)
+			wpa_printf(MSG_WARNING, "ACS: making backup of file [%s] failed. %s", name,
+				strerror(errno));
+		fp = fopen(name, "w");
+		if (!fp) {
+			wpa_printf(MSG_ERROR, "ACS: cannot open file [%s]. %s", name,
+				strerror(errno));
+		}
+	}
+	return fp;
+}
+
+static enum oper_chan_width get_oper_width(int width)
+{
+	switch (width) {
+		case 20:
+		case 40:  return CONF_OPER_CHWIDTH_USE_HT;
+		case 80:  return CONF_OPER_CHWIDTH_80MHZ;
+		case 160: return CONF_OPER_CHWIDTH_160MHZ;
+		default: wpa_printf(MSG_ERROR, "ACS: wrong or unsupported channel width %d", width);
+	}
+
+	return -1; /* should never happen */
+}
+
+static inline unsigned acs_freq_to_chan(int freq)
+{
+	u8 chan;
+	ieee80211_freq_to_chan(freq, &chan);
+	return chan;
+}
+
+static u32 acs_get_center_chan_index(struct hostapd_iface *iface)
+{
+	int i;
+	u32 primary, secondary;
+
+	primary   = iface->conf->channel;
+	secondary = iface->conf->secondary_channel ? iface->conf->channel + iface->conf->secondary_channel * 4 : 0;
+
+	if (hostapd_get_oper_chwidth(iface->conf) == CONF_OPER_CHWIDTH_80MHZ) {
+		if (is_6ghz_op_class(iface->conf->op_class)) {
+			for(i = 0; i < ARRAY_SIZE(g_channels80_6G); i++)
+				if (g_channels80_6G[i].primary == primary && g_channels80_6G[i].secondary == secondary)
+					return g_channels80_6G[i].chan_no;
+		}
+		else {
+			for(i = 0; i < ARRAY_SIZE(g_channels80); i++)
+				if (g_channels80[i].primary == primary && g_channels80[i].secondary == secondary)
+					return g_channels80[i].chan_no;
+		}
+	}
+	else if (hostapd_get_oper_chwidth(iface->conf) == CONF_OPER_CHWIDTH_160MHZ) {
+		if (is_6ghz_op_class(iface->conf->op_class)) {
+			for(i = 0; i < ARRAY_SIZE(g_channels160_6G); i++)
+				if (g_channels160_6G[i].primary == primary && g_channels160_6G[i].secondary == secondary)
+					return g_channels160_6G[i].chan_no;
+		}
+		else {
+			for(i = 0; i < ARRAY_SIZE(g_channels160); i++)
+				if (g_channels160[i].primary == primary && g_channels160[i].secondary == secondary)
+					return g_channels160[i].chan_no;
+		}
+	}
+
+	wpa_printf(MSG_ERROR, "didn't find center channel index from primary channel "
+			      "%d and secondary channel %d", primary, secondary);
+	return 0;
+}
+
+/* Smart ACS always fills iface->conf->secondary_channel, also for 6GHz, so it is safe to rely on it */
+static void acs_smart_adjust_center_freq(struct hostapd_iface *iface, unsigned center_chan_index)
+{
+	wpa_printf(MSG_DEBUG, "ACS SMART: Adjusting center frequency");
+
+	switch (hostapd_get_oper_chwidth(iface->conf)) {
+	case CONF_OPER_CHWIDTH_USE_HT:
+		center_chan_index = iface->conf->channel + 2 * iface->conf->secondary_channel;
+		break;
+	case CONF_OPER_CHWIDTH_80MHZ:
+	/* fall through */
+	case CONF_OPER_CHWIDTH_160MHZ:
+		/* For ACS fallback channel case */
+		if (!center_chan_index)
+			center_chan_index = acs_get_center_chan_index(iface);
+
+		break;
+	default:
+		wpa_printf(MSG_ERROR, "ACS SMART: Only 20/40/80/160 is supported at the moment");
+		return;
+	}
+
+	hostapd_set_oper_centr_freq_seg0_idx(iface->conf, center_chan_index);
+
+	/* In case Fallback channel or reduced BW from BW comparison algo update OP class */
+	if (is_6ghz_op_class(iface->conf->op_class))
+		iface->conf->op_class = HOSTAP_6GHZ_20MHZ_OP_CLASS + center_idx_to_bw_6ghz(center_chan_index);
+}
+
+static FILE* acs_fopen(const char *fname, bool append, const char *name)
+{
+	FILE *fp = acs_write_file(fname, append);
+
+	if (!fp) {
+		wpa_printf(MSG_ERROR, "Error opening the %s '%s': %s",
+			   name, fname, strerror(errno));
+		return stderr;
+	}
+	else
+		return fp;
+}
+
+static void acs_fclose(FILE *fp, const char *name)
+{
+	if (fp != stderr) {
+		if (fclose(fp))	wpa_printf(MSG_ERROR, "Error closing the %s: %s", name, strerror(errno));
+	}
+}
+
+static bool channels_overlap(u32 freq1, u32 width1, u32 freq2, u32 width2)
+{
+
+#define SINGLE_CHANNEL_WIDTH 20
+
+	/* convert the first channel's center frequency to the start of frequency range */
+	freq1 -= SINGLE_CHANNEL_WIDTH >> 1;
+	freq2 -= SINGLE_CHANNEL_WIDTH >> 1;
+
+	if ((freq2 >= freq1) && (freq1 + width1 > freq2)) return true;
+	if ((freq1 >= freq2) && (freq2 + width2 > freq1)) return true;
+	return false;
+}
+
+static bool is_vht_or_he(struct hostapd_iface *iface)
+{
+	if ((iface->conf->ieee80211ac) || (iface->conf->ieee80211ax)) {
+		return true;
+	}
+	return false;
+}
+
+static void ch_width_and_ch_num_to_seg_idx(int bss_width, u8 channel, u8* he_oper_centr_freq_seg0_idx, u8* he_oper_centr_freq_seg1_idx)
+{
+	switch(bss_width) {
+		case HE_OPER_CHANWIDTH_20:
+			*he_oper_centr_freq_seg0_idx = channel;
+			break;
+
+		case HE_OPER_CHANWIDTH_40:
+			switch (channel) {
+				case 1:
+				case 5:
+					*he_oper_centr_freq_seg0_idx = 3;
+					break;
+				case 9:
+				case 13:
+					*he_oper_centr_freq_seg0_idx = 11;
+					break;
+				case 17:
+				case 21:
+					*he_oper_centr_freq_seg0_idx = 19;
+					break;
+				case 25:
+				case 29:
+					*he_oper_centr_freq_seg0_idx = 27;
+					break;
+				case 33:
+				case 37:
+					*he_oper_centr_freq_seg0_idx = 35;
+					break;
+				case 41:
+				case 45:
+					*he_oper_centr_freq_seg0_idx = 43;
+					break;
+				case 49:
+				case 53:
+					*he_oper_centr_freq_seg0_idx = 51;
+					break;
+				case 57:
+				case 61:
+					*he_oper_centr_freq_seg0_idx = 59;
+					break;
+				case 65:
+				case 69:
+					*he_oper_centr_freq_seg0_idx = 67;
+					break;
+				case 73:
+				case 77:
+					*he_oper_centr_freq_seg0_idx = 75;
+					break;
+				case 81:
+				case 85:
+					*he_oper_centr_freq_seg0_idx = 83;
+					break;
+				case 89:
+				case 93:
+					*he_oper_centr_freq_seg0_idx = 91;
+					break;
+				case 97:
+				case 101:
+					*he_oper_centr_freq_seg0_idx = 99;
+					break;
+				case 105:
+				case 109:
+					*he_oper_centr_freq_seg0_idx = 107;
+					break;
+				case 113:
+				case 117:
+					*he_oper_centr_freq_seg0_idx = 115;
+					break;
+				case 121:
+				case 125:
+					*he_oper_centr_freq_seg0_idx = 123;
+					break;
+				case 129:
+				case 133:
+					*he_oper_centr_freq_seg0_idx = 131;
+					break;
+				case 137:
+				case 141:
+					*he_oper_centr_freq_seg0_idx = 139;
+					break;
+				case 145:
+				case 149:
+					*he_oper_centr_freq_seg0_idx = 147;
+					break;
+				case 153:
+				case 157:
+					*he_oper_centr_freq_seg0_idx = 155;
+					break;
+				case 161:
+				case 165:
+					*he_oper_centr_freq_seg0_idx = 163;
+					break;
+				case 169:
+				case 173:
+					*he_oper_centr_freq_seg0_idx = 171;
+					break;
+				case 177:
+				case 181:
+					*he_oper_centr_freq_seg0_idx = 179;
+					break;
+				case 185:
+				case 189:
+					*he_oper_centr_freq_seg0_idx = 187;
+					break;
+				case 193:
+				case 197:
+					*he_oper_centr_freq_seg0_idx = 195;
+					break;
+				case 201:
+				case 205:
+					*he_oper_centr_freq_seg0_idx = 203;
+					break;
+				case 209:
+				case 213:
+					*he_oper_centr_freq_seg0_idx = 211;
+					break;
+				case 217:
+				case 221:
+					*he_oper_centr_freq_seg0_idx = 219;
+					break;
+				case 225:
+				case 229:
+					*he_oper_centr_freq_seg0_idx = 227;
+					break;
+			}
+			break;
+
+		case HE_OPER_CHANWIDTH_80:
+				switch (channel) {
+					case 1:
+					case 5:
+					case 9:
+					case 13:
+						*he_oper_centr_freq_seg0_idx = 7;
+						break;
+					case 17:
+					case 21:
+					case 25:
+					case 29:
+						*he_oper_centr_freq_seg0_idx = 23;
+						break;
+					case 33:
+					case 37:
+					case 41:
+					case 45:
+						*he_oper_centr_freq_seg0_idx = 39;
+						break;
+					case 49:
+					case 53:
+					case 57:
+					case 61:
+						*he_oper_centr_freq_seg0_idx = 55;
+						break;
+					case 65:
+					case 69:
+					case 73:
+					case 77:
+						*he_oper_centr_freq_seg0_idx = 71;
+						break;
+					case 81:
+					case 85:
+					case 89:
+					case 93:
+						*he_oper_centr_freq_seg0_idx = 87;
+						break;
+					case 97:
+					case 101:
+					case 105:
+					case 109:
+						*he_oper_centr_freq_seg0_idx = 103;
+						break;
+					case 113:
+					case 117:
+					case 121:
+					case 125:
+						*he_oper_centr_freq_seg0_idx = 119;
+						break;
+					case 129:
+					case 133:
+					case 137:
+					case 141:
+						*he_oper_centr_freq_seg0_idx = 135;
+						break;
+					case 145:
+					case 149:
+					case 153:
+					case 157:
+						*he_oper_centr_freq_seg0_idx = 151;
+						break;
+					case 161:
+					case 165:
+					case 169:
+					case 173:
+						*he_oper_centr_freq_seg0_idx = 167;
+						break;
+					case 177:
+					case 181:
+					case 185:
+					case 189:
+						*he_oper_centr_freq_seg0_idx = 183;
+						break;
+					case 193:
+					case 197:
+					case 201:
+					case 205:
+						*he_oper_centr_freq_seg0_idx = 199;
+						break;
+					case 209:
+					case 213:
+					case 217:
+					case 221:
+						*he_oper_centr_freq_seg0_idx = 215;
+						break;
+				}
+			break;
+
+		case HE_OPER_CHANWIDTH_160:
+				switch (channel) {
+					case 1:
+					case 5:
+					case 9:
+					case 13:
+					case 17:
+					case 21:
+					case 25:
+					case 29:
+						*he_oper_centr_freq_seg1_idx = 15;
+						break;
+					case 33:
+					case 37:
+					case 41:
+					case 45:
+					case 49:
+					case 53:
+					case 57:
+					case 61:
+						*he_oper_centr_freq_seg1_idx = 47;
+						break;
+					case 65:
+					case 69:
+					case 73:
+					case 77:
+					case 81:
+					case 85:
+					case 89:
+					case 93:
+						*he_oper_centr_freq_seg1_idx = 79;
+						break;
+					case 97:
+					case 101:
+					case 105:
+					case 109:
+					case 113:
+					case 117:
+					case 121:
+					case 125:
+						*he_oper_centr_freq_seg1_idx = 111;
+						break;
+					case 129:
+					case 133:
+					case 137:
+					case 141:
+					case 145:
+					case 149:
+					case 153:
+					case 157:
+						*he_oper_centr_freq_seg1_idx = 143;
+						break;
+					case 161:
+					case 165:
+					case 169:
+					case 173:
+					case 177:
+					case 181:
+					case 185:
+					case 189:
+						*he_oper_centr_freq_seg1_idx = 175;
+						break;
+					case 193:
+					case 197:
+					case 201:
+					case 205:
+					case 209:
+					case 213:
+					case 217:
+					case 221:
+						*he_oper_centr_freq_seg1_idx = 207;
+						break;
+				}
+			switch (channel) {
+				case 1:
+				case 5:
+				case 9:
+				case 13:
+					*he_oper_centr_freq_seg0_idx = 7;
+					break;
+				case 17:
+				case 21:
+				case 25:
+				case 29:
+					*he_oper_centr_freq_seg0_idx = 23;
+					break;
+				case 33:
+				case 37:
+				case 41:
+				case 45:
+					*he_oper_centr_freq_seg0_idx = 39;
+					break;
+				case 49:
+				case 53:
+				case 57:
+				case 61:
+						*he_oper_centr_freq_seg0_idx = 55;
+						break;
+				case 65:
+				case 69:
+				case 73:
+				case 77:
+						*he_oper_centr_freq_seg0_idx = 71;
+						break;
+				case 81:
+				case 85:
+				case 89:
+				case 93:
+						*he_oper_centr_freq_seg0_idx = 87;
+						break;
+				case 97:
+				case 101:
+				case 105:
+				case 109:
+						*he_oper_centr_freq_seg0_idx = 103;
+						break;
+				case 113:
+				case 117:
+				case 121:
+				case 125:
+						*he_oper_centr_freq_seg0_idx = 119 ;;
+						break;
+				case 129:
+				case 133:
+				case 137:
+				case 141:
+						*he_oper_centr_freq_seg0_idx = 135;
+						break;
+				case 145:
+				case 149:
+				case 153:
+				case 157:
+						*he_oper_centr_freq_seg0_idx = 151;
+						break;
+				case 161:
+				case 165:
+				case 169:
+				case 173:
+						*he_oper_centr_freq_seg0_idx = 167;
+						break;
+				case 177:
+				case 181:
+				case 185:
+				case 189:
+						*he_oper_centr_freq_seg0_idx = 183;
+						break;
+				case 193:
+				case 197:
+				case 201:
+				case 205:
+						*he_oper_centr_freq_seg0_idx = 199;
+						break;
+				case 209:
+				case 213:
+				case 217:
+				case 221:
+						*he_oper_centr_freq_seg0_idx = 215;
+						break;
+			}
+	}
+}
+
+void acs_smart_record_bsses(struct hostapd_iface *iface, struct wpa_scan_results *scan_res, FILE *fp)
+{
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	int i, j;
+	struct hapd_interfaces *ifaces = iface->interfaces;
+
+	wpa_printf(MSG_DEBUG, "ACS_SMART: recording BSS-es");
+
+	iface->mxl_iface.acs_num_bss = 0;
+
+	for (j = 0; j < iface->mxl_iface.num_candidates; j++) {
+		candidates[j].num_bss = 0;
+		candidates[j].num_bss_pri = 0;
+		candidates[j].overlap40 = 0;
+		candidates[j].overlap_vht_he = 0;
+		candidates[j].intolerant40 = 0;
+	}
+
+	fprintf(fp, "\n# ssid                          \twidth\tprimary\tsecondary\tcenter0\tcenter1\trssi\n");
+
+	for (i = 0; i < scan_res->num; i++) {
+		struct wpa_scan_res *bss = scan_res->res[i];
+		struct ieee802_11_elems elems;
+		struct ieee80211_ht_capabilities *ht_cap = NULL;
+		struct ieee80211_ht_operation *ht_oper = NULL;
+		struct ieee80211_vht_operation *vht_oper = NULL;
+		struct ieee80211_he_operation *he_oper = NULL;
+		int bss_sec_freq = 0;
+		int bss_center_freq0 = bss->freq;
+		int bss_center_freq1 = 0;
+		int cf = 0;
+		int bss_width = 0;
+		int bss_base_freq;
+		int num_width = 20;
+		int bss_rssi_penalty;
+		const char *bss_printable_width = "20";
+		u8 he_6ghz_pri_chan = 0;
+		u8 he_6ghz_seg0_offset = 0;
+		u8 he_6ghz_seg1_offset = 0;
+		int sec_offset = 0;
+		u8 len = 0, fopclass = 0;
+		u16 fd = 0;
+		bool is_short_ssid = false;
+		u8 ssid_len;
+		char ssid_string[SSID_MAX_LEN];
+
+		if (!mxl_acs_find_chan(iface, bss->freq))
+			continue;
+		ieee802_11_parse_elems((u8 *)(bss + 1), bss->ie_len, &elems, 0);
+
+		if (bss->level < iface->conf->mxl_conf.ScanRssiTh) {
+			wpa_printf(MSG_DEBUG, "Skip due to low BSS:%-32.*s RSSI:%d", elems.ssid_len, elems.ssid, bss->level);
+			continue;
+		}
+
+		/* get the HT capabilities element, needed later when we analyze each channel */
+		if (elems.ht_capabilities)
+			ht_cap = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
+
+		/* get the secondary channel's frequency */
+		if (elems.ht_operation) {
+			ht_oper = (struct ieee80211_ht_operation *) elems.ht_operation;
+
+			if (ht_oper->ht_param & HT_INFO_HT_PARAM_STA_CHNL_WIDTH) {
+				int sec = ht_oper->ht_param & HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK;
+				if (sec == HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE) {
+					bss_printable_width = "40";
+					num_width = 40;
+					bss_sec_freq = bss->freq + 20;
+				}
+				else if (sec == HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW) {
+					bss_printable_width = "40";
+					bss_sec_freq = bss->freq - 20;
+					num_width = 40;
+				}
+				bss_center_freq0 = (bss->freq + bss_sec_freq) / 2;
+			}
+		}
+
+		/* get the vht operational info if in 5 GHz band */
+		if (mode->mode == HOSTAPD_MODE_IEEE80211A && elems.vht_operation) {
+			vht_oper = (struct ieee80211_vht_operation *) elems.vht_operation;
+			bss_width = vht_oper->vht_op_info_chwidth;
+
+			/* IEEE802.11-2016, 9.4.2.159 VHT Operation IE, Table 9-252 */
+			if (bss_width > VHT_OPER_CHANWIDTH_20_40MHZ) {
+				num_width = 80;
+				bss_printable_width = "80";
+				bss_center_freq0 = 5000 + 5 * vht_oper->vht_op_info_chan_center_freq_seg0_idx;
+
+				switch (bss_width) {
+				case VHT_OPER_CHANWIDTH_80_160_80P80MHZ:
+					if (vht_oper->vht_op_info_chan_center_freq_seg1_idx) {
+						bss_center_freq1 = 5000 + 5 * vht_oper->vht_op_info_chan_center_freq_seg1_idx;
+
+						/* IEEE802.11-2016, 9.4.2.159 VHT Operation IE, Table 9-253 */
+						if (abs(vht_oper->vht_op_info_chan_center_freq_seg1_idx -
+							vht_oper->vht_op_info_chan_center_freq_seg0_idx) == CF0_AND_CF1_IDX_DIFF_IN_160_MHZ) {
+							bss_printable_width = "160";
+							num_width = 160;
+						}
+						else {
+							bss_printable_width = "80+80";
+						}
+					}
+					break;
+				case VHT_OPER_CHANWIDTH_160MHZ: /* Deprecated format */
+					bss_printable_width = "160";
+					num_width = 160;
+					break;
+				case VHT_OPER_CHANWIDTH_80P80MHZ: /* Deprecated format */
+					bss_center_freq1 = 5000 + 5 * vht_oper->vht_op_info_chan_center_freq_seg1_idx;
+					bss_printable_width = "80+80";
+					break;
+				default:
+					wpa_printf(MSG_WARNING, "Smart ACS: BSS with Unsupported VHT channel width %d detected", bss_width);
+					break;
+				}
+			}
+		}
+
+		if (is_6ghz_op_class(iface->conf->op_class)) {
+			/* Aligned to opensource HE */
+			he_oper = (struct ieee80211_he_operation *)elems.he_operation;
+			if (he_oper && (he_oper->he_oper_params & HE_OPERATION_6GHZ_OPER_INFO)
+						&& (!(he_oper->he_oper_params & (HE_OPERATION_COHOSTED_BSS | HE_OPERATION_VHT_OPER_INFO)))) {
+				struct ieee80211_he_6ghz_oper_info *he_6ghz_oper_info = (struct ieee80211_he_6ghz_oper_info *)(he_oper + 1); /* means he_oper + sizeof(he_oper) */
+				he_6ghz_pri_chan = he_6ghz_oper_info->primary_chan;
+				he_6ghz_seg0_offset = he_6ghz_oper_info->chan_center_freq_seg0;
+				he_6ghz_seg1_offset = he_6ghz_oper_info->chan_center_freq_seg1;
+				bss_width = he_6ghz_oper_info->control & HE_6GHZ_OPER_INFO_CTRL_CHAN_WIDTH_MASK;
+				bss_center_freq0 = WAVE_6G_STARTING_FREQ + (5 * he_6ghz_seg0_offset);
+				if (he_6ghz_seg1_offset)
+					bss_center_freq1 = WAVE_6G_STARTING_FREQ + (5 * he_6ghz_seg1_offset);
+				wpa_printf(MSG_DEBUG, "6GHz oper info: pri = %d, width = %d, cf0 = %d, cf1 = %d",
+									   he_6ghz_pri_chan, bss_width, bss_center_freq0, bss_center_freq1);
+			}
+			else if (elems.mxl_fils_ie) {
+				/*
+				* FILS frame from AP:
+
+				|------------------------------------------------------------------------------------------------------------|
+			Bytes	|  2     |  8   |  2    |  1-32   | 0-1   | 0-2     | 0-1      | 0-1 | 0-1  | 0-1   | 0-5  |  0-1   | 0-3    |
+				|--------|------|-------|---------|-------|---------|----------|-----|------|-------|------|--------|--------|
+			Descr	| FILS   |time  | Beacon|SSID/    |Length | FD      |operating |prim |Ap seq|Access |FD RSN|Chan feq|mobility|
+				|discovey|stamp | int   |shortSSID|       |Capablity|clss      |chan |num   |Network|info  | seg 1  |domain  |
+				|------------------------------------------------------------------------------------------------------------|
+				* Total: 12 + optional bytes
+				* fils discovry has ssid len,primary chan,center freq, length presence bit used to parse fils.
+				* The Timestamp subfield carries the value of the TSF timer.
+				* The Beacon Interval subfield carries the beacon interval in TUs.
+				* The Beacon Interval subfield carries the beacon interval in TUs.
+				* The Length subfield indicates the length of the remaining fields in the FILS Discovery Information field in
+				* octets. Its value is variable.
+				* The FD Capability subfield contains the information that advertises the capabilities and operational
+				* indications of the STA transmitting the FILS Discovery frame, our interest is BSS operating width.
+				* The Operating Class subfield specifies the operating class of the Primary Channel of the transmitting AP
+				* The Primary Channel subfield is set to the channel number of the primary channel
+				* The Channel Center Frequency Segment 1 subfield is set to the index of the channel center frequency of the
+				* frequency segment 1
+				* */
+				u8 *fbuf = (u8 *)(elems.mxl_fils_ie + MXL_OUI_LEN);
+				if(fbuf[0] & (FILS_SHORT_SSID_INDICATOR)) {
+					is_short_ssid = true;
+					elems.ssid = (fbuf + FILS_FIXED_LEN);
+				}
+				else {
+					elems.ssid = (fbuf + FILS_FIXED_LEN);
+				}
+				/* The SSID Length subfield of the FILS Discovery Frame Control subfield indicates the length,in octets,
+				 * of the SSID/Short SSID subfield in the FILS Discovery frame. This subfield is equal to the length of the
+				 * SSID/Short SSID subfield in octets minus 1.
+				 * */
+				elems.ssid_len = ((fbuf[0] & (FILS_SSID_LEN)) + 1);
+				if (fbuf[1] & (FILS_LEN_PRESENCE_INDICATOR)) {
+					len = fbuf[FILS_FIXED_LEN + elems.ssid_len];
+				}
+				if (fbuf[0] & (FILS_CAPABALITY_PRESENCE_INDICATOR)) {
+					memcpy(&fd, &fbuf[FILS_FIXED_LEN + elems.ssid_len  + FILS_LENGTH_SUBFIELD_SIZE], sizeof(fd));
+				}
+				if (fd) {
+					bss_width = (fd & FILS_BSS_OPERATING_CHANNEL_WIDTH);
+					ieee80211_freq_to_chan(bss->freq, &he_6ghz_pri_chan);
+				}
+				if ((len) && (fbuf[1] & (FILS_PRIMARY_CHANNEL_PRESENCE_INDICATOR))) {
+					he_6ghz_pri_chan = fbuf[FILS_FIXED_LEN + elems.ssid_len + FILS_LENGTH_SUBFIELD_SIZE + FILS_PRIMARY_CHANNEL_OFFSET];
+					fopclass = fbuf[FILS_FIXED_LEN + elems.ssid_len + FILS_LENGTH_SUBFIELD_SIZE];
+					bss_width = op_class_to_bandwidth(fopclass);
+					switch (bss_width) {
+						case 20:
+							bss_width = HE_OPER_CHANWIDTH_20;
+							break;
+						case 40:
+							bss_width = HE_OPER_CHANWIDTH_40;
+							break;
+						case 80:
+							bss_width = HE_OPER_CHANWIDTH_80;
+							break;
+						case 160:
+							bss_width = HE_OPER_CHANWIDTH_160;
+							break;
+						default:
+							break;
+					}
+				}
+				if ((len) && (fbuf[1] & (FILS_CHANNEL_CENTRE_FREQUENCY_SEG1))) {
+					bss_center_freq1 = fbuf[FILS_FIXED_LEN + elems.ssid_len + FILS_LENGTH_SUBFIELD_SIZE + FILS_CHANNEL_CENTRE_FREQUENCY_SEG1_OFFSET];
+				}
+
+				ch_width_and_ch_num_to_seg_idx(bss_width, he_6ghz_pri_chan, &he_6ghz_seg0_offset, &he_6ghz_seg1_offset);
+
+				if (he_6ghz_seg0_offset)
+					bss_center_freq0 = WAVE_6G_STARTING_FREQ + (5 * he_6ghz_seg0_offset);
+				if (he_6ghz_seg1_offset)
+					bss_center_freq1 = WAVE_6G_STARTING_FREQ + (5 * he_6ghz_seg1_offset);
+
+				wpa_printf(MSG_DEBUG, "Fils frame info  pri = %d, width = %d, cf0 = %d, cf1 = %d, elems.ssid = %02X:%02X:%02X:%02X, fopclass = %d",
+						he_6ghz_pri_chan, bss_width, bss_center_freq0, bss_center_freq1, elems.ssid[0], elems.ssid[1], elems.ssid[2], elems.ssid[3], fopclass);
+				}
+				switch(bss_width) {
+					case HE_OPER_CHANWIDTH_20:
+						bss_printable_width = "20";
+						num_width = 20;
+						break;
+					case HE_OPER_CHANWIDTH_40:
+						bss_printable_width = "40";
+						num_width = 40;
+						sec_offset = (he_6ghz_seg0_offset > he_6ghz_pri_chan) ? 20 : -20;
+						bss_sec_freq = bss->freq + sec_offset;
+						break;
+					case HE_OPER_CHANWIDTH_80:
+						bss_printable_width = "80";
+						num_width = 80;
+						break;
+					case HE_OPER_CHANWIDTH_160:
+						bss_printable_width = "160";
+						num_width = 160;
+						break;
+					default:
+						break;
+				}
+			}
+
+		if (is_short_ssid) {
+			ssid_len = snprintf(ssid_string, sizeof(ssid_string), "%02X:%02X:%02X:%02X", elems.ssid[0], elems.ssid[1], elems.ssid[2], elems.ssid[3]);
+		}
+		else {
+			snprintf(ssid_string, sizeof(ssid_string), "%s", elems.ssid);
+			ssid_len = elems.ssid_len;
+		}
+
+		if (elems.rnr) {
+			mxl_parse_rnr(&elems, &iface->interfaces->rnr_scan_6g_ap_info);
+		}
+
+		fprintf(fp, "%-32.*s\t%5s\t%7u\t%9u\t%7u\t%7u\t%4d\n",
+			ssid_len, ssid_string, bss_printable_width,
+			acs_freq_to_chan(bss->freq),
+			bss_sec_freq > 0 ? acs_freq_to_chan(bss_sec_freq) : 0,
+			acs_freq_to_chan(bss_center_freq0),
+			bss_center_freq1 > 0 ? acs_freq_to_chan(bss_center_freq1) : 0,
+			bss->level);
+		/* for 80+80 BSS only the first segment considered for Candidates ranking */
+		if (os_strcmp(bss_printable_width, "80+80") == 0)
+			bss_center_freq1 = 0;
+
+		cf = (bss_center_freq1 ? bss_center_freq1 : bss_center_freq0);
+		bss_base_freq = cf - (num_width >> 1) + (SINGLE_CHANNEL_WIDTH >> 1);
+
+		/* increase the relevant counters in every channel affected */
+		for (j = 0; j < iface->mxl_iface.num_candidates; j++)
+		{
+			bool primary_ch_overlap;
+			if (!channels_overlap(candidates[j].freq, candidates[j].width, bss_base_freq, num_width))
+				continue;
+
+			primary_ch_overlap = channels_overlap(hostapd_chan_to_freq(candidates[j].primary, is_6ghz_op_class(iface->conf->op_class)), 20, bss_base_freq, num_width);
+			if (primary_ch_overlap) {
+				candidates[j].num_bss_pri++;
+			}
+			candidates[j].num_bss++;
+			bss_rssi_penalty = acs_get_bss_rssi_penalty(bss->level);
+			candidates[j].num_bss_pen += bss_rssi_penalty;
+			wpa_printf(MSG_EXCESSIVE, "ACS: Adding BSS penalty %d (from RSSI %d) to candidate idx %d",
+				   bss_rssi_penalty, bss->level, j);
+
+			/* Exclude candidates based on CoEx rules from standard for HT and VHT */
+			if (candidates[j].width < 40)
+				continue;
+
+			if (ht_cap && (le_to_host16(ht_cap->ht_capabilities_info) & HT_CAP_INFO_40MHZ_INTOLERANT)) {
+				candidates[j].intolerant40++;
+				os_get_reltime(&candidates[j].ts_intolerant40);
+				continue;
+			}
+
+			if (bss->level < iface->conf->mxl_conf.obss_beacon_rssi_threshold)
+				continue;
+
+			/* HT 2.4 GHz: IEEE Std 802.11-2016 Chapter 11.16.3.2 */
+			if ((mode->mode == HOSTAPD_MODE_IEEE80211G) &&
+			   ((hostapd_chan_to_freq(candidates[j].primary, false) != bss->freq) ||
+			    (bss_sec_freq && (hostapd_chan_to_freq(candidates[j].secondary, false) != bss_sec_freq)))) {
+				candidates[j].overlap40 = true;
+				os_get_reltime(&candidates[j].ts_overlap40);
+				continue;
+			}
+
+			/* VHT: IEEE Std 802.11-2016 Chapter 11.40.2 */
+			if (is_vht_or_he(iface) &&
+			    (bss_sec_freq && (hostapd_chan_to_freq(candidates[j].primary, false) == bss_sec_freq))) {
+				candidates[j].overlap_vht_he = 1;
+				os_get_reltime(&candidates[j].ts_overlap_vht_he);
+			}
+		} /* for - candidates */
+		iface->mxl_iface.acs_num_bss++;
+	}
+
+	if (!dl_list_empty(&ifaces->rnr_scan_6g_ap_info)) {
+		iface->mxl_iface.acs_rnr_available = 1;
+	}
+
+	for (i = 0; i < iface->mxl_iface.num_candidates; i++) {
+		if (candidates[i].num_bss_pen > iface->mxl_iface.max_num_bss_pen)
+			iface->mxl_iface.max_num_bss_pen = candidates[i].num_bss_pen;
+	}
+
+	iface->conf->mxl_conf.acs_init_done = 1;
+
+	fprintf(fp, "\nnum_bss = %d\n\n", iface->mxl_iface.acs_num_bss);
+}
+
+static bool acs_is_chan_scanned(struct hostapd_iface *iface, short chan)
+{
+	int i;
+	struct acs_candidate_table *candidate = iface->mxl_iface.candidates;
+
+	for (i = 0; (i < iface->mxl_iface.num_candidates && i < MAX_CANDIDATES); i++) {
+		if ((candidate[i].primary == chan) &&
+		    (20 == candidate[i].width))
+			return candidate[i].scanned;
+	}
+
+	return false;
+}
+
+static bool acs_are_all_available_chans_scanned(struct hostapd_iface *iface)
+{
+	int i, num_available_chans = 0, num_scanned = 0;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+
+	for (i = 0; i < mode->num_channels; i++) {
+		if (!(mode->channels[i].flag & HOSTAPD_CHAN_DISABLED) &&
+		    mxl_is_in_chanlist(iface, &mode->channels[i])) {
+
+			/* we care only about available channels, as we can't
+			 * do CSA to usable or unavailable channels anyway */
+			if ((mode->channels[i].flag & HOSTAPD_CHAN_RADAR) &&
+			    ((mode->channels[i].flag & HOSTAPD_CHAN_DFS_MASK) != HOSTAPD_CHAN_DFS_AVAILABLE))
+				continue;
+
+			num_available_chans++;
+
+			if (acs_is_chan_scanned(iface, mode->channels[i].chan))
+				num_scanned++;
+		}
+	}
+
+	wpa_printf(MSG_DEBUG, "Dynamic failsafe: num channels %u (available %d), scanned %u",
+		   mode->num_channels, num_available_chans, num_scanned);
+
+	return num_available_chans == num_scanned;
+}
+
+void mxl_acs_smart_process_bsses(struct hostapd_iface *iface, struct wpa_scan_results *scan_res)
+{
+	int res;
+	FILE *fp = acs_fopen(iface->conf->mxl_conf.acs_history_file, iface->conf->mxl_conf.acs_init_done ? true : false, "ACS history file");
+
+	acs_smart_record_bsses(iface, scan_res, fp);
+
+	acs_fclose(fp, "ACS history file");
+
+	mxl_acs_update_radar(iface);
+	res = mxl_acs_recalc_ranks_and_set_chan(iface, SWR_INITIAL);
+
+	/* hostapd_setup_interface_complete() will return -1 on failure and 0 on success */
+	if (mxl_hostapd_acs_completed(iface, 0, (res == 1)) == 0)
+	{
+		acs_cleanup(iface);
+		return;
+	}
+
+	/* If we're here then somehow ACS chose an invalid channel */
+	wpa_printf(MSG_ERROR, "SmartACS: BSS procedure failed. If reporting, please include your config file and info file '%s'.", iface->conf->mxl_conf.acs_smart_info_file);
+	mxl_acs_fail(iface);
+}
+
+void mxl_acs_bg_scan_complete(struct hostapd_iface *iface)
+{
+	struct wpa_scan_results *scan_res = NULL;
+	FILE *fp;
+	mxl_acs_chandef cur_chan;
+
+	if (iface->mxl_iface.acs_update_in_progress) {
+		wpa_printf(MSG_INFO, "ACS Update already in progress");
+		return;
+	}
+
+	iface->mxl_iface.in_scan = 0;
+	iface->mxl_iface.acs_update_in_progress = 1;
+
+	scan_res = hostapd_driver_get_scan_results(iface->bss[0]);
+
+	if (scan_res == NULL) {
+		wpa_printf(MSG_ERROR, "ACS: Failed to get BSS data from BG scan");
+		iface->mxl_iface.acs_update_in_progress = 0;
+	return;
+	}
+
+	acs_push_chandef(iface, &cur_chan);
+
+	wpa_printf(MSG_INFO, "BSS data from BG scan received");
+	fp = acs_fopen(iface->conf->mxl_conf.acs_history_file, true, "ACS history file");
+
+	acs_smart_record_bsses(iface, scan_res, fp);
+	wpa_scan_results_free(scan_res);
+
+	acs_fclose(fp, "ACS history file");
+
+	if (mxl_acs_recalc_ranks_and_set_chan(iface, SWR_BG_SCAN) > 0) {
+		if (mxl_acs_do_switch_channel(iface, 0) < 0) {
+			/* back out with channel switch */
+			acs_pop_chandef(iface, &cur_chan);
+		}
+	}
+
+	iface->mxl_iface.acs_update_in_progress = 0;
+	return;
+}
+
+static const char * acs_6g_scan_state_text(enum hostapd_acs_6g_scan_status status)
+{
+	switch (status) {
+		case SCAN_6G_IDLE:    	return "IDLE";
+		case SCAN_6G_STARTED: 	return "STARTED";
+		case SCAN_6G_WAITING: 	return "WAITING";
+		case SCAN_6G_DONE:    	return "DONE";
+		case SCAN_6G_COMPLETE:	return "COMPLETE";
+	}
+	return "UNKNOWN";
+}
+
+static const char * acs_6g_scan_type_text(enum hostapd_acs_6g_scan_type type)
+{
+	switch (type) {
+		case SCAN_6G_NONE:           return "SCAN_6G_NONE";
+		case SCAN_6G_PSC_OPT:        return "SCAN_6G_PSC_OPT";
+		case SCAN_6G_RNR_PASSIVE:    return "SCAN_6G_RNR_PASSIVE";
+		case SCAN_6G_FULL_BAND:      return "SCAN_6G_FULL_BAND";
+		case SCAN_6G_UNII5_UNII7_BAND: return "SCAN_6G_UNII5_UNII7_BAND";
+	}
+	return "UNKNOWN";
+}
+
+int is_24ghz_op_class(u8 op_class);
+int is_5ghz_op_class(u8 op_class);
+
+void acs_get_rnr_status(struct hostapd_iface *iface, u8 *rnr_24g, u8 *rnr_5g)
+{
+	u8 count;
+
+	for (count = 0; count < iface->interfaces->count; count++) {
+		if (is_24ghz_op_class(iface->interfaces->iface[count]->conf->op_class)) {
+			*rnr_24g = iface->interfaces->iface[count]->mxl_iface.acs_rnr_available;
+		}
+		else if (is_5ghz_op_class(iface->interfaces->iface[count]->conf->op_class)) {
+			*rnr_5g = iface->interfaces->iface[count]->mxl_iface.acs_rnr_available;
+		}
+	}
+}
+
+void mxl_acs_rnr_scan_timer_handler(void *eloop_ctx, void *timeout_ctx)
+{
+	struct hostapd_iface *iface = eloop_ctx;
+
+	wpa_printf(MSG_DEBUG, "6G ACS : RNR scan timer expired");
+
+	/* Get 2.4G and 5G ACS conf and status*/
+	mxl_acs_get_lower_band_status(iface);
+
+	if ((iface->mxl_iface.acs_6g_scan_type == SCAN_6G_RNR_PASSIVE ||
+		iface->mxl_iface.acs_6g_scan_type == SCAN_6G_FULL_BAND) &&
+		(iface->mxl_iface.acs_6g_scan_status == SCAN_6G_STARTED)) {
+
+		if (mxl_acs_request_scan(iface) < 0) {
+			wpa_printf(MSG_ERROR, "6G ACS : Scan Request Failed, Completing Scan");
+			goto complete;
+		}
+	} else {
+		goto complete;
+	}
+	return;
+complete:
+	iface->mxl_iface.acs_6g_scan_status = SCAN_6G_COMPLETE;
+	mxl_acs_scan_complete(iface);
+}
+
+void acs_init_defaults_candidate_table(struct hostapd_iface *iface)
+{
+	int i;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	s8 tx_power = 0;
+
+	/* Get TX power from 1'st PSC channel */
+	for (i = 0; (i < iface->mxl_iface.num_candidates && i < MAX_CANDIDATES); i++) {
+		if (is_6ghz_psc_frequency(candidates[i].freq)) {
+			tx_power = candidates[i].tx_power;
+			break;
+		}
+	}
+
+	/* Initialize NON-PSC channel candidates to have default CWI and
+	   TX-POWER so that they can be considered for ranking calculation */
+	for (i = 0; (i < iface->mxl_iface.num_candidates && i < MAX_CANDIDATES); i++) {
+
+		if (is_6ghz_psc_frequency(candidates[i].freq) || mxl_is_6ghz_opt_freq(iface, candidates[i].freq))
+			continue;
+
+		candidates[i].cwi_noise[PRI_20]	= ACS_DEFAULT_CWI;
+		candidates[i].tx_power = tx_power;
+	}
+}
+
+void mxl_acs_restore_6g_scan_states(struct hostapd_iface *iface)
+{
+	iface->mxl_iface.acs_6g_scan_type = SCAN_6G_NONE;
+	iface->mxl_iface.acs_6g_scan_status = SCAN_6G_IDLE;
+}
+
+void mxl_acs_get_lower_band_status(struct hostapd_iface *iface)
+{
+	u8 rnr_24g = 0, iface_state_24g = 0, count;
+	u8 rnr_5g = 0, iface_state_5g = 0;
+	u8 acs_24g = 0, acs_5g = 0;
+
+	for (count = 0; count < iface->interfaces->count; count++) {
+		if (is_24ghz_op_class(iface->interfaces->iface[count]->conf->op_class)) {
+			rnr_24g = iface->interfaces->iface[count]->mxl_iface.acs_rnr_available;
+			iface_state_24g = iface->interfaces->iface[count]->state;
+			acs_24g         = iface->interfaces->iface[count]->conf->acs;
+		}
+		if (is_5ghz_op_class(iface->interfaces->iface[count]->conf->op_class)) {
+			rnr_5g = iface->interfaces->iface[count]->mxl_iface.acs_rnr_available;
+			iface_state_5g = iface->interfaces->iface[count]->state;
+			acs_5g = iface->interfaces->iface[count]->conf->acs;
+		}
+	}
+
+	wpa_printf(MSG_DEBUG, "6G ACS - op_class %d, i/f count : %zu, rnr_5g : %d, iface_state_5g : %d, acs_5g : %d, rnr_24g : %d, iface_state_24g : %d, acs_24g : %d", iface->conf->op_class, iface->interfaces->count,rnr_5g, iface_state_5g, acs_5g, rnr_24g, iface_state_24g, acs_24g);
+
+	/* Check if Lower band Interface is already Enabled or Disabled*/
+	if ((iface_state_24g == HAPD_IFACE_ENABLED ||
+		iface_state_24g == HAPD_IFACE_UNINITIALIZED ||
+		iface_state_24g == HAPD_IFACE_DISABLED) &&
+		(iface_state_5g == HAPD_IFACE_ENABLED ||
+		iface_state_5g == HAPD_IFACE_UNINITIALIZED ||
+		iface_state_5g == HAPD_IFACE_DISABLED))	{
+			wpa_printf(MSG_DEBUG, "6G ACS - FULL BAND SCAN as lower band interface are already enabled/disabled");
+			iface->mxl_iface.acs_6g_scan_type = SCAN_6G_FULL_BAND;
+			iface->mxl_iface.acs_6g_scan_status = SCAN_6G_STARTED;
+			return;
+	}
+
+	/* Check if lower band ACS is enabled */
+	if (!(acs_24g && acs_5g)) {
+		wpa_printf(MSG_DEBUG, "6G ACS - FULL BAND SCAN as ACS is disabled in lower bands");
+		iface->mxl_iface.acs_6g_scan_type = SCAN_6G_FULL_BAND;
+		iface->mxl_iface.acs_6g_scan_status = SCAN_6G_STARTED;
+		return;
+	}
+
+	/* Check for lower band RNR data availibitly */
+	if (rnr_24g || rnr_5g) {
+		mxl_acs_6ghz_prepare_rnr_scan_data(iface);
+		acs_init_defaults_candidate_table(iface);
+		if (iface->mxl_iface.acs_6ghz_passive_ch_num) {
+			iface->mxl_iface.acs_6g_scan_type = SCAN_6G_FULL_BAND;
+			iface->mxl_iface.acs_6g_scan_status = SCAN_6G_STARTED;
+		}
+		else {
+			/* Lower band scan done but did not find any channel for RNR Passive Scan*/
+			iface->mxl_iface.acs_6g_scan_type = SCAN_6G_RNR_PASSIVE;
+			iface->mxl_iface.acs_6g_scan_status = SCAN_6G_COMPLETE;
+		}
+	}
+}
+
+void mxl_acs_update_scan_states(struct hostapd_iface *iface)
+{
+
+	if (iface->mxl_iface.acs_6g_scan_type == SCAN_6G_NONE &&
+		iface->mxl_iface.acs_6g_scan_status == SCAN_6G_IDLE) {
+
+		/* Looks to be the first scan call for 6G */
+		iface->mxl_iface.acs_6g_scan_type = SCAN_6G_PSC_OPT;
+		iface->mxl_iface.acs_6g_scan_status = SCAN_6G_STARTED;
+		wpa_printf(MSG_DEBUG, "6G ACS - Update : scan_type : %s->%s  scan_state : %s->%s",
+					acs_6g_scan_type_text(SCAN_6G_NONE), acs_6g_scan_type_text(iface->mxl_iface.acs_6g_scan_type),
+					acs_6g_scan_state_text(SCAN_6G_IDLE), acs_6g_scan_state_text(iface->mxl_iface.acs_6g_scan_status));
+		return;
+	} else if (iface->mxl_iface.acs_6g_scan_type == SCAN_6G_PSC_OPT && iface->mxl_iface.acs_6g_scan_status == SCAN_6G_DONE) {
+
+		/* PSC Scan is completed and Next is RNR */
+		wpa_printf(MSG_DEBUG, "6G ACS PSC is completed - waiting for lower bands RNR results ...");
+		iface->mxl_iface.acs_6g_scan_type = SCAN_6G_RNR_PASSIVE;
+		iface->mxl_iface.acs_6g_scan_status = SCAN_6G_WAITING;
+		eloop_register_timeout(iface->conf->mxl_conf.acs_rnr_scan_timeout, 0, mxl_acs_rnr_scan_timer_handler, iface, NULL);
+	} else {
+		wpa_printf(MSG_ERROR, "6G ACS - Invalid scan state - Update : scan_type : %s scan_state : %s",
+					acs_6g_scan_type_text(iface->mxl_iface.acs_6g_scan_type),
+					acs_6g_scan_state_text(iface->mxl_iface.acs_6g_scan_status));
+		goto complete;
+	}
+	return;
+complete:
+	iface->mxl_iface.acs_6g_scan_status = SCAN_6G_COMPLETE;
+	mxl_acs_scan_complete(iface);
+}
+
+void mxl_acs_rnr_scan_cb(struct hostapd_iface *iface)
+{
+	u8 rnr_24g = 0, rnr_5g = 0;
+
+	if (iface->mxl_iface.acs_6g_scan_status == SCAN_6G_COMPLETE ||
+		iface->mxl_iface.acs_6g_scan_status == SCAN_6G_STARTED) {
+		/* Ignore RNR scan call for 6G as timer has timed-out */
+		wpa_printf(MSG_DEBUG, "6G ACS : RNR scan req. from lower band but timer already expired - Ignoring req.");
+		return;
+	}
+	acs_get_rnr_status(iface, &rnr_24g, &rnr_5g);
+	wpa_printf(MSG_DEBUG, "6G ACS : RNR Scan req from lower bands : 2.4 - %d 5 - %d", rnr_24g, rnr_5g);
+
+	if (rnr_24g && rnr_5g) {
+		/* RNR results for both band available before timer timed-out */
+		eloop_cancel_timeout(mxl_acs_rnr_scan_timer_handler, iface, NULL);
+		mxl_acs_6ghz_prepare_rnr_scan_data(iface);
+		acs_init_defaults_candidate_table(iface);
+
+		/* Scan req for 6G for RNR passive chan list*/
+		if (iface->mxl_iface.acs_6ghz_passive_ch_num) {
+			iface->mxl_iface.acs_6g_scan_type = SCAN_6G_RNR_PASSIVE;
+			iface->mxl_iface.acs_6g_scan_status = SCAN_6G_STARTED;
+			if (mxl_acs_request_scan(iface) < 0) {
+				wpa_printf(MSG_ERROR, "6G ACS : CB Scan Request Failed, Completing Scan");
+				goto complete;
+			}
+		}
+		else
+			goto complete;
+	}
+	return;
+complete:
+	iface->mxl_iface.acs_6g_scan_status = SCAN_6G_COMPLETE;
+	mxl_acs_scan_complete(iface);
+}
+
+static int acs_is_subchannel_allowed(struct hostapd_iface *iface, int channel)
+{
+	int j;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct mxl_hostapd_config *mxl_conf = &iface->conf->mxl_conf;
+
+	for (j = 0; j < mode->num_channels; j++) {
+		struct hostapd_channel_data *chan = &mode->channels[j];
+
+		if (chan->chan == channel) {
+			if (chan->flag & HOSTAPD_CHAN_DISABLED)
+				return 0;
+
+			if (iface->conf->acs_exclude_dfs && (chan->flag & HOSTAPD_CHAN_RADAR))
+				return 0;
+
+			if (mxl_conf->acs_chanlist_all_chans &&
+			    mxl_conf->acs_strict_chanlist && !mxl_is_in_chanlist(iface, chan))
+				return 0;
+
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int acs_is_channel_disabled(struct hostapd_iface *iface, int start_freq, int width, int primary_chan, bool check_chanlist)
+{
+	int i, j;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct mxl_hostapd_config *mxl_conf = &iface->conf->mxl_conf;
+
+	for (j = 0; j < mode->num_channels; j++) {
+		struct hostapd_channel_data *chan = &mode->channels[j];
+
+		if (!mxl_conf->acs_chanlist_all_chans &&
+		    check_chanlist && (chan->chan == primary_chan) && !mxl_is_in_chanlist(iface, chan))
+			return 1;
+
+		for (i = 0; i < (width / SINGLE_CHANNEL_WIDTH); i++) {
+			if (chan->freq == start_freq + SINGLE_CHANNEL_WIDTH * i) {
+				if (chan->flag & HOSTAPD_CHAN_DISABLED)
+					return 1;
+
+				if (iface->conf->acs_exclude_dfs && (chan->flag & HOSTAPD_CHAN_RADAR))
+					return 1;
+
+				if (mxl_conf->acs_chanlist_all_chans &&
+				    check_chanlist && !mxl_is_in_chanlist(iface, chan))
+					return 1;
+
+				switch (width) {
+				case 40:
+					/* TODO: check for HT40 flags
+					if (chan->flag & HOSTAPD_CHAN_NO_HT40_MINUS)) return 1;*/
+					break;
+
+				case 80:
+					if (chan->flag & HOSTAPD_CHAN_NO_80MHZ)
+						return 1;
+					break;
+
+				case 160:
+					if (chan->flag & HOSTAPD_CHAN_NO_160MHZ)
+						return 1;
+					break;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int acs_is_radar_affected_channel(struct hostapd_iface *iface, int channel)
+{
+	int j;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+
+	for (j = 0; j < mode->num_channels; j++) {
+		if (mode->channels[j].chan == channel) {
+			if (mode->channels[j].flag & HOSTAPD_CHAN_RADAR)
+				return 1;
+			else
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int acs_is_40_mhz_overlap_chan (channel_pair *candidate)
+{
+	if ((candidate->primary == 1  && candidate->secondary == 5)  ||
+	    (candidate->primary == 5  && candidate->secondary == 1)  ||
+	    (candidate->primary == 7  && candidate->secondary == 11) ||
+	    (candidate->primary == 11 && candidate->secondary == 7))
+		return 0;
+
+	return 1;
+}
+
+void add_channel_pair_candidates(struct hostapd_iface *iface, channel_pair *channel_pairs, u32 nof_pairs, u32 base_freq, struct hostapd_channel_data *chan)
+{
+	int i;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	for (i = 0; i < nof_pairs; i++) {
+		if ((channel_pairs[i].primary == chan->chan) && acs_is_subchannel_allowed(iface, channel_pairs[i].secondary)) {
+			/* Special rule to allow only 2 non-overlapping 40 MHz candidates (1--5, 7--11) in 2.4 GHz,
+			* if special acs_use24overlapped configuration parameter is set to 0 (default) */
+			if ((base_freq < 5000) && (!iface->conf->mxl_conf.acs_use24overlapped) &&
+			    (acs_is_40_mhz_overlap_chan(&channel_pairs[i])))
+				continue;
+
+			if (is_excluded_opclass_chan(iface, channel_pairs[i].primary, 40) ||
+				is_excluded_opclass_chan(iface, channel_pairs[i].secondary, 40)) {
+				continue;
+			}
+
+			if (channel_pairs[i].primary < channel_pairs[i].secondary)
+				candidates[iface->mxl_iface.num_candidates].freq = chan->freq;
+			else
+				candidates[iface->mxl_iface.num_candidates].freq = base_freq + 5 * channel_pairs[i].secondary;
+
+			candidates[iface->mxl_iface.num_candidates].primary = channel_pairs[i].primary;
+			candidates[iface->mxl_iface.num_candidates].secondary = channel_pairs[i].secondary;
+			candidates[iface->mxl_iface.num_candidates].chan = (channel_pairs[i].primary + channel_pairs[i].secondary) >> 1;
+			candidates[iface->mxl_iface.num_candidates].width = 40;
+
+			if ((chan->flag & HOSTAPD_CHAN_RADAR) || acs_is_radar_affected_channel(iface, channel_pairs[i].secondary))
+				candidates[iface->mxl_iface.num_candidates].radar_affected = true;
+
+			wpa_printf(MSG_DEBUG, "ACS: adding candidate %d, freq %d chan %d pri %d sec %d width %d",
+				   iface->mxl_iface.num_candidates,
+				   candidates[iface->mxl_iface.num_candidates].freq,
+				   candidates[iface->mxl_iface.num_candidates].chan,
+				   candidates[iface->mxl_iface.num_candidates].primary,
+				   candidates[iface->mxl_iface.num_candidates].secondary,
+				   candidates[iface->mxl_iface.num_candidates].width);
+
+			iface->mxl_iface.num_candidates++;
+		}
+	}
+}
+
+void add_80_channels(struct hostapd_iface *iface, mxl_acs_chan *channel_pairs, u32 nof_pairs, struct hostapd_channel_data *chan)
+{
+	int i;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	for (i = 0; i < nof_pairs; i++) {
+		if (is_excluded_opclass_chan(iface, channel_pairs[i].primary, 80) ||
+			is_excluded_opclass_chan(iface, channel_pairs[i].secondary, 80)) {
+			continue;
+		}
+
+		if ((channel_pairs[i].primary == chan->chan) &&
+		    !acs_is_channel_disabled(iface, channel_pairs[i].freq, 80, channel_pairs[i].primary,
+					     iface->conf->mxl_conf.acs_strict_chanlist)) {
+			candidates[iface->mxl_iface.num_candidates].freq = channel_pairs[i].freq;
+			candidates[iface->mxl_iface.num_candidates].chan = channel_pairs[i].chan_no;
+			candidates[iface->mxl_iface.num_candidates].primary = channel_pairs[i].primary;
+			candidates[iface->mxl_iface.num_candidates].secondary = channel_pairs[i].secondary;
+			candidates[iface->mxl_iface.num_candidates].width = 80;
+
+			if (acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no - 6) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no - 2) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no + 2) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no + 6))
+				candidates[iface->mxl_iface.num_candidates].radar_affected = true;
+
+			wpa_printf(MSG_DEBUG, "ACS: adding candidate %d, freq %d chan %d pri %d sec %d width %d",
+				   iface->mxl_iface.num_candidates,
+				   candidates[iface->mxl_iface.num_candidates].freq,
+				   candidates[iface->mxl_iface.num_candidates].chan,
+				   candidates[iface->mxl_iface.num_candidates].primary,
+				   candidates[iface->mxl_iface.num_candidates].secondary,
+				   candidates[iface->mxl_iface.num_candidates].width);
+
+			iface->mxl_iface.num_candidates++;
+		}
+	}
+}
+
+void add_160_channels(struct hostapd_iface *iface, mxl_acs_chan *channel_pairs, u32 nof_pairs, struct hostapd_channel_data *chan)
+{
+	int i;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	for (i = 0; i < nof_pairs; i++) {
+		if (is_excluded_opclass_chan(iface, channel_pairs[i].primary, 160) ||
+			is_excluded_opclass_chan(iface, channel_pairs[i].secondary, 160)) {
+			continue;
+		}
+
+		if ((channel_pairs[i].primary == chan->chan) &&
+		    !acs_is_channel_disabled(iface, channel_pairs[i].freq, 160, channel_pairs[i].primary,
+					     iface->conf->mxl_conf.acs_strict_chanlist)) {
+			candidates[iface->mxl_iface.num_candidates].freq = channel_pairs[i].freq;
+			candidates[iface->mxl_iface.num_candidates].chan = channel_pairs[i].chan_no;
+			candidates[iface->mxl_iface.num_candidates].primary = channel_pairs[i].primary;
+			candidates[iface->mxl_iface.num_candidates].secondary = channel_pairs[i].secondary;
+			candidates[iface->mxl_iface.num_candidates].width = 160;
+
+			if (acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no - 14) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no - 10) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no -  6) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no -  2) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no +  2) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no +  6) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no + 10) ||
+			    acs_is_radar_affected_channel(iface, channel_pairs[i].chan_no + 14))
+				candidates[iface->mxl_iface.num_candidates].radar_affected = true;
+
+			wpa_printf(MSG_DEBUG, "ACS: adding candidate %d, freq %d chan %d pri %d sec %d width %d",
+				   iface->mxl_iface.num_candidates,
+				   candidates[iface->mxl_iface.num_candidates].freq,
+				   candidates[iface->mxl_iface.num_candidates].chan,
+				   candidates[iface->mxl_iface.num_candidates].primary,
+				   candidates[iface->mxl_iface.num_candidates].secondary,
+				   candidates[iface->mxl_iface.num_candidates].width);
+
+			iface->mxl_iface.num_candidates++;
+		}
+	}
+}
+
+void mxl_acs_init_candidate_table(struct hostapd_iface *iface)
+{
+	int i;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	memset(candidates, 0, sizeof(iface->mxl_iface.candidates));
+	iface->mxl_iface.num_candidates = 0;
+	iface->mxl_iface.selected_candidate = -1;
+
+	wpa_printf(MSG_DEBUG, "ACS: init candidate table, num_chan = %d", mode->num_channels);
+
+	for (i = 0; i < mode->num_channels; i++) {
+		struct hostapd_channel_data *chan = &mode->channels[i];
+		if (chan->flag & HOSTAPD_CHAN_DISABLED)
+			continue;
+
+		if (iface->conf->mxl_conf.acs_strict_chanlist && !mxl_is_in_chanlist(iface, chan))
+			continue;
+
+		if (iface->conf->acs_exclude_dfs && (chan->flag & HOSTAPD_CHAN_RADAR))
+			continue;
+
+		if (iface->conf->mxl_conf.acs_use24overlapped || (chan->chan == 1) ||
+		    (chan->chan == 6) || (chan->chan == 11) || (chan->freq >= 5000)) {
+			if (chan->flag & HOSTAPD_CHAN_RADAR)
+				candidates[iface->mxl_iface.num_candidates].radar_affected = true;
+
+			candidates[iface->mxl_iface.num_candidates].freq = chan->freq;
+			candidates[iface->mxl_iface.num_candidates].chan = chan->chan;
+			candidates[iface->mxl_iface.num_candidates].primary = chan->chan;
+			candidates[iface->mxl_iface.num_candidates].secondary = 0;
+			candidates[iface->mxl_iface.num_candidates].width = 20;
+
+			wpa_printf(MSG_DEBUG, "ACS: adding candidate %d, freq %d chan %d pri %d sec %d width %d",
+				   iface->mxl_iface.num_candidates,
+				   candidates[iface->mxl_iface.num_candidates].freq,
+				   candidates[iface->mxl_iface.num_candidates].chan,
+				   candidates[iface->mxl_iface.num_candidates].primary,
+				   candidates[iface->mxl_iface.num_candidates].secondary,
+				   candidates[iface->mxl_iface.num_candidates].width);
+
+			iface->mxl_iface.num_candidates++;
+		}
+
+		if (!iface->conf->secondary_channel) {
+			if (!is_6ghz_op_class(iface->conf->op_class))
+				continue;
+
+			if (20 == op_class_to_bandwidth(iface->conf->op_class))
+				continue;
+		}
+
+		if (chan->freq < 5000) { /* 2.4 GHz */
+			add_channel_pair_candidates(iface, g_channel_pairs_40_24G, sizeof(g_channel_pairs_40_24G) / sizeof(channel_pair), 2407, chan);
+		} else if (chan->freq < WAVE_6G_STARTING_FREQ) { /* 5 GHz */
+			add_channel_pair_candidates(iface, g_channel_pairs_40_5G, sizeof(g_channel_pairs_40_5G) / sizeof(channel_pair), 5000, chan);
+
+			if (hostapd_get_oper_chwidth(iface->conf) >= CONF_OPER_CHWIDTH_80MHZ) { /* 80 MHz supported */
+				add_80_channels(iface, g_channels80, sizeof(g_channels80) / sizeof(mxl_acs_chan), chan);
+			}
+			if (hostapd_get_oper_chwidth(iface->conf) == CONF_OPER_CHWIDTH_160MHZ) { /* 160 MHz supported */
+				add_160_channels(iface, g_channels160, sizeof(g_channels160) / sizeof(mxl_acs_chan), chan);
+			}
+		} else { /* 6GHz */
+			add_channel_pair_candidates(iface, g_channel_pairs_40_6G, sizeof(g_channel_pairs_40_6G) / sizeof(channel_pair),
+										WAVE_6G_STARTING_FREQ, chan);
+			if (hostapd_get_oper_chwidth(iface->conf) >= CONF_OPER_CHWIDTH_80MHZ) { /* 80 MHz supported */
+				add_80_channels(iface, g_channels80_6G, sizeof(g_channels80_6G) / sizeof(mxl_acs_chan), chan);
+			}
+			if (hostapd_get_oper_chwidth(iface->conf) == CONF_OPER_CHWIDTH_160MHZ) { /* 160 MHz supported */
+				add_160_channels(iface, g_channels160_6G, sizeof(g_channels160_6G) / sizeof(mxl_acs_chan), chan);
+			}
+		}
+	}
+	/* 80p80 is not supported */
+
+	wpa_printf(MSG_DEBUG, "ACS: init candidate table done");
+
+	return;
+}
+
+int mxl_is_6ghz_opt_freq(struct hostapd_iface *iface, int freq)
+{
+	int count;
+
+	for(count = 0; count < iface->conf->mxl_conf.acs_6g_opt_ch_count ; count++) {
+		if (freq == (hostapd_chan_to_freq(iface->conf->mxl_conf.acs_6g_opt_ch_list[count], iface->conf->op_class)))
+			return 1;
+	}
+	return 0;
+}
+
+int mxl_is_6ghz_rnr_passive_scan_freq(struct hostapd_iface *iface, int freq)
+{
+	int ch;
+
+	for (ch = 0; ch < iface->mxl_iface.acs_6ghz_passive_ch_num; ch++) {
+		if (freq == iface->mxl_iface.acs_6ghz_passive_ch_list[ch])
+			return 1;
+	}
+	return 0;
+}
+
+void mxl_acs_6ghz_prepare_rnr_scan_data(struct hostapd_iface *iface)
+{
+	struct hapd_interfaces *ifaces = iface->interfaces;
+	rnr_scan_ap_info_t *scan_ap_info;
+	u8 passive_ch = 0;
+
+	dl_list_for_each(scan_ap_info, &ifaces->rnr_scan_6g_ap_info, rnr_scan_ap_info_t, list) {
+		if (scan_ap_info->flag & RNR_AOCS_SCAN_PASSIVE_CHANNEL) {
+			if (is_6ghz_psc_frequency(scan_ap_info->freq) || mxl_is_6ghz_opt_freq(iface, scan_ap_info->freq))
+				continue;
+			else
+				iface->mxl_iface.acs_6ghz_passive_ch_list[passive_ch++] = scan_ap_info->freq;
+		}
+		else if (scan_ap_info->flag & RNR_AOCS_SCAN_ACTIVE_CHANNEL) {
+			if (is_6ghz_psc_frequency(scan_ap_info->freq) || mxl_is_6ghz_opt_freq(iface, scan_ap_info->freq))
+				continue;
+			else
+				/* Due to 6G RNR ACTIVE Scan Open issue (Probe Req. not transmitted over air during bootup scan)
+				 * it is decided to do passive scan even for channels that are categorized todo Active scan.
+				 * Hence Populating Passive channel list for Active channels in RNR Report */
+				iface->mxl_iface.acs_6ghz_passive_ch_list[passive_ch++] = scan_ap_info->freq;
+		}
+	}
+	iface->mxl_iface.acs_6ghz_passive_ch_num = passive_ch;
+	wpa_printf(MSG_DEBUG, "6G ACS : RNR Scan - No. of Passive channels discovered %d", iface->mxl_iface.acs_6ghz_passive_ch_num);
+}
+
+char acs_to_exclude_candidate(struct hostapd_iface *iface, u32 i, struct os_reltime *now)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	if (acs_is_channel_disabled(iface, candidates[i].freq, candidates[i].width, candidates[i].primary, true)) {
+		wpa_printf(MSG_DEBUG, "ACS: skip candidate %d, disabled", i);
+		return ACS_EXCLUDE_DISABLED;
+	}
+
+	if (candidates[i].radar_detected) {
+		wpa_printf(MSG_DEBUG, "ACS: skip candidate %d, radar detect", i);
+		return ACS_EXCLUDE_RADAR;
+	}
+
+	if (candidates[i].intolerant40) {
+		wpa_printf(MSG_DEBUG, "ACS: skip candidate %d, intolerant no timeout", i);
+		return ACS_EXCLUDE_INTOLERANT;
+	}
+
+	if (candidates[i].overlap40) {
+		wpa_printf(MSG_DEBUG, "ACS: skip candidate %d, overlap40", i);
+		return ACS_EXCLUDE_OVERLAP40;
+	}
+
+	if (candidates[i].overlap_vht_he) {
+		wpa_printf(MSG_DEBUG, "ACS: skip candidate %d, overlap_vht_he", i);
+		return ACS_EXCLUDE_OVERLAP_VHT_HE;
+	}
+
+	if (candidates[i].cwi_noise[PRI_20] > iface->conf->mxl_conf.acs_noise_threshold) {
+		wpa_printf(MSG_DEBUG, "ACS: skip candidate %d, CWI noise %i > %i", i,
+			   candidates[i].cwi_noise[PRI_20], iface->conf->mxl_conf.acs_noise_threshold);
+		return ACS_EXCLUDE_CWI;
+	}
+
+	wpa_printf(MSG_DEBUG, "ACS: do NOT skip candidate %d", i);
+	return ACS_NO_EXCLUSION;
+}
+
+
+typedef struct {
+	u32 rank;
+	u32 cand_idx;
+	int rank_util_primary;
+	int bw_comp_util;
+	int bw_rank_cand_idx;
+
+	/* For excluded due to Primary utilization param storage */
+	u32 ex_rank;
+	u32 ex_cand_idx;
+	int ex_rank_util_primary;
+} calibration_group;
+
+
+#ifndef MIN
+#define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+#ifndef MAX
+#define MAX(x,y) ((x)>(y)?(x):(y))
+#endif
+
+
+static int get_secondary_offset(int primary, int secondary)
+{
+	if (secondary)
+		return ((secondary > primary) ? 1 : -1);
+	else
+		return 0;
+}
+
+int hostapd_csa_in_progress(struct hostapd_iface *iface);
+int hostapd_dfs_start_channel_switch_cac(struct hostapd_iface *iface);
+
+int mxl_acs_do_switch_channel(struct hostapd_iface *iface, int block_tx)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct csa_settings csa_settings;
+	unsigned int i;
+	int err = 1;
+
+	if (!mode)
+		return -1;
+
+	/* Check if CSA in progress */
+	if (hostapd_csa_in_progress(iface)) {
+		wpa_printf(MSG_DEBUG, "will NOT switch to a new channel - CSA already in progress");
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG, "try switch to a new channel %d, params freq %d sec %d vht_chwidth %d seg0 %d seg1 %d block_tx %d",
+			iface->conf->channel,
+			hostapd_chan_to_freq(iface->conf->channel, is_6ghz_op_class(iface->conf->op_class)),
+			iface->conf->secondary_channel,
+			hostapd_get_oper_chwidth(iface->conf),
+			hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
+			hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
+			block_tx);
+
+	/* Check if active CAC */
+	if (iface->cac_started)
+		return hostapd_setup_interface_complete(iface, 0);
+
+	/* check CAC required */
+	for (i = 0; i < mode->num_channels; i++) {
+		struct hostapd_channel_data *channel;
+
+		channel = &mode->channels[i];
+
+		if (channels_overlap(channel->freq, 20, candidates[iface->mxl_iface.selected_candidate].freq,
+				     candidates[iface->mxl_iface.selected_candidate].width) &&
+		   (channel->flag & HOSTAPD_CHAN_RADAR) &&
+		   ((channel->flag & HOSTAPD_CHAN_DFS_MASK) != HOSTAPD_CHAN_DFS_AVAILABLE)) {
+			iface->freq = channel->freq;
+			iface->conf->acs = 0;
+			hostapd_disable_iface(iface);
+			hostapd_enable_iface(iface);
+			iface->conf->acs = 1;
+			return 0;
+		}
+	}
+
+	wpa_printf(MSG_DEBUG, "will switch to a new channel %d, params freq %d sec %d vht_chwidth %d seg0 %d seg1 %d",
+			iface->conf->channel,
+			hostapd_chan_to_freq(iface->conf->channel, is_6ghz_op_class(iface->conf->op_class)),
+			iface->conf->secondary_channel,
+			hostapd_get_oper_chwidth(iface->conf),
+			hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
+			hostapd_get_oper_centr_freq_seg1_idx(iface->conf));
+
+	/* Setup CSA request */
+	os_memset(&csa_settings, 0, sizeof(csa_settings));
+	csa_settings.cs_count = mxl_hostapd_get_cs_count(iface);
+	csa_settings.block_tx = block_tx;
+
+	if (!iface->conf->ieee80211n) wpa_printf(MSG_ERROR, "interface HT == OFF, please report !!!");
+
+	err = hostapd_set_freq_params(&csa_settings.freq_params,
+						iface->conf->hw_mode,
+						hostapd_chan_to_freq(iface->conf->channel, is_6ghz_op_class(iface->conf->op_class)),
+						iface->conf->channel,
+						iface->conf->enable_edmg,
+						iface->conf->edmg_channel,
+						iface->conf->ieee80211n,
+						iface->conf->ieee80211ac,
+						iface->conf->ieee80211ax,
+						iface->conf->ieee80211be,
+						iface->conf->secondary_channel,
+						hostapd_get_oper_chwidth(iface->conf),
+						hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
+						hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
+						mode ? mode->vht_capab : 0,
+						mode ? &mode->he_capab[IEEE80211_MODE_AP] : NULL,
+						mode ? &mode->eht_capab[IEEE80211_MODE_AP] : NULL);
+
+	if (err) {
+		wpa_printf(MSG_ERROR, "failed to calculate CSA freq params");
+		/* possibly recover actual iface params */
+		hostapd_disable_iface(iface);
+		return -1;
+	}
+
+	for (i = 0; i < iface->num_bss; i++) {
+		err = hostapd_switch_channel(iface->bss[i], &csa_settings);
+		if (err) {
+			wpa_printf(MSG_ERROR, "Unable to switch channel !");
+			return -1;
+		}
+	}
+
+	if (iface->mxl_iface.acs_reenable_iface)
+		hostapd_set_state(iface, HAPD_IFACE_ENABLED);
+
+	return 0;
+}
+
+
+void acs_print_info_header(int level)
+{
+	wpa_printf(level, " #  1y  2y freq  BW    R#   RB# u_p u_bw l_p l_s ls40 ls80  bss  pri aff rdr Ovl int40 c_p c_s cs40 cs80");
+}
+
+void acs_print_cand_no(int level, struct hostapd_iface *iface, int i)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	wpa_printf(level, "%2d %3d %3d %4d %3d %5d %5d %3d %4d %3d %3d %4d %4d %4d %4d %3d %3d %3d %5d %3d %3d %4d %4d",
+				i,
+				candidates[i].primary,
+				candidates[i].secondary,
+				candidates[i].freq,
+				candidates[i].width,
+				candidates[i].rank,
+				candidates[i].bw_comp_rank,
+				candidates[i].rank_util_primary,
+				candidates[i].bw_comp_util,
+				candidates[i].channel_load[PRI_20],
+				candidates[i].channel_load[SEC_20],
+				candidates[i].channel_load[SEC_MAX_40],
+				candidates[i].channel_load[SEC_MAX_80],
+				candidates[i].num_bss,
+				candidates[i].num_bss_pri,
+				candidates[i].radar_affected,
+				candidates[i].radar_detected,
+				candidates[i].overlap40 | candidates[i].overlap_vht_he,
+				candidates[i].intolerant40,
+				candidates[i].cwi_noise[PRI_20],
+				candidates[i].cwi_noise[SEC_20],
+				candidates[i].cwi_noise[SEC_MAX_40],
+				candidates[i].cwi_noise[SEC_MAX_80]);
+}
+
+void acs_print_info_header_file(FILE *fp)
+{
+	fprintf(fp, "\n #  1y  2y freq  BW    R#   RB# u_p u_bw l_p l_s ls40 ls80  bss  pri aff rdr Ovl int40  c_p  c_s cs40 cs80 txp skip\n");
+}
+
+void acs_print_cand_no_file(FILE *fp, struct hostapd_iface *iface, int i)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	fprintf(fp, "%2d %3d %3d %4d %3d %5d %5d %3d %4d %3d %3d %4d %4d %4d %4d %3d %3d %3d %5d %4d %4d %4d %4d %3d %4c\n",
+		i,
+		candidates[i].primary,
+		candidates[i].secondary,
+		candidates[i].freq,
+		candidates[i].width,
+		candidates[i].rank,
+		candidates[i].bw_comp_rank,
+		candidates[i].rank_util_primary,
+		candidates[i].bw_comp_util,
+		candidates[i].channel_load[PRI_20],
+		candidates[i].channel_load[SEC_20],
+		candidates[i].channel_load[SEC_MAX_40],
+		candidates[i].channel_load[SEC_MAX_80],
+		candidates[i].num_bss,
+		candidates[i].num_bss_pri,
+		candidates[i].radar_affected,
+		candidates[i].radar_detected,
+		candidates[i].overlap40 | candidates[i].overlap_vht_he,
+		candidates[i].intolerant40,
+		candidates[i].cwi_noise[PRI_20],
+		candidates[i].cwi_noise[SEC_20],
+		candidates[i].cwi_noise[SEC_MAX_40],
+		candidates[i].cwi_noise[SEC_MAX_80],
+		candidates[i].tx_power,
+		candidates[i].exclude_reason);
+}
+
+void acs_print_info_legend(FILE *fp)
+{
+	fprintf(fp, "Legend:  # = candidate no\n" \
+		    "        1y = primary channel\n" \
+		    "        2y = secondary channel\n" \
+		    "      freq = frequency\n" \
+		    "        BW = bandwidth, channel width\n" \
+		    "        R# = calculated rank (not valid for skipped channels)\n" \
+		    "       RB# = calculated rank for BW comparison\n" \
+		    "       u_p = ACS calculated utilization for Primary channel\n" \
+		    "      u_bw = ACS calculated utilization for BW comparison\n" \
+		    "       l_p = channel load on primary channel\n" \
+		    "       l_s = channel load on secondary channel (valid if width > 20)\n" \
+		    "      ls40 = channel load on secondary 40 MHz part (valid if width > 40)\n" \
+		    "      ls80 = channel load on secondary 80 MHz part (valid if width > 80)\n" \
+		    "       bss = number of APs detected overlapping with channel\n" \
+		    "       pri = number of APs detected overlapping with primary channel\n" \
+		    "       aff = radar affected\n" \
+		    "       rdr = radar detected\n" \
+		    "       Ovl = Does not comply with CoEx standard rules (IEEE 802.11-2016: 11.16.3.2 or 11.40.2)\n" \
+		    "     int40 = intolerant 40MHz\n" \
+		    "       c_p = CWI noise level detected on primary channel\n" \
+		    "       c_s = CWI noise level detected on secondary channel (valid if width > 20)\n" \
+		    "      cs40 = CWI noise level detected on secondary 40 MHz part (valid if width > 40)\n" \
+		    "      cs80 = CWI noise level detected on secondary 80 MHz part (valid if width > 80)\n" \
+		    "       txp = TX power\n"
+		    "      skip = reason, why this channel candidate was excluded from ranking/selection: "
+				  "r = radar, i = intolerant, o = overlap40, v = overlap VHT/HE, c = CWI noise, "
+				  "u = Primary channel utilization <= 20%%, d = disabled\n");
+}
+
+const char *sw_reasons[] = {
+	"initial scan",
+	"radar",
+	"background scan",
+	"periodic update",
+};
+
+
+int acs_set_new_chan_if_ok(struct hostapd_iface *iface, int min_rank_cand_idx, int switch_reason, FILE *fp_hist)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	int actual_width, selected_cand_rank;
+	int bg_scan = iface->conf->mxl_conf.acs_bgscan_interval;
+	bool res = false;
+
+	actual_width       = candidates[min_rank_cand_idx].width;
+
+	/* validate previously selected candidate */
+	if (iface->mxl_iface.selected_candidate >= 0) {
+		if (candidates[iface->mxl_iface.selected_candidate].rank > 0) {
+			selected_cand_rank = candidates[iface->mxl_iface.selected_candidate].rank;
+			wpa_printf(MSG_INFO, "Current rank %d prev_rank %d", candidates[min_rank_cand_idx].rank, selected_cand_rank);
+		}
+
+		if (candidates[iface->mxl_iface.selected_candidate].width != actual_width) {
+			wpa_printf(MSG_WARNING, "invalid previously candidate %d detected, width %d",
+				   iface->mxl_iface.selected_candidate, actual_width);
+			iface->mxl_iface.selected_candidate = -1; /* invalid */
+		}
+	}
+	else {
+		wpa_printf(MSG_DEBUG, "no previously selected candidate, width %d", actual_width);
+		iface->mxl_iface.selected_candidate = -1;
+	}
+
+	/* got previous, now check threshold */
+	if (((iface->mxl_iface.selected_candidate < 0) || /* if previously selected candidate is not known - switch */
+	    (switch_reason == SWR_RADAR) || (switch_reason == SWR_INITIAL) || /* in these cases, switch regardless of threshold */
+	    (candidates[iface->mxl_iface.selected_candidate].rank == -1)) && !bg_scan) { /* If previously selected candidates rank is now invalid, switch regardless of threshold*/
+		wpa_printf(MSG_DEBUG, "ACS going from candidate regardless of threshold %d to %d", iface->mxl_iface.selected_candidate, min_rank_cand_idx);
+		acs_print_info_header(MSG_DEBUG);
+		acs_print_info_header_file(fp_hist);
+		acs_print_cand_no(MSG_DEBUG, iface, min_rank_cand_idx);
+		acs_print_cand_no_file(fp_hist, iface, min_rank_cand_idx);
+		res = true;
+	}
+	else {
+		acs_print_info_header(MSG_DEBUG);
+		acs_print_info_header_file(fp_hist);
+		if (((iface->mxl_iface.selected_candidate != min_rank_cand_idx) && (iface->mxl_iface.selected_candidate >= 0) &&
+		    ((candidates[iface->mxl_iface.selected_candidate].rank * (100 - iface->conf->mxl_conf.acs_switch_thresh) / 100) < candidates[min_rank_cand_idx].rank))) {
+			wpa_printf(MSG_DEBUG, "ACS previous selected candidate rank is better than current candidate");
+			acs_print_cand_no(MSG_DEBUG, iface, iface->mxl_iface.selected_candidate);
+			acs_print_cand_no_file(fp_hist, iface, iface->mxl_iface.selected_candidate);
+			if (!iface->conf->channel) {
+				/* set the previous channel */
+				iface->conf->channel = candidates[iface->mxl_iface.selected_candidate].primary;
+				iface->freq = hostapd_hw_get_freq(iface->bss[0], iface->conf->channel);
+				iface->conf->secondary_channel = get_secondary_offset(candidates[iface->mxl_iface.selected_candidate].primary, candidates[iface->mxl_iface.selected_candidate].secondary);
+				hostapd_set_oper_chwidth(iface->conf, mxl_get_oper_width(candidates[iface->mxl_iface.selected_candidate].width));
+				acs_smart_adjust_center_freq(iface, candidates[iface->mxl_iface.selected_candidate].chan);
+			}
+		}
+		else {
+			wpa_printf(MSG_DEBUG, "ACS going from candidate %d to %d as current candidate rank is better", iface->mxl_iface.selected_candidate, min_rank_cand_idx);
+			acs_print_cand_no(MSG_DEBUG, iface, min_rank_cand_idx);
+			acs_print_cand_no_file(fp_hist, iface, min_rank_cand_idx);
+
+			/* set the new channel */
+			iface->conf->channel = candidates[min_rank_cand_idx].primary;
+			iface->freq = hostapd_hw_get_freq(iface->bss[0], iface->conf->channel);
+			iface->conf->secondary_channel = get_secondary_offset(candidates[min_rank_cand_idx].primary, candidates[min_rank_cand_idx].secondary);
+			iface->mxl_iface.selected_candidate = min_rank_cand_idx;
+			hostapd_set_oper_chwidth(iface->conf, get_oper_width(candidates[min_rank_cand_idx].width));
+			acs_smart_adjust_center_freq(iface, candidates[min_rank_cand_idx].chan);
+			res = true;
+		}
+	}
+
+	return res;
+}
+#ifndef CONFIG_NO_STDOUT_DEBUG
+static const char * acs_penalty_fact_to_str(int penalty_factor)
+{
+	switch (penalty_factor) {
+	case K_CWI:
+		return "Noise floor (CWI)";
+	case K_CL:
+		return "Channel load";
+	case K_TX_POWER:
+		return "Delta from TX power";
+	case K_NUMOFBSS:
+		return "BSSes on candidate";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+static void acs_print_penalty_factors(int *acs_penalty_factors)
+{
+	int i;
+	wpa_printf(MSG_DEBUG, "ACS: Penalty factors:");
+	for (i = 0; i < ACS_NUM_PENALTY_FACTORS; i++) {
+		wpa_printf(MSG_DEBUG, "\t%d: %s penalty factor %d", i, acs_penalty_fact_to_str(i), *acs_penalty_factors);
+		acs_penalty_factors++;
+	}
+}
+#endif /* CONFIG_NO_STDOUT_DEBUG */
+
+static inline int acs_apply_penalty_factor(struct hostapd_iface *iface, enum penalty_factor_e f, int rank)
+{
+	return iface->conf->mxl_conf.acs_penalty_factors[f] * rank;
+}
+
+#define ACS_RANK_FACTOR1 88
+#define ACS_RANK_FACTOR2 75
+#define ACS_RANK_FACTOR3 50
+
+#define ACS_RANK_UTIL_FACTOR_20  10000 /* (100 * 100) */
+#define ACS_RANK_UTIL_FACTOR_40  15000 /* (100 * 100) + 0.5 * (100 * 100) */
+#define ACS_RANK_UTIL_FACTOR_80  22500 /* (100 * 100) + 0.75 * (100 * 100) + 0.5 * (100 * 100) */
+#define ACS_RANK_UTIL_FACTOR_160 31300 /* (100 * 100) + 0.88 * (100 * 100) + 0.75 * (100 * 100) + 0.5 * (100 * 100) */
+
+#define ACS_RANK_UTIL_MIN 20
+#define ACS_RANK_UTIL_MAX 50
+
+static int acs_get_rank_bw_factor(int candidate_bw, enum acs_chan_per_bw_elems_e sec_sb)
+{
+	switch (candidate_bw) {
+	case 40:
+		return ACS_RANK_FACTOR3;
+	case 80:
+		if (SEC_20 == sec_sb)
+			return ACS_RANK_FACTOR2;
+		else
+			return ACS_RANK_FACTOR3;
+	case 160:
+		if (SEC_20 == sec_sb)
+			return ACS_RANK_FACTOR1;
+		else if (SEC_MAX_40 == sec_sb)
+			return ACS_RANK_FACTOR2;
+		else
+			return ACS_RANK_FACTOR3;
+	}
+
+	wpa_printf(MSG_ERROR, "ACS: failed to get rank bw factor for bandwidth %d, secondary subband %d",
+		   candidate_bw, sec_sb);
+
+	return 0;
+}
+
+static bool
+acs_is_chan_in_sec_80 (struct acs_candidate_table *candidate, int chan)
+{
+	if ((candidate->primary < candidate->chan) &&
+	    (chan < candidate->chan))
+		return false;
+
+	if ((candidate->primary > candidate->chan) &&
+	    (chan > candidate->chan))
+		return false;
+
+	return true;
+}
+
+static void acs_update_load_if_needed(struct acs_candidate_table *candidate, int load,
+				      enum acs_chan_per_bw_elems_e sec_sb)
+{
+	if (load > candidate->channel_load[sec_sb])
+		candidate->channel_load[sec_sb] = load;
+}
+
+static void acs_update_cwi_if_needed(struct acs_candidate_table *candidate, int cwi,
+				      enum acs_chan_per_bw_elems_e sec_sb)
+{
+	if ((0 == candidate->cwi_noise[sec_sb]) ||
+	    (cwi > candidate->cwi_noise[sec_sb]))
+		candidate->cwi_noise[sec_sb] = cwi;
+}
+
+static void acs_calculate_rank_utilization (struct acs_candidate_table *candidate, int rank_primary)
+{
+	int bw_factor, utilization;
+
+	switch (candidate->width) {
+	case 20:
+		bw_factor = ACS_RANK_UTIL_FACTOR_20;
+		break;
+	case 40:
+		bw_factor = ACS_RANK_UTIL_FACTOR_40;
+		break;
+	case 80:
+		bw_factor = ACS_RANK_UTIL_FACTOR_80;
+		break;
+	case 160:
+		bw_factor = ACS_RANK_UTIL_FACTOR_160;
+		break;
+	default:
+		wpa_printf(MSG_ERROR, "Unsupported bandwidth %d", candidate->width);
+		return;
+	}
+
+	utilization = 100 - (100 * candidate->bw_comp_rank / bw_factor);
+	if (utilization < 0)
+		utilization = 0;
+
+	candidate->bw_comp_util = utilization;
+
+	if (20 != candidate->width) {
+		utilization = 100 - (100 * rank_primary / ACS_RANK_UTIL_FACTOR_20);
+		if (utilization < 0)
+			utilization = 0;
+	}
+
+	candidate->rank_util_primary = utilization;
+	wpa_printf(MSG_DEBUG, "ACS: Utilization primary: %d, BW comparison utilization: %d",
+		   candidate->rank_util_primary, candidate->bw_comp_util);
+}
+
+/* Return: -1: error; 0: stay on the same channel; 1: set new channel */
+int mxl_acs_recalc_ranks_and_set_chan (struct hostapd_iface *iface, int switch_reason)
+{
+	struct os_reltime now;
+	calibration_group cg[ACS_NUM_GRP_PRIORITIES];
+	int *grp_map;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	FILE *fp      = NULL;
+	FILE *fp_hist = NULL;
+	int i, prio;
+	int res = -1;
+	bool all_candidates_util_below_thresh = true;
+
+	fp = fopen(iface->conf->mxl_conf.acs_smart_info_file, "w");
+	if (!fp) {
+		wpa_printf(MSG_ERROR, "ACS: cannot open info file");
+		goto end;
+	}
+
+	fp_hist = acs_write_file(iface->conf->mxl_conf.acs_history_file, true);
+	if (!fp_hist) {
+		wpa_printf(MSG_ERROR, "ACS: cannot open history file");
+		goto end;
+	}
+
+	memset(&cg, 0, sizeof(cg));
+	for (int i = 0; i < ACS_NUM_GRP_PRIORITIES; i++) {
+		cg[i].rank = cg[i].ex_rank = UINT32_MAX;
+		cg[i].bw_comp_util = -1;
+	}
+
+	grp_map = iface->conf->mxl_conf.acs_policy == ACS_POLICY_REACH ? iface->conf->mxl_conf.acs_grp_prio_reach_map : iface->conf->mxl_conf.acs_grp_prio_tp_map;
+
+	wpa_printf(MSG_DEBUG, "ACS: recalculate candidate table, acs_policy %d, "
+			      "acs_switch_thresh %d, acs_bw_comparison %d, acs_noise_threshold %d"
+			      "acs_grp_priorities_throughput %d-%d-%d-%d, acs_grp_priorities_reach %d-%d-%d-%d",
+			      iface->conf->mxl_conf.acs_policy, iface->conf->mxl_conf.acs_switch_thresh,
+			      iface->conf->mxl_conf.acs_bw_comparison, iface->conf->mxl_conf.acs_noise_threshold,
+			      iface->conf->mxl_conf.acs_grp_priorities_throughput[0],
+			      iface->conf->mxl_conf.acs_grp_priorities_throughput[1], iface->conf->mxl_conf.acs_grp_priorities_throughput[2],
+			      iface->conf->mxl_conf.acs_grp_priorities_throughput[3], iface->conf->mxl_conf.acs_grp_priorities_reach[0],
+			      iface->conf->mxl_conf.acs_grp_priorities_reach[1], iface->conf->mxl_conf.acs_grp_priorities_reach[2],
+			      iface->conf->mxl_conf.acs_grp_priorities_reach[3]);
+#ifndef CONFIG_NO_STDOUT_DEBUG
+	acs_print_penalty_factors(iface->conf->mxl_conf.acs_penalty_factors);
+#endif /* CONFIG_NO_STDOUT_DEBUG */
+
+	acs_print_info_legend(fp);
+	acs_print_info_header_file(fp);
+
+	os_get_reltime(&now);
+
+	for (i = 0; (i < iface->mxl_iface.num_candidates && i < MAX_CANDIDATES); i++) {
+		int cg_idx = CALIB_20;
+		int cwi_rank, chan_load_rank, tx_power_rank, num_bss_rank = 0;
+		int rank_util_primary = 0;
+
+		wpa_printf(MSG_DEBUG, "ACS: recalculate candidate idx %d", i);
+
+		acs_print_info_header(MSG_DEBUG);
+		acs_print_cand_no(MSG_DEBUG, iface, i);
+
+		candidates[i].exclude_reason = acs_to_exclude_candidate(iface, i, &now);
+
+		/* Do not calculate rank for channels to be excluded, special case for
+		 * not in chanlist candidates (ACS_EXCLUDE_DISABLED), for them rank always
+		 * should be calculted, but they should be skipped after rank calculation */
+		if ((candidates[i].exclude_reason == ACS_NO_EXCLUSION) ||
+		    (candidates[i].exclude_reason == ACS_EXCLUDE_DISABLED)) {
+			tx_power_rank = acs_apply_penalty_factor(iface, K_TX_POWER,
+					MIN(100, ((iface->mxl_iface.max_tx_power - candidates[i].tx_power) * 10 / 8)));
+			wpa_printf(MSG_DEBUG, "ACS calc rank for tx power(%d) and max tx power(%d): %d",
+				   candidates[i].tx_power, iface->mxl_iface.max_tx_power, tx_power_rank);
+
+			if (iface->mxl_iface.max_num_bss_pen)
+				num_bss_rank = acs_apply_penalty_factor(iface, K_NUMOFBSS,
+						candidates[i].num_bss_pen * 100 / iface->mxl_iface.max_num_bss_pen);
+			wpa_printf(MSG_DEBUG, "ACS calc rank for num BSSes(%d), pen sum(%d), pen max(%d): %d",
+				   candidates[i].num_bss, candidates[i].num_bss_pen, iface->mxl_iface.max_num_bss_pen, num_bss_rank);
+
+			chan_load_rank = acs_apply_penalty_factor(iface, K_CL, candidates[i].channel_load[PRI_20]);
+			wpa_printf(MSG_DEBUG, "ACS calc primary rank for channel load(%d): %d",
+				   candidates[i].channel_load[PRI_20], chan_load_rank);
+
+			cwi_rank = acs_apply_penalty_factor(iface, K_CWI, acs_get_cwi_penalty(candidates[i].cwi_noise[PRI_20]));
+			wpa_printf(MSG_DEBUG, "ACS calc primary rank for CWI(%d): %d", candidates[i].cwi_noise[PRI_20], cwi_rank);
+
+			candidates[i].rank = cwi_rank + tx_power_rank + num_bss_rank + chan_load_rank;
+			rank_util_primary = chan_load_rank + cwi_rank;
+
+			if (candidates[i].width > 20) {
+				chan_load_rank = acs_apply_penalty_factor(iface, K_CL, candidates[i].channel_load[SEC_20]);
+				wpa_printf(MSG_DEBUG, "ACS calc secondary 20 rank for channel load(%d): %d",
+					   candidates[i].channel_load[SEC_20], chan_load_rank);
+
+				cwi_rank = acs_apply_penalty_factor(iface, K_CWI, acs_get_cwi_penalty(candidates[i].cwi_noise[SEC_20]));
+				wpa_printf(MSG_DEBUG, "ACS calc secondary 20 rank for CWI(%d): %d",
+					   candidates[i].cwi_noise[SEC_20], cwi_rank);
+
+				candidates[i].rank += acs_get_rank_bw_factor(candidates[i].width, SEC_20) * (chan_load_rank + cwi_rank) / 100;
+			}
+
+			if (candidates[i].width > 40) {
+				chan_load_rank = acs_apply_penalty_factor(iface, K_CL, candidates[i].channel_load[SEC_MAX_40]);
+				wpa_printf(MSG_DEBUG, "ACS calc secondary 40 rank for channel load(%d): %d",
+					   candidates[i].channel_load[SEC_MAX_40], chan_load_rank);
+
+				cwi_rank = acs_apply_penalty_factor(iface, K_CWI, acs_get_cwi_penalty(candidates[i].cwi_noise[SEC_MAX_40]));
+				wpa_printf(MSG_DEBUG, "ACS calc secondary 40 rank for CWI(%d): %d",
+					   candidates[i].cwi_noise[SEC_MAX_40], cwi_rank);
+
+				candidates[i].rank += acs_get_rank_bw_factor(candidates[i].width, SEC_MAX_40) * (chan_load_rank + cwi_rank) / 100;
+			}
+
+			if (candidates[i].width > 80) {
+				chan_load_rank = acs_apply_penalty_factor(iface, K_CL, candidates[i].channel_load[SEC_MAX_80]);
+				wpa_printf(MSG_DEBUG, "ACS calc secondary 80 rank for channel load(%d): %d",
+					   candidates[i].channel_load[SEC_MAX_80], chan_load_rank);
+
+				cwi_rank = acs_apply_penalty_factor(iface, K_CWI, acs_get_cwi_penalty(candidates[i].cwi_noise[SEC_MAX_80]));
+				wpa_printf(MSG_DEBUG, "ACS calc secondary 80 rank for CWI(%d): %d",
+					   candidates[i].cwi_noise[SEC_MAX_80], cwi_rank);
+
+				candidates[i].rank += acs_get_rank_bw_factor(candidates[i].width, SEC_MAX_80) * (chan_load_rank + cwi_rank) / 100;
+			}
+
+			candidates[i].rank = iface->conf->mxl_conf.acs_chan_cust_penalty[candidates[i].chan] * candidates[i].rank / 100;
+			candidates[i].bw_comp_rank = candidates[i].rank - tx_power_rank - num_bss_rank;
+			acs_calculate_rank_utilization(&candidates[i], rank_util_primary);
+
+			if (candidates[i].rank_util_primary <= ACS_RANK_UTIL_MIN)
+				candidates[i].exclude_reason = ACS_EXCLUDE_LOW_PRIMARY_UTIL;
+		} else {
+			candidates[i].rank = -1;
+			candidates[i].rank_util_primary = -1;
+			candidates[i].bw_comp_rank = -1;
+			candidates[i].bw_comp_util = -1;
+		}
+
+		wpa_printf(MSG_DEBUG, "ACS: candidate idx %d rank %d, bw_rank %d, primary util %d, util %d",
+			   i, candidates[i].rank, candidates[i].bw_comp_rank, candidates[i].rank_util_primary, candidates[i].bw_comp_util);
+
+		acs_print_cand_no_file(fp, iface, i);
+
+		if (candidates[i].exclude_reason != ACS_NO_EXCLUSION &&
+		    candidates[i].exclude_reason != ACS_EXCLUDE_LOW_PRIMARY_UTIL)
+			continue;
+
+		/* select calibration group */
+		switch (candidates[i].width) {
+		case 20:
+			cg_idx = CALIB_20;
+			break;
+		case 40:
+			cg_idx = CALIB_40;
+			break;
+		case 80:
+			cg_idx = CALIB_80;
+			break;
+		case 160:
+			cg_idx = CALIB_160;
+			break;
+		default:
+			wpa_printf(MSG_ERROR, "Wrong width");
+			assert(0);
+		}
+
+		if (candidates[i].exclude_reason == ACS_EXCLUDE_LOW_PRIMARY_UTIL) {
+			if ((candidates[i].rank_util_primary > cg[cg_idx].ex_rank_util_primary) ||
+			    ((candidates[i].rank_util_primary == cg[cg_idx].ex_rank_util_primary) &&
+			     (candidates[i].rank < cg[cg_idx].ex_rank))) {
+				cg[cg_idx].ex_rank_util_primary = candidates[i].rank_util_primary;
+				cg[cg_idx].ex_rank = candidates[i].rank;
+				cg[cg_idx].ex_cand_idx = i;
+			}
+			continue;
+		}
+
+		all_candidates_util_below_thresh = false;
+		if ((candidates[i].rank < cg[cg_idx].rank) ||
+		    ((candidates[i].rank == cg[cg_idx].rank) &&
+		     (candidates[i].rank_util_primary > cg[cg_idx].rank_util_primary))) {
+			cg[cg_idx].rank_util_primary = candidates[i].rank_util_primary;
+			cg[cg_idx].rank = candidates[i].rank;
+			cg[cg_idx].cand_idx = i;
+		}
+		if (candidates[i].bw_comp_util > cg[cg_idx].bw_comp_util) {
+			cg[cg_idx].bw_comp_util = candidates[i].bw_comp_util;
+			cg[cg_idx].bw_rank_cand_idx = i;
+		}
+
+	}
+
+	if ((!iface->conf->mxl_conf.acs_bg_scan_do_switch && (SWR_BG_SCAN == switch_reason)) ||
+	    iface->mxl_iface.cac_required || !(iface->conf->mxl_conf.acs_init_done)) {
+		goto stay_on_chan;
+	}
+
+	if (!iface->conf->mxl_conf.acs_update_do_switch && (SWR_UPDATE == switch_reason)) {
+		goto stay_on_chan;
+	}
+
+	for (prio = 0; prio < ACS_NUM_GRP_PRIORITIES; prio++) {
+		int rank;
+		int min_rank_cand_idx;
+		int bw_comp_util;
+
+		if (all_candidates_util_below_thresh) {
+			if (UINT32_MAX == cg[grp_map[prio]].ex_rank)
+				continue;
+
+			min_rank_cand_idx = cg[grp_map[prio]].ex_cand_idx;
+			wpa_printf(MSG_WARNING, "ACS: All channels below Primary utilization threshold, selecting idx %d, grp %d",
+				   min_rank_cand_idx, grp_map[prio]);
+			goto set_chan;
+		}
+
+		rank = (int)cg[grp_map[prio]].rank;
+		if (rank == -1)
+			continue;
+
+		min_rank_cand_idx = cg[grp_map[prio]].cand_idx;
+		bw_comp_util = candidates[min_rank_cand_idx].bw_comp_util;
+
+		/* comparison between bandwidth categories - pick up the one with the best rank */
+		if ((iface->conf->mxl_conf.acs_bw_comparison) &&
+		    (iface->conf->mxl_conf.acs_policy == ACS_POLICY_THROUGHPUT) &&
+		    ((prio + 1) < ACS_NUM_GRP_PRIORITIES)) /* for the last category, there will be no rank to compare with */
+		{
+			if ((-1 == bw_comp_util) || (-1 == cg[grp_map[prio + 1]].bw_comp_util))
+				continue;
+
+			if (bw_comp_util < ACS_RANK_UTIL_MAX) {
+				if (bw_comp_util < cg[grp_map[prio + 1]].bw_comp_util / 2) {
+					wpa_printf(MSG_INFO, "ACS: Decreasing BW, from cand idx %d to %d",
+						   min_rank_cand_idx, cg[grp_map[prio + 1]].bw_rank_cand_idx);
+					min_rank_cand_idx = cg[grp_map[prio + 1]].bw_rank_cand_idx;
+				}
+			}
+		}
+
+set_chan:
+		wpa_printf(MSG_DEBUG, "ACS: exit recalculate, selected prio %d min_rank_cand_idx %d", prio, min_rank_cand_idx);
+		res = acs_set_new_chan_if_ok(iface, min_rank_cand_idx, switch_reason, fp_hist);
+		if (res) {
+			int width = mxl_hostapd_get_num_width(hostapd_get_oper_chwidth(iface->conf), candidates[min_rank_cand_idx].secondary);
+			int seg0_idx = hostapd_get_oper_centr_freq_seg0_idx(iface->conf);
+			int seg1_idx = hostapd_get_oper_centr_freq_seg1_idx(iface->conf);
+			wpa_printf(MSG_DEBUG, "ACS: selected a new channel %d, width %d, secondary %d, seg0 %d, seg1 %d, priority group %d candidate idx %d\n",
+				   iface->conf->channel, width, candidates[min_rank_cand_idx].secondary,
+				   seg0_idx, seg1_idx, prio, min_rank_cand_idx);
+			fprintf(fp, "ACS: selected a new channel %d, width %d, secondary %d, seg0 %d, seg1 %d, priority group %d candidate idx %d\n",
+				   iface->conf->channel, width, candidates[min_rank_cand_idx].secondary,
+				   seg0_idx, seg1_idx, prio, min_rank_cand_idx);
+			fprintf(fp_hist, "selected a new channel %d, width %d, secondary %d, seg0 %d, seg1 %d, priority group %d candidate idx %d switch reason %s\n",
+				   iface->conf->channel, width, candidates[min_rank_cand_idx].secondary,
+				   seg0_idx, seg1_idx, prio, min_rank_cand_idx, sw_reasons[switch_reason]);
+			goto end;
+		} else {
+			wpa_printf(MSG_DEBUG, "ACS: a new channel was not set");
+			goto stay_on_chan;
+		}
+	}
+
+	/* if we are still here - use the fallback channel */
+	iface->conf->channel = iface->conf->mxl_conf.acs_fallback_chan.primary;
+	iface->freq = hostapd_hw_get_freq(iface->bss[0], iface->conf->channel);
+	iface->conf->secondary_channel = get_secondary_offset(iface->conf->mxl_conf.acs_fallback_chan.primary, iface->conf->mxl_conf.acs_fallback_chan.secondary);
+	hostapd_set_oper_chwidth(iface->conf, get_oper_width(iface->conf->mxl_conf.acs_fallback_chan.width));
+	acs_smart_adjust_center_freq(iface, 0);
+	wpa_printf(MSG_DEBUG, "ACS: exit recalculate, using fallback channel");
+	fprintf(fp_hist, "ACS: using fallback channel\n");
+	res = true;
+
+	goto end;
+
+stay_on_chan:
+	{
+		int seg0_idx = hostapd_get_oper_centr_freq_seg0_idx(iface->conf);
+		int seg1_idx = hostapd_get_oper_centr_freq_seg1_idx(iface->conf);
+		int width = mxl_hostapd_get_num_width(hostapd_get_oper_chwidth(iface->conf), iface->conf->secondary_channel);
+
+		wpa_printf(MSG_DEBUG, "ACS: stay on the channel %u, width %d, secondary %d, seg0 %d, seg1 %d\n",
+			   iface->conf->channel, width, iface->conf->secondary_channel, seg0_idx, seg1_idx);
+		fprintf(fp, "ACS: stay on the channel %u, width %d, secondary %d, seg0 %d, seg1 %d\n",
+			iface->conf->channel, width, iface->conf->secondary_channel, seg0_idx, seg1_idx);
+		res = 0;
+	}
+
+end:
+	if (fp) fclose(fp);
+	if (fp_hist) fclose(fp_hist);
+	return res;
+}
+
+
+static int bt_find_clean_channel(struct hostapd_iface *iface, int width)
+{
+	struct hostapd_hw_modes *mode;
+	struct hostapd_channel_data *chan;
+	int i, affected_start, aff_width;
+
+	WPA_ASSERT((width == 40) || (width == 20));
+
+	mode = iface->current_mode;
+
+	affected_start = hostapd_chan_to_freq((iface->conf->secondary_channel < 0) ? iface->conf->channel - 4
+											: iface->conf->channel, is_6ghz_op_class(iface->conf->op_class));
+	aff_width = (iface->conf->ieee80211n && iface->conf->secondary_channel) ? 40 : 20;
+
+	wpa_printf(MSG_DEBUG, "BT is searching for %d MHz channels", width);
+	for (i = 0; i < mode->num_channels; i++) {
+		chan = &mode->channels[i];
+
+		/* Skip incompatible chandefs */
+		if (chan->flag & HOSTAPD_CHAN_DISABLED)
+			continue;
+
+		if (width == 40) {
+			struct hostapd_channel_data *sec_chan;
+
+			sec_chan = mxl_hostapd_get_mode_channel(iface, chan->freq + 20);
+			if (!sec_chan)
+				continue;
+			if (sec_chan->flag & HOSTAPD_CHAN_DISABLED)
+				continue;
+		}
+
+		if (channels_overlap(affected_start, aff_width, chan->freq, width))
+			continue;
+
+		iface->freq = chan->freq;
+		iface->conf->channel = chan->chan;
+		iface->conf->secondary_channel = (width == 40) ? 1 : 0;
+
+		wpa_printf(MSG_DEBUG, "Selected ch. #%d", chan->chan);
+		return true;
+	}
+
+	return 0;
+}
+
+static void acs_push_chandef(struct hostapd_iface *iface, mxl_acs_chandef *chan)
+{
+	chan->pri = iface->conf->channel;
+	chan->sec = iface->conf->secondary_channel,
+	chan->chwidth = hostapd_get_oper_chwidth(iface->conf);
+	chan->cent_freq = hostapd_get_oper_centr_freq_seg0_idx(iface->conf);
+	chan->sel_cand = iface->mxl_iface.selected_candidate;
+}
+
+static void acs_pop_chandef(struct hostapd_iface *iface, mxl_acs_chandef *chan)
+{
+	iface->conf->channel = chan->pri;
+	iface->conf->secondary_channel = chan->sec;
+	hostapd_set_oper_chwidth(iface->conf,chan->chwidth);
+	hostapd_set_oper_centr_freq_seg0_idx(iface->conf,chan->cent_freq);
+	iface->mxl_iface.selected_candidate = chan->sel_cand;
+}
+
+void mxl_hostapd_update_channel_data(struct hostapd_iface *iface, const u8 *data, size_t data_len)
+{
+	struct intel_vendor_channel_data *ch_data = (struct intel_vendor_channel_data *) data;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	int j;
+
+	if (!data || (data_len != sizeof(struct intel_vendor_channel_data))) {
+		wpa_printf(MSG_ERROR, "bad channel data event, size %zu expected %zu",
+			   data_len, sizeof(struct intel_vendor_channel_data));
+		return;
+	}
+
+	/* Check if CSA in progress */
+	if (hostapd_csa_in_progress(iface)) {
+		wpa_printf(MSG_DEBUG, "discard update - CSA in progress");
+		return;
+	}
+
+	/* Check if active CAC */
+	if (iface->cac_started) {
+		wpa_printf(MSG_DEBUG, "discard update - CAC in progress");
+		return;
+	}
+
+	if (!iface->conf->mxl_conf.acs_init_done) {
+		if (ch_data->filled_mask & CHDATA_BT_INTERF_MODE) {
+			if ((ch_data->primary == iface->conf->channel) &&
+			    (ch_data->cwi_noise > iface->conf->mxl_conf.acs_noise_threshold)) {
+				mxl_acs_chandef orig_chan;
+				int ret = 0;
+
+				acs_push_chandef(iface, &orig_chan);
+
+				wpa_printf(MSG_DEBUG, "%s called (CAC active: %s, CSA active: %s)",
+					   __func__, iface->cac_started ? "yes" : "no",
+					   hostapd_csa_in_progress(iface) ? "yes" : "no");
+
+				if (iface->conf->ieee80211n && iface->conf->secondary_channel)
+					ret = bt_find_clean_channel(iface, 40);
+
+				if (!ret)
+					ret = bt_find_clean_channel(iface, 20);
+
+				if (!ret) { /* unable to find a clean channel */
+					/* We cannot do anything about it !!! try to work as is */
+					wpa_printf(MSG_WARNING, "BT failed to find a clean channel, continuing on the same channel");
+				}
+				else {
+					/* Perform channel switch/CSA */
+					if (mxl_acs_do_switch_channel(iface, 0) < 0) {
+						wpa_printf(MSG_WARNING, "BT failed to schedule CSA - trying fallback");
+
+						/* back out with channel switch */
+						acs_pop_chandef(iface, &orig_chan);
+
+						hostapd_disable_iface(iface);
+						hostapd_enable_iface(iface);
+					}
+				}
+			}
+			return;
+		}
+		else {
+			if (!(ch_data->filled_mask & CHDATA_SCAN_MODE))
+				return;
+			if (iface->mxl_iface.num_candidates == 0)
+				mxl_acs_init_candidate_table(iface);
+		}
+	}
+
+	if (iface->mxl_iface.acs_update_in_progress) return;
+
+	iface->mxl_iface.acs_update_in_progress = 1;
+
+	wpa_printf(MSG_DEBUG, "ACS: parse channel data event");
+	wpa_printf(MSG_DEBUG, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d 0x%X",
+		   ch_data->channel,
+		   ch_data->BW,
+		   ch_data->primary,
+		   ch_data->secondary,
+		   ch_data->freq,
+		   ch_data->load,
+		   ch_data->busy_time,
+		   ch_data->total_time,
+		   ch_data->calibration,
+		   ch_data->num_bss,
+		   ch_data->dynBW20,
+		   ch_data->dynBW40,
+		   ch_data->dynBW80,
+		   ch_data->dynBW160,
+		   ch_data->tx_power,
+		   ch_data->rssi,
+		   ch_data->snr,
+		   ch_data->cwi_noise,
+		   ch_data->not_80211_rx_evt,
+		   ch_data->ext_sta_rx,
+		   ch_data->filled_mask);
+
+	for (j = 0; j < iface->mxl_iface.num_candidates; j++) {
+		candidates[j].filled_mask = ch_data->filled_mask;
+
+		if (candidates[j].primary == ch_data->primary) {
+			wpa_printf(MSG_DEBUG, "channel data event update candidate %d chan %d BW %d pri %d sec %d freq %d",
+				   j, candidates[j].chan, candidates[j].width, candidates[j].primary, candidates[j].secondary, candidates[j].freq);
+
+			/* overwrite channel data */
+			if (ch_data->filled_mask & CHDATA_LOAD)
+				candidates[j].channel_load[PRI_20] = ch_data->load;
+
+			if (ch_data->filled_mask & CHDATA_CWI_NOISE)
+				candidates[j].cwi_noise[PRI_20] = ch_data->cwi_noise;
+
+			if (ch_data->filled_mask & CHDATA_TX_POWER) {
+				candidates[j].tx_power = ch_data->tx_power;
+				if (ch_data->tx_power > iface->mxl_iface.max_tx_power) iface->mxl_iface.max_tx_power = ch_data->tx_power;
+			}
+
+			if ((20 == candidates[j].width) &&
+			    (ch_data->filled_mask & CHDATA_ALL_BITS) &&
+			    (ch_data->filled_mask & CHDATA_SCAN_MODE))
+				candidates[j].scanned = true;
+		}
+		else if (candidates[j].secondary == ch_data->primary) {
+			if (ch_data->filled_mask & CHDATA_LOAD)
+				candidates[j].channel_load[SEC_20] = ch_data->load;
+
+			if (ch_data->filled_mask & CHDATA_CWI_NOISE)
+				candidates[j].cwi_noise[SEC_20] = ch_data->cwi_noise;
+		} else if ((candidates[j].width > 40) &&
+			   (ch_data->filled_mask & CHDATA_CWI_NOISE) && (ch_data->filled_mask & CHDATA_LOAD) &&
+			   channels_overlap(ch_data->freq, 20, candidates[j].freq, candidates[j].width)) {
+
+			if (candidates[j].width == 80) {
+				acs_update_load_if_needed(&candidates[j], ch_data->load, SEC_MAX_40);
+				acs_update_cwi_if_needed(&candidates[j], ch_data->cwi_noise, SEC_MAX_40);
+			} else if (candidates[j].width == 160) {
+				if (acs_is_chan_in_sec_80(&candidates[j], ch_data->channel)) {
+					acs_update_load_if_needed(&candidates[j], ch_data->load, SEC_MAX_80);
+					acs_update_cwi_if_needed(&candidates[j], ch_data->cwi_noise, SEC_MAX_80);
+				} else {
+					acs_update_load_if_needed(&candidates[j], ch_data->load, SEC_MAX_40);
+					acs_update_cwi_if_needed(&candidates[j], ch_data->cwi_noise, SEC_MAX_40);
+				}
+			}
+		}
+	}
+
+	if (!(ch_data->filled_mask & CHDATA_SCAN_MODE)) {
+		mxl_acs_chandef cur_chan;
+
+		acs_push_chandef(iface, &cur_chan);
+
+		if (mxl_acs_recalc_ranks_and_set_chan(iface, SWR_UPDATE) > 0) {
+			if (mxl_acs_do_switch_channel(iface, 0) < 0) {
+				/* back out with channel switch */
+				acs_pop_chandef(iface, &cur_chan);
+			}
+		}
+	}
+
+	iface->mxl_iface.acs_update_in_progress = 0;
+}
+
+void mxl_acs_update_intolerant_channels(struct hostapd_iface *iface, u8 chan)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	int j, freq;
+
+	freq = hostapd_chan_to_freq(chan, false);
+	for (j = 0; j < iface->mxl_iface.num_candidates; j++) {
+		if (candidates[j].width == 40 && channels_overlap(freq, 20, candidates[j].freq, 40)) {
+			candidates[j].intolerant40++;
+			os_get_reltime(&candidates[j].ts_intolerant40);
+		}
+	}
+}
+
+
+void mxl_acs_update_radar(struct hostapd_iface *iface)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	int i, j;
+
+	if (!iface->conf->mxl_conf.acs_init_done)
+		return;
+
+	for (j = 0; j < iface->mxl_iface.num_candidates; j++) {
+		candidates[j].radar_detected = false;
+
+		for (i = 0; i < mode->num_channels; i++) {
+			struct hostapd_channel_data *chan;
+
+			chan = &iface->current_mode->channels[i];
+
+			if (channels_overlap(candidates[j].freq, candidates[j].width, chan->freq, 20)) {
+				if ((chan->flag & HOSTAPD_CHAN_DFS_MASK) == HOSTAPD_CHAN_DFS_UNAVAILABLE) {
+					candidates[j].radar_detected = true;
+					break;
+				}
+			}
+		}
+	}
+}
+
+void mxl_acs_radar_switch(struct hostapd_iface *iface)
+{
+	int ret;
+	mxl_acs_chandef cur_chan;
+
+	acs_push_chandef(iface, &cur_chan);
+
+	ret = mxl_acs_recalc_ranks_and_set_chan(iface, SWR_RADAR);
+
+	mxl_hostapd_channel_switch_reason_set(iface, HAPD_CHAN_SWITCH_RADAR_DETECTED);
+
+	if ((ret <= 0) || (mxl_acs_do_switch_channel(iface, 1) < 0)) {
+		/* back out with channel switch */
+		acs_pop_chandef(iface, &cur_chan);
+		hostapd_disable_iface(iface);
+		wpa_printf(MSG_ERROR, "Unable to switch channel on radar detection !");
+	}
+
+}
+
+int mxl_hostapd_acs_get_candidates_rank_idx(struct hostapd_iface *iface,
+					    int primary_channel,
+					    int secondary_offset,
+					    int bandwidth)
+{
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+	int i, secondary_channel = 0;
+
+	if (secondary_offset)
+		secondary_channel = primary_channel + (secondary_offset * 4);
+
+	for (i = 0; (i < iface->mxl_iface.num_candidates && i < MAX_CANDIDATES); i++) {
+		if ((candidates[i].primary   == primary_channel)   &&
+		    (candidates[i].secondary == secondary_channel) &&
+		    (candidates[i].width     == bandwidth))
+		    return i;
+	}
+
+	wpa_printf(MSG_ERROR, "ACS candidate primary %d, secondary %d, bandwidth %d does not exist",
+		   primary_channel, secondary_channel, bandwidth);
+	return -1;
+}
+
+/* Must pass 2 adjacent bandwidths, return true if lower BW rank is better */
+static bool hostapd_acs_compare_bw_utilization (int util_high_bw, int util_low_bw)
+{
+	if (util_high_bw < ACS_RANK_UTIL_MAX) {
+		if (util_high_bw < util_low_bw / 2) {
+			return true;
+		}
+	}
+
+	return false;
+}
+
+/* Returns true if first rank is better than second rank, false otherwise and on errors */
+bool mxl_hostapd_acs_compare_ranks(struct hostapd_iface *iface, int rank1_idx, int rank2_idx)
+{
+	struct acs_candidate_table *cand1, *cand2;
+
+	if ((-1 == rank1_idx) || (-1 == rank2_idx))
+		return false;
+
+	cand1 = &iface->mxl_iface.candidates[rank1_idx];
+	cand2 = &iface->mxl_iface.candidates[rank2_idx];
+
+	if (cand1->width == cand2->width) {
+		return cand1->rank < cand2->rank;
+	}
+	else if (cand1->width > cand2->width) {
+		if ((cand2->width * 2) != cand1->width)
+			return false;
+
+		if (hostapd_acs_compare_bw_utilization(cand1->bw_comp_util, cand2->bw_comp_util))
+			return false;
+
+		return true;
+	}
+	else { /* cand1->width < cand2->width */
+		if ((cand1->width * 2) != cand2->width)
+			return false;
+
+		return hostapd_acs_compare_bw_utilization(cand2->bw_comp_util, cand1->bw_comp_util);
+	}
+}
+
+enum acs_failsafe_bw
+{
+	FAILSAFE_20,
+	FAILSAFE_40,
+	FAILSAFE_80,
+	FAILSAFE_160,
+
+	FAILSAFE_NUM_BW,
+};
+struct acs_failsafe_table
+{
+	int index_rank[FAILSAFE_NUM_BW];
+	int index_bw_util[FAILSAFE_NUM_BW];
+};
+
+static bool
+acs_candidate_dfs_available(struct hostapd_iface *iface,
+			    struct acs_candidate_table *candidate)
+{
+	int i;
+	struct hostapd_channel_data *channel;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+
+	for (i = 0; i < mode->num_channels; i++) {
+		channel = &mode->channels[i];
+
+		if (channels_overlap(channel->freq, 20, candidate->freq, candidate->width)) {
+			if ((channel->flag & HOSTAPD_CHAN_RADAR) &&
+			    ((channel->flag & HOSTAPD_CHAN_DFS_MASK) != HOSTAPD_CHAN_DFS_AVAILABLE))
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static bool
+acs_candidate_dfs_usable(struct hostapd_iface *iface,
+			 struct acs_candidate_table *candidate)
+{
+	int i;
+	struct hostapd_channel_data *channel;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+
+	for (i = 0; i < mode->num_channels; i++) {
+		channel = &mode->channels[i];
+
+		if (channels_overlap(channel->freq, 20, candidate->freq, candidate->width)) {
+			if ((channel->flag & HOSTAPD_CHAN_RADAR) &&
+			    (!(channel->flag & HOSTAPD_CHAN_DFS_USABLE))) {
+				return false;
+			}
+		}
+	}
+
+	return true;
+}
+
+static void
+acs_get_failsafe_indexes_per_bw(struct hostapd_iface *iface,
+				struct acs_failsafe_table *table, bool skip_usable)
+{
+	int i;
+	struct acs_candidate_table *candidate = iface->mxl_iface.candidates;
+	int best20 = INT_MAX, best40 = INT_MAX, best80 = INT_MAX, best160 = INT_MAX;
+	int best20_util = 0, best40_util = 0, best80_util = 0, best160_util = 0;
+
+	for (i = FAILSAFE_20; i < FAILSAFE_NUM_BW; i++) {
+		table->index_rank[i] = -1;
+		table->index_bw_util[i] = -1;
+	}
+
+	for (i = 0; (i < iface->mxl_iface.num_candidates && i < MAX_CANDIDATES); i++) {
+		if (candidate[i].rank == -1)
+			continue;
+
+		/* Skipping the channels which are restricted or not in chan_list */
+		if (candidate[i].exclude_reason == ACS_EXCLUDE_DISABLED)
+			continue;
+
+		if (!acs_candidate_dfs_available(iface, &candidate[i])) {
+			if (!skip_usable) {
+				/* Include USABLE channels too. */
+				if (!acs_candidate_dfs_usable(iface, &candidate[i])) {
+					continue;
+				}
+			} else {
+				continue;
+			}
+		}
+
+		switch (candidate[i].width) {
+		case 20:
+			if (candidate[i].rank < best20) {
+				best20 = candidate[i].rank;
+				table->index_rank[FAILSAFE_20] = i;
+			}
+			if (candidate[i].bw_comp_util > best20_util) {
+				best20_util = candidate[i].bw_comp_util;
+				table->index_bw_util[FAILSAFE_20] = i;
+			}
+			break;
+		case 40:
+			if (candidate[i].rank < best40) {
+				best40 = candidate[i].rank;
+				table->index_rank[FAILSAFE_40] = i;
+			}
+			if (candidate[i].bw_comp_util > best40_util) {
+				best40_util = candidate[i].bw_comp_util;
+				table->index_bw_util[FAILSAFE_40] = i;
+			}
+			break;
+		case 80:
+			if (candidate[i].rank < best80) {
+				best80 = candidate[i].rank;
+				table->index_rank[FAILSAFE_80] = i;
+			}
+			if (candidate[i].bw_comp_util > best80_util) {
+				best80_util = candidate[i].bw_comp_util;
+				table->index_bw_util[FAILSAFE_80] = i;
+			}
+			break;
+		case 160:
+			if (candidate[i].rank < best160) {
+				best160 = candidate[i].rank;
+				table->index_rank[FAILSAFE_160] = i;
+			}
+			if (candidate[i].bw_comp_util > best160_util) {
+				best160_util = candidate[i].bw_comp_util;
+				table->index_bw_util[FAILSAFE_160] = i;
+			}
+			break;
+		default:
+			continue;
+		}
+	}
+}
+
+struct acs_candidate_table *
+mxl_acs_get_failsafe_channel(struct hostapd_iface *iface, bool skip_usable)
+{
+	int i;
+	int best_rank_idx = -1;
+	struct acs_failsafe_table table = {0};
+	struct acs_candidate_table *candidate = iface->mxl_iface.candidates;
+	int current_bw_mhz;
+
+	if (iface->mxl_iface.num_candidates == 0) {
+		wpa_printf(MSG_DEBUG, "Dynamic failsafe channel: ACS candidates not initialized");
+		return NULL;
+	}
+
+	if (!acs_are_all_available_chans_scanned(iface)) {
+		wpa_printf(MSG_DEBUG, "Dynamic failsafe channel: Not all available channels scanned");
+		return NULL;
+	}
+
+	acs_get_failsafe_indexes_per_bw(iface, &table, skip_usable);
+
+	current_bw_mhz = mxl_hostapd_get_num_width(hostapd_get_oper_chwidth(iface->conf), iface->conf->secondary_channel);
+
+	for (i = FAILSAFE_160; i >= FAILSAFE_20; i--) {
+		if ((-1 != table.index_rank[i]) &&
+		    (candidate[table.index_rank[i]].width <= current_bw_mhz)) {
+			best_rank_idx = table.index_rank[i];
+			break;
+		}
+	}
+
+	/* BW comparison */
+	if (iface->conf->mxl_conf.acs_bw_comparison) {
+		for (i = FAILSAFE_160; i > FAILSAFE_20; i--) {
+			if ((-1 == table.index_bw_util[i]) || (-1 == table.index_bw_util[i - 1])) {
+				continue;
+			}
+
+			if (hostapd_acs_compare_bw_utilization(candidate[table.index_bw_util[i]].bw_comp_util,
+							       candidate[table.index_bw_util[i - 1]].bw_comp_util))
+				best_rank_idx = table.index_bw_util[i - 1];
+
+			break;
+		}
+	}
+
+	if (-1 == best_rank_idx) {
+		wpa_printf(MSG_ERROR, "Selecting Dynamic failsafe channel failed: No DFS AVAILABLE channels available?");
+		return NULL;
+	}
+
+	return &candidate[best_rank_idx];
+}
+
+void mxl_acs_set_bg_scan_callback(struct hostapd_iface *iface)
+{
+	if (iface->conf->mxl_conf.acs_init_done)
+		iface->scan_cb = mxl_acs_bg_scan_complete;
+}
+
+bool mxl_acs_should_skip_freq(struct hostapd_iface *iface, struct hostapd_channel_data *chan)
+{
+	struct mxl_hostapd_config *mxl_conf = &iface->conf->mxl_conf;
+
+	if (mxl_conf->acs_strict_chanlist &&
+	    mxl_conf->acs_chanlist_all_chans &&
+	    !mxl_is_in_chanlist(iface, chan))
+		return true;
+
+	if (is_6ghz_op_class(iface->conf->op_class))
+	{
+		switch (iface->mxl_iface.acs_6g_scan_type) {
+			case SCAN_6G_PSC_OPT:
+				/* 6G PSC or OPT list */
+				if (!(is_6ghz_psc_frequency(chan->freq) || mxl_is_6ghz_opt_freq(iface, chan->freq)))
+					return true;
+				break;
+
+			case SCAN_6G_RNR_PASSIVE:
+				/* 6G RNR PASSIVE - List of channels discovered through RNR IE for passive scan */
+				/* Reset the flag otherwise Scan resuts of PSC and PSC optional
+				 * channels are flushed by kernel during fresh scan result.
+				 * we need old scan results of PSC and PSC optional along with
+				 * new scan results to show AOCS history table */
+				if (!mxl_is_6ghz_rnr_passive_scan_freq(iface, chan->freq))
+					return true;
+				break;
+
+			case SCAN_6G_FULL_BAND:
+				/* 6G All channels except PSC and OPT */
+				/* Reset the flag otherwise Scan resuts of PSC and PSC optional
+				 * channels are flushed by kernel during fresh scan result.
+				 * we need old scan results of PSC and PSC optional along with
+				 * new scan results to show AOCS history table */
+				if (is_6ghz_psc_frequency(chan->freq) || mxl_is_6ghz_opt_freq(iface, chan->freq))
+					return true;
+				break;
+
+			default:
+				wpa_printf(MSG_INFO, "6G ACS : Invalid scan type");
+		}
+	}
+	return false;
+}
+
+void mxl_acs_cleanup(struct hostapd_iface *iface)
+{
+	if (is_6ghz_op_class(iface->conf->op_class)) {
+		eloop_cancel_timeout(mxl_acs_rnr_scan_timer_handler, iface, NULL);
+	}
+}
+
+bool mxl_acs_is_smart(struct hostapd_iface *iface)
+{
+	return (iface->conf->mxl_conf.acs_algo == ACS_ALGO_SMART);
+}
+
+void mxl_smart_acs_scan_complete(struct hostapd_iface *iface)
+{
+	int err;
+	struct wpa_scan_results *scan_res = NULL;
+
+	wpa_printf(MSG_DEBUG, "ACS: mxl_acs_scan_complete for op_class : %d", iface->conf->op_class);
+	iface->mxl_iface.in_scan = 0;
+
+	iface->scan_cb = NULL;
+
+	if (!mxl_acs_is_smart(iface)) {
+		wpa_printf(MSG_ERROR, "ACS: Called mxl_acs_scan_complete, but Smart ACS not enabled (this is a bug!)");
+		goto fail;
+	}
+
+	wpa_printf(MSG_DEBUG, "ACS: Using Smart ACS based algorithm (acs_num_scans=%d)",
+			iface->conf->acs_num_scans);
+
+	if (is_6ghz_op_class(iface->conf->op_class)) {
+		if (iface->mxl_iface.acs_6g_scan_type == SCAN_6G_FULL_BAND ||
+			iface->mxl_iface.acs_6g_scan_type == SCAN_6G_RNR_PASSIVE)
+			iface->mxl_iface.acs_6g_scan_status = SCAN_6G_COMPLETE;
+
+		if (iface->mxl_iface.acs_6g_scan_status != SCAN_6G_COMPLETE) {
+			iface->mxl_iface.acs_6g_scan_status = SCAN_6G_DONE;
+			mxl_acs_update_scan_states(iface);
+			return;
+		}
+	}
+	scan_res = hostapd_driver_get_scan_results(iface->bss[0]);
+	if (scan_res == NULL) {
+		wpa_printf(MSG_ERROR, "ACS: Failed to get BSS data");
+		goto fail;
+	}
+
+	/* Change the scan callback function for BG scan results */
+	iface->scan_cb = mxl_acs_bg_scan_complete;
+
+	if (++iface->acs_num_completed_scans < iface->conf->acs_num_scans) {
+		err = mxl_acs_request_scan(iface);
+		if (err) {
+			wpa_printf(MSG_ERROR, "ACS: Failed to request scan");
+			goto fail;
+		}
+
+		wpa_scan_results_free(scan_res);
+		return;
+	}
+
+	mxl_acs_smart_process_bsses(iface, scan_res);
+
+	/* After 2.4 and 5 RNR Processing call 6G ACS Scan Request with RNR Data */
+	if (!(is_6ghz_op_class(iface->conf->op_class))) {
+		int count;
+		for (count = 0; count < iface->interfaces->count; count++) {
+			if (is_6ghz_op_class(iface->interfaces->iface[count]->conf->op_class))	{
+				/* Check if 6GHz is Really waiting for lower bands for RNR data to receive */
+				if (iface->interfaces->iface[count]->mxl_iface.acs_6g_scan_type == SCAN_6G_RNR_PASSIVE &&
+					iface->interfaces->iface[count]->mxl_iface.acs_6g_scan_status == SCAN_6G_WAITING) {
+					mxl_acs_rnr_scan_cb(iface->interfaces->iface[count]);
+				}
+			}
+		}
+	}
+
+	/* 6G ACS Restore Scan States after Scan completion */
+	if (is_6ghz_op_class(iface->conf->op_class)) {
+		mxl_acs_restore_6g_scan_states(iface);
+	}
+
+	wpa_scan_results_free(scan_res);
+	return;
+fail:
+	wpa_scan_results_free(scan_res);
+	hostapd_acs_completed(iface, 1);
+	mxl_acs_fail(iface);
+}
+
+int mxl_hostapd_acs_completed(struct hostapd_iface *iface, int err, int set_channel)
+{
+	int ret = -1;
+	int dfs_channel = 0;
+	struct hostapd_channel_data* chan;
+	int freq;
+
+	if (err)
+		goto out;
+
+	if (iface->conf->channel)
+		iface->freq = hostapd_hw_get_freq(iface->bss[0], iface->conf->channel);
+
+	switch (mxl_hostapd_check_chans(iface)) {
+	case HOSTAPD_CHAN_VALID:
+		freq = hostapd_hw_get_freq(iface->bss[0], iface->conf->channel);
+		chan = mxl_hostapd_hw_get_channel_data(iface, freq);
+		if (chan && (chan->flag & HOSTAPD_CHAN_RADAR))
+			dfs_channel = 1;
+
+		if (!iface->conf->mxl_conf.acs_scan_mode) {
+			wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO,
+					ACS_EVENT_COMPLETED "freq=%d channel=%d"
+					" OperatingChannelBandwidt=%d ExtensionChannel=%d cf1=%d cf2=%d"
+					" reason=%s dfs_chan=%d",
+					freq, iface->conf->channel,
+					mxl_hostapd_get_num_width(hostapd_get_oper_chwidth(iface->conf),
+							      iface->conf->secondary_channel),
+					iface->conf->secondary_channel,
+					hostapd_chan_to_freq(hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
+							     is_6ghz_op_class(iface->conf->op_class)),
+					hostapd_chan_to_freq(hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
+							     is_6ghz_op_class(iface->conf->op_class)),
+					mxl_hostapd_channel_switch_text(HAPD_CHAN_SWITCH_OTHER),
+					dfs_channel);
+		} else {
+			hostapd_set_state(iface, HAPD_IFACE_ACS_DONE);
+			wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, ACS_EVENT_COMPLETED "SCAN");
+		}
+		break;
+	case HOSTAPD_CHAN_ACS:
+		wpa_printf(MSG_ERROR, "ACS error - reported complete, but no result available");
+		wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, ACS_EVENT_FAILED);
+		mxl_hostapd_notify_bad_chans(iface);
+		goto out;
+	case HOSTAPD_CHAN_INVALID:
+	default:
+		wpa_printf(MSG_ERROR, "ACS picked unusable channels");
+		wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, ACS_EVENT_FAILED);
+		mxl_hostapd_notify_bad_chans(iface);
+		goto out;
+	}
+
+	/* After scan and ACS don't set the channel */
+	if (iface->conf->mxl_conf.acs_scan_mode) {
+		iface->conf->mxl_conf.acs_scan_mode = 0;
+		return 0;
+	}
+
+	if (!set_channel) {
+		hostapd_set_state(iface, HAPD_IFACE_ENABLED);
+		return 0;
+	}
+
+	ret = hostapd_check_ht_capab(iface);
+	if (ret < 0)
+		goto out;
+	if (ret == 1) {
+		wpa_printf(MSG_DEBUG, "Interface initialization will be completed in a callback");
+		return 0;
+	}
+
+	ret = 0;
+out:
+	/* In case ACS was started via ctrl iface when intefaces were UP */
+	if (iface->mxl_iface.acs_reenable_iface) {
+		if (ret < 0) {
+			wpa_printf(MSG_ERROR, "hostapd_check_ht_capab error %d", ret);
+			return ret;
+		}
+
+		ret = mxl_acs_do_switch_channel(iface, 0);
+		iface->mxl_iface.acs_reenable_iface = 0;
+		return ret;
+	}
+
+	return hostapd_setup_interface_complete(iface, ret);
+}
+
+int mxl_acs_init(struct hostapd_iface *iface)
+{
+	if (is_6ghz_op_class(iface->conf->op_class))
+		if (20 == op_class_to_bandwidth(iface->conf->op_class))
+			iface->conf->secondary_channel = 0;
+
+	if (!iface->conf->mxl_conf.acs_init_done)
+		mxl_acs_init_candidate_table(iface);
+
+	if (is_6ghz_op_class(iface->conf->op_class)) {
+		mxl_acs_restore_6g_scan_states(iface);
+		mxl_acs_update_scan_states(iface);
+	}
+
+	if (mxl_acs_request_scan(iface) < 0) {
+		if (is_6ghz_op_class(iface->conf->op_class)) {
+			mxl_acs_restore_6g_scan_states(iface);
+		}
+		return -1;
+	}
+	return 0;
+}
+
+int mxl_acs_start(struct hostapd_iface *iface)
+{
+	if (acs_init(iface) == HOSTAPD_CHAN_ACS)
+		return 0;
+
+	return -1;
+}
+
+void mxl_event_scan_results(struct hostapd_data *hapd, union wpa_event_data *data)
+{
+	if (!hapd->iface->conf->mxl_conf.acs_init_done)
+		mxl_acs_recalc_ranks_and_set_chan(hapd->iface, SWR_BG_SCAN);
+}
+
+
+void mxl_acs_init_defaults(struct hostapd_iface *iface)
+{
+	int i;
+	struct acs_candidate_table *candidates = iface->mxl_iface.candidates;
+
+	for (i = 0; (i < iface->mxl_iface.num_candidates && i < MAX_CANDIDATES); i++) {
+		/* PRI_20 and SEC_20 are overwritten, so no need to initialize */
+		candidates[i].channel_load[SEC_MAX_40] = 0;
+		candidates[i].channel_load[SEC_MAX_80] = 0;
+		candidates[i].cwi_noise[SEC_MAX_40] = 0;
+		candidates[i].cwi_noise[SEC_MAX_80] = 0;
+	}
+}
+
+int mxl_hostapd_drv_abort_scan(struct hostapd_data *hapd)
+{
+	if (hapd->driver && hapd->driver->abort_scan)
+		return hapd->driver->abort_scan(hapd->drv_priv, 0);
+	return -1;
+}
+
+
+int mxl_hostapd_check_and_abort_scan(struct hostapd_iface *iface)
+{
+	if (nl80211_scan_running(iface->bss[0]->drv_priv)) {
+		wpa_printf(MSG_DEBUG, "ACS: SCAN is running");
+		/*
+		 * When new internal scan request is triggered while current scan is running,
+		 * to avoid race condition we are aborting a current scan.
+		*/
+		if (mxl_hostapd_drv_abort_scan(iface->bss[0]) < 0) {
+			wpa_printf(MSG_ERROR, "ACS: Failed to request abort for running scan");
+			iface->mxl_iface.in_scan = 0;
+			acs_cleanup(iface);
+			return -1;
+		}
+		wpa_printf(MSG_DEBUG, "ACS: Aborted a running scan, new scan will be triggered soon");
+		iface->mxl_iface.retrigger_acs = 1;
+		return 0;
+	}
+	return 1;
+}
+
+int mxl_hostapd_change_country(struct hostapd_iface *iface, struct channel_list_changed *info)
+{
+#ifdef CONFIG_ACS
+	if (mxl_acs_is_smart(iface) && iface->conf->mxl_conf.acs_init_done) {
+		wpa_printf(MSG_INFO, "Regdom change: will reset candidates and re-trigger ACS");
+		iface->conf->mxl_conf.acs_init_done = 0;
+		iface->conf->channel = 0;
+
+		iface->conf->country[0] = info->alpha2[0];
+		iface->conf->country[1] = info->alpha2[1];
+
+		iface->whm_if_fail = false;
+		if (hostapd_disable_iface(iface) < 0)
+			return -1;
+
+		if (hostapd_enable_iface(iface) < 0)
+			return -1;
+		return 0;
+	}
+#endif
+	return 0;
+}
+
+int mxl_acs_check_bgscan(struct hostapd_iface *iface)
+{
+	iface->conf->channel = 0;
+	iface->conf->secondary_channel = 1;
+
+	if ((iface->state == HAPD_IFACE_DFS)) {
+		return -1;
+	}
+
+	if ((iface->state != HAPD_IFACE_ENABLED) && (iface->state != HAPD_IFACE_ACS_DONE)) {
+		return -1;
+	}
+
+	if (is_6ghz_op_class(iface->conf->op_class))
+		iface->conf->op_class = 132;
+	else {
+		mxl_hostapd_update_user_conf_cw(iface);
+		iface->conf->op_class = 0;
+	}
+
+	if (iface->state == HAPD_IFACE_ENABLED)
+		iface->mxl_iface.acs_reenable_iface = 1;
+
+	iface->conf->mxl_conf.acs_init_done = 0;
+
+	return mxl_acs_start(iface);
+}
+
+void mxl_acs_bgscan_timer_cb(void *eloop_data, void *user_ctx)
+{
+	struct hostapd_data *hapd = (struct hostapd_data *) eloop_data;
+	int ret;
+	u16 interval = hapd->iface->conf->mxl_conf.acs_bgscan_interval;
+	interval *= 60;
+
+	/* Set values to initiate a bg scan */
+	hapd->iface->mxl_iface.dfs_bg_cac = true;
+
+	wpa_printf(MSG_DEBUG, "Acs_bgscan Interval Expired, Interval secs %d", interval);
+	if (interval) {
+		ret = mxl_acs_check_bgscan(hapd->iface);
+		if (ret == 0) {
+			wpa_printf(MSG_DEBUG, "ACS Triggered acs_bgscan");
+			eloop_register_timeout(interval, 0, mxl_acs_bgscan_timer_cb,
+					hapd, NULL);
+		}
+		else {
+			wpa_printf(MSG_ERROR, "ACS Failed to trigger scan acs_bgscan");
+		}
+	}
+}
+
+void mxl_acs_set_bgscan_int(struct hostapd_data *hapd)
+{
+	struct mxl_hostapd_config *mxl_conf = &hapd->iconf->mxl_conf;
+	int interval = mxl_conf->acs_bgscan_interval;
+	interval *= 60;
+
+	if (interval != 0) {
+		if (!eloop_is_timeout_registered(mxl_acs_bgscan_timer_cb, hapd, NULL)) {
+			hapd->iface->mxl_iface.dfs_bg_cac = true;
+			eloop_register_timeout(interval, 0, mxl_acs_bgscan_timer_cb,
+					hapd, NULL);
+		}
+	}
+}
diff --git a/src/ap/mxl_acs.h b/src/ap/mxl_acs.h
new file mode 100644
index 000000000..cbb5b62aa
--- /dev/null
+++ b/src/ap/mxl_acs.h
@@ -0,0 +1,179 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+         Copyright 2016 - 2020 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+
+#ifndef MXL_ACS_H
+#define MXL_ACS_H
+
+#include "utils/includes.h"
+#include "../drivers/driver.h"
+struct hostapd_iface;
+
+/* 6GHz channel candidates: 59 20MHz, (29*2) 40MHz, (14*4) 80MHz, (7*8) 160MHz */
+#define NUM_20MHZ_IN_40MHZ		2
+#define NUM_20MHZ_IN_80MHZ		4
+#define NUM_20MHZ_IN_160MHZ		8
+
+#define NUM_CHAN_PAIRS_40_24G	18
+#define NUM_CHAN_PAIRS_40_5G	24
+#define NUM_CHAN_PAIRS_80		24
+#define NUM_CHAN_PAIRS_160		16
+
+#define NUM_CHANS_20_6G			(59)
+#define NUM_CHAN_PAIRS_40_6G	((NUM_CHANS_20_6G >> 1) * NUM_20MHZ_IN_40MHZ)
+#define NUM_CHAN_PAIRS_80_6G	((NUM_CHAN_PAIRS_40_6G >> 1) * NUM_20MHZ_IN_80MHZ)
+#define NUM_CHAN_PAIRS_160_6G	((NUM_CHAN_PAIRS_80_6G >> 1) * NUM_20MHZ_IN_160MHZ)
+#define MAX_CANDIDATES			(NUM_CHANS_20_6G + NUM_CHAN_PAIRS_40_6G + NUM_CHAN_PAIRS_80_6G + NUM_CHAN_PAIRS_160_6G)
+
+#define ACS_EXCLUDE_RADAR				'r'
+#define ACS_EXCLUDE_INTOLERANT			'i'
+#define ACS_EXCLUDE_OVERLAP40			'o'
+#define ACS_EXCLUDE_OVERLAP_VHT_HE		'v'
+#define ACS_EXCLUDE_PRI_OVERLAP40		'p'
+#define ACS_EXCLUDE_CWI					'c'
+#define ACS_EXCLUDE_DISABLED			'd'
+#define ACS_EXCLUDE_LOW_PRIMARY_UTIL	'u'
+#define ACS_NO_EXCLUSION				' '
+
+#define CHDATA_NOISE_FLOOR		1
+#define CHDATA_BUSY_TIME		2
+#define CHDATA_TOTAL_TIME		4
+#define CHDATA_CALIB			8
+#define CHDATA_NUM_BSS			0x0010
+#define CHDATA_DYNBW			0x0020
+#define CHDATA_RSSI				0x0040
+#define CHDATA_SNR				0x0080
+#define CHDATA_CWI_NOISE		0x0100
+#define CHDATA_NOT_80211_EVT	0x0200
+#define CHDATA_LOW_RSSI			0x0400
+#define CHDATA_TX_POWER			0x0800
+#define CHDATA_LOAD				0x1000
+#define CHDATA_BT_INTERF_MODE	0x400000
+#define CHDATA_SCAN_MODE		0x800000
+#define CHDATA_ALL_BITS			0x0FFFFF
+
+/* Used for channel load and CWI noise */
+enum acs_chan_per_bw_elems_e {
+	PRI_20,
+	SEC_20,
+	SEC_MAX_40,
+	SEC_MAX_80,
+	ACS_NUM_BW_ELEMS,
+};
+
+typedef struct {
+	u32 primary;
+	u32 secondary;
+} channel_pair;
+
+typedef struct {
+	u32 chan_no;
+	u32 primary;
+	u32 secondary;
+	u32 freq;
+} mxl_acs_chan;
+
+typedef struct acs_candidate_table
+{
+	u32 primary;
+	u32 secondary;
+	u32 freq;      /* low frequency */
+	int width;
+	u32 chan;      /* center chan number */
+
+	/* calculated */
+	int rank;
+	int rank_util_primary;
+	int bw_comp_rank;
+	int bw_comp_util;
+
+	u32  num_bss;
+	u32  num_bss_pen;
+	u32  num_bss_pri;
+	bool radar_affected;
+	bool radar_detected;
+	bool overlap40;
+	bool overlap_vht_he;
+	u32  intolerant40;
+	struct os_reltime ts_overlap40;      // Timestamp of overlapping 40 MHz detected
+	struct os_reltime ts_overlap_vht_he; // Timestamp of overlapping VHT / HE detected
+	struct os_reltime ts_intolerant40;   // Timestamp of intolerant 40 MHz detected
+	int cwi_noise[ACS_NUM_BW_ELEMS];
+	u32 tx_power;
+	u32 channel_load[ACS_NUM_BW_ELEMS];
+	u32 filled_mask;
+	char exclude_reason;
+	bool scanned; /* Set only if width is 20 MHz */
+} acs_candidate_table;
+
+enum {
+	SWR_INITIAL,
+	SWR_RADAR,
+	SWR_BG_SCAN,
+	SWR_UPDATE,
+	SWR_LAST
+};
+
+int mxl_acs_recalc_ranks_and_set_chan(struct hostapd_iface *iface, int switch_reason);
+void mxl_acs_update_intolerant_channels(struct hostapd_iface *iface, u8 chan);
+void mxl_acs_update_radar(struct hostapd_iface *iface);
+void mxl_acs_radar_switch(struct hostapd_iface *iface);
+int mxl_acs_do_switch_channel(struct hostapd_iface *iface, int block_tx);
+void mxl_acs_update_scan_states(struct hostapd_iface *iface);
+void mxl_acs_restore_6g_scan_states(struct hostapd_iface *iface);
+int mxl_is_6ghz_opt_freq(struct hostapd_iface *iface, int freq);
+void mxl_acs_6ghz_prepare_rnr_scan_data(struct hostapd_iface *iface);
+void mxl_acs_rnr_scan_cb(struct hostapd_iface *iface);
+void mxl_acs_get_lower_band_status(struct hostapd_iface *iface);
+void mxl_acs_smart_process_bsses(struct hostapd_iface *iface, struct wpa_scan_results *scan_res);
+int mxl_is_6ghz_rnr_passive_scan_freq(struct hostapd_iface *iface, int freq);
+void mxl_acs_init_candidate_table(struct hostapd_iface *iface);
+void mxl_acs_bg_scan_complete(struct hostapd_iface *iface);
+void mxl_acs_rnr_scan_timer_handler(void *eloop_ctx, void *timeout_ctx);
+bool mxl_acs_should_skip_freq(struct hostapd_iface *iface, struct hostapd_channel_data *chan);
+void mxl_smart_acs_scan_complete(struct hostapd_iface *iface);
+bool mxl_acs_is_smart(struct hostapd_iface *iface);
+int mxl_acs_init(struct hostapd_iface *iface);
+int mxl_acs_start(struct hostapd_iface *iface);
+void mxl_event_scan_results(struct hostapd_data *hapd, union wpa_event_data *data);
+int mxl_hostapd_drv_abort_scan(struct hostapd_data *hapd);
+int mxl_hostapd_check_and_abort_scan(struct hostapd_iface *iface);
+
+typedef struct {
+	u8 pri;
+	u8 sec;
+	u8 chwidth;
+	u8 cent_freq;
+	int sel_cand;
+} mxl_acs_chandef;
+
+/* declarations for wrapper functions to make static open source functions accesible to MXL code */
+void mxl_acs_fail(struct hostapd_iface *iface);
+int * mxl_acs_request_scan_add_freqs(struct hostapd_iface *iface, struct hostapd_hw_modes *mode, int *freq);
+int  mxl_acs_request_scan(struct hostapd_iface *iface);
+void mxl_acs_scan_complete(struct hostapd_iface *iface);
+struct hostapd_channel_data *mxl_acs_find_chan(struct hostapd_iface *iface, int freq);
+int  mxl_is_in_chanlist(struct hostapd_iface *iface, struct hostapd_channel_data *chan);
+void mxl_acs_cleanup(struct hostapd_iface *iface);
+void mxl_acs_study(struct hostapd_iface *iface);
+void mxl_acs_init_defaults(struct hostapd_iface *iface);
+int mxl_hostapd_acs_get_candidates_rank_idx(struct hostapd_iface *iface, int primary_channel,
+					    int secondary_offset, int bandwidth);
+bool mxl_hostapd_acs_compare_ranks(struct hostapd_iface *iface, int rank1_idx, int rank2_idx);
+struct acs_candidate_table *mxl_acs_get_failsafe_channel(struct hostapd_iface *iface, bool skip_usable);
+int mxl_hostapd_change_country(struct hostapd_iface *iface, struct channel_list_changed *info);
+int mxl_acs_find_center_chan(int freq, int width);
+void mxl_acs_bgscan_timer_cb(void *eloop_data, void *user_ctx);
+int mxl_acs_check_bgscan(struct hostapd_iface *iface);
+void mxl_acs_set_bgscan_int(struct hostapd_data *hapd);
+
+#endif /* MXL_ACS_H */
diff --git a/src/ap/mxl_coexistence.c b/src/ap/mxl_coexistence.c
index 14824cc61..8f6b9b7ab 100644
--- a/src/ap/mxl_coexistence.c
+++ b/src/ap/mxl_coexistence.c
@@ -19,6 +19,9 @@
 #include "hostapd.h"
 #include "mxl_coexistence.h"
 #include "common/mxl_wpa_ctrl.h"
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 
 void mxl_hostapd_fill_obss_scan_params(struct ieee80211_obss_scan_parameters *scan_params, const struct hostapd_data *hapd) {
@@ -40,6 +43,12 @@ void mxl_hostapd_fill_obss_scan_params(struct ieee80211_obss_scan_parameters *sc
 static void mxl_hostapd_switch_to_20mhz(struct hostapd_data *hapd,
 			        struct hostapd_iface *iface, const struct ieee80211_mgmt *mgmt, int signal)
 {
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#ifdef CONFIG_ACS
+	if (mxl_acs_is_smart(iface) && iface->conf->mxl_conf.acs_init_done)
+		mxl_acs_update_intolerant_channels(iface, iface->conf->channel);
+#endif /* CONFIG_ACS */
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	if (iface->drv_flags & WPA_DRIVER_FLAGS_HT_2040_COEX) {
 		if (iface->conf->secondary_channel) {
 			hostapd_logger(hapd, mgmt->sa,
diff --git a/src/ap/mxl_config.h b/src/ap/mxl_config.h
index 76abc45e5..1e75a45a2 100644
--- a/src/ap/mxl_config.h
+++ b/src/ap/mxl_config.h
@@ -17,6 +17,39 @@
 #include "mxl_softblock.h"
 #include "common/ieee802_11_defs.h"
 
+struct hostapd_config;
+struct hostapd_bss_config;
+
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+
+#define SCAN_RSSI_THRESHOLD_DEFAULT     -86
+#define ACS_NUM_PENALTY_FACTORS         4
+#define ACS_PEN_MIN                     0
+#define ACS_PEN_MAX                     1000
+#define ACS_PEN_DEFAULT                 100
+#define ACS_PEN_DEFAULT_WBSS            50
+#define ACS_NUM_GRP_PRIORITIES          4
+#define ACS_MAX_CHANNELS                (233+1)
+#define ACS_SWITCH_THRESHOLD            100
+#define ACS_MIN_NUM_SCANS               1
+#define ACS_MAX_NUM_SCANS               100
+#define ACS_NOISE_THR_MIN               (-128)
+#define ACS_NOISE_THR_MAX               0
+#define ACS_NOISE_THR_DEFAULT           (-68)
+
+typedef struct acs_chan {
+        int primary;
+        int secondary;
+        int width;
+} acs_chan;
+
+int mxl_config_check_smart_acs_config(struct hostapd_config *conf, struct hostapd_bss_config *bss, const char *buf, char* pos, int line);
+int mxl_hostapd_acs_config_defaults(struct hostapd_config *conf);
+void mxl_hostapd_config_fill_acs(struct hostapd_config *conf, char *pos);
+void mxl_hostapd_config_free_acs(struct hostapd_config *conf);
+int mxl_hostapd_config_check_acs(struct hostapd_config *conf, int full_config);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 #define CCA_TH_SIZE 5
 
 struct duplicate_beacon {
@@ -312,6 +345,47 @@ struct mxl_hostapd_config {
 	u8 ap_retry_limit_data;
 	u8 ap_retry_limit_probe_resp;
 	colocated_6g_ap_info_t coloc_6g_ap_info[MAX_SUPPORTED_6GHZ_RADIO];
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	int acs_scan_mode;
+	int ScanRssiTh;
+	enum {
+		ACS_ALGO_SURVEY = 0,
+		ACS_ALGO_SMART  = 1,
+	} acs_algo;
+
+#ifdef CONFIG_ACS
+	/* SmartACS */
+	int acs_init_done;
+	char *acs_smart_info_file;
+	char *acs_history_file;
+	struct acs_chan acs_fallback_chan;
+	int *acs_penalty_factors;
+	int acs_chan_cust_penalty[ACS_MAX_CHANNELS];
+	int acs_noise_threshold;
+	int *acs_grp_priorities_throughput; // [ACS_NUM_GRP_PRIORITIES];
+	int *acs_grp_priorities_reach; // [ACS_NUM_GRP_PRIORITIES];
+	int acs_grp_prio_reach_map[ACS_NUM_GRP_PRIORITIES];
+	int acs_grp_prio_tp_map[ACS_NUM_GRP_PRIORITIES];
+	int acs_policy;
+	int acs_switch_thresh;
+	int acs_bw_comparison;
+	int acs_use24overlapped;
+	int acs_bg_scan_do_switch;
+	int acs_update_do_switch;
+
+	/* If this is set, exclude candidates (which are not provided in chanlist) from ACS table, ACS scan and ACS reports
+	 * Otherwise cadidates will be included, but not selected due to exclude reason 'disabled' */
+	int acs_strict_chanlist;
+	int acs_chanlist_all_chans;
+	int *acs_6g_opt_ch_list;
+	int acs_6g_opt_ch_count;
+	int acs_rnr_scan_timeout;
+	int acs_6g_punct_mode;
+	u16 acs_bgscan_interval;
+	struct acs_exclude *acs_exclude_opclass_ch_list;
+	int acs_exclude_opclass_ch_count;
+#endif /* CONFIG_ACS */
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	int allow_scan_during_cac;
 	int sub_band_dfs;
@@ -372,6 +446,9 @@ enum duplicate_beacon_bw {
  * struct mxl_hostapd_bss_config - Per-BSS configuration
  */
 struct mxl_hostapd_bss_config {
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	u32 scan_timeout;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	/* Soft Block ACL */
 	struct soft_block_acl_db deny_mac_sb;
@@ -420,14 +497,12 @@ struct mxl_hostapd_bss_config {
 #endif /* CONFIG_LEGACY_MULTI_AP_MXL */
 };
 
-struct hostapd_config;
-struct hostapd_bss_config;
 
 int mxl_hostapd_config_fill (struct hostapd_config *conf,
 					struct hostapd_bss_config *bss,
 					const char *buf, char *pos, int line);
 void mxl_hostapd_config_defaults_bss(struct hostapd_bss_config *bss);
-void mxl_hostapd_config_defaults(struct hostapd_config *conf);
+int mxl_hostapd_config_defaults(struct hostapd_config *conf);
 void mxl_hostapd_config_free_bss(struct hostapd_bss_config *bss);
 int mxl_hostapd_config_check(struct hostapd_config *conf, int full_config);
 int mxl_hostapd_config_check_bss(struct hostapd_bss_config *bss, struct hostapd_config *conf, int full_config);
diff --git a/src/ap/mxl_dfs_common.c b/src/ap/mxl_dfs_common.c
index a2065035d..a32b235c4 100644
--- a/src/ap/mxl_dfs_common.c
+++ b/src/ap/mxl_dfs_common.c
@@ -74,10 +74,13 @@ void mxl_hostapd_event_dfs_cac_paused(struct hostapd_data *hapd, struct dfs_even
 {
 	wpa_printf(MSG_DEBUG, "DFS CAC paused on %d MHz", radar->freq);
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
 	/* CAC was paused for some reason (probably becuase user
 	 * initiated a scan request via iw). Restart CAC once scan is
 	 * done. */
 	wpa_printf(MSG_INFO, "CAC paused, restart CAC when scan is done");
+	hapd->iface->mxl_iface.cac_required = 1;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 }
 
 static struct hostapd_channel_data *
@@ -155,9 +158,11 @@ void mxl_hostapd_dfs_cac_restart(struct hostapd_iface *iface)
 	if (mxl_dfs_check_chans_unavailable(iface, start_chan_idx, n_chans)) {
 		wpa_printf(MSG_DEBUG, "CAC won't be restarted, some channels are unavailable");
 #ifdef CONFIG_ACS
-		if (!mxl_dfs_is_failsafe_enabled(iface))
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		if (!mxl_dfs_is_failsafe_enabled(iface) && iface->conf->mxl_conf.acs_init_done)
 			mxl_hostapd_handle_radar(iface, 0, 0);
 		else
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #endif
 			mxl_hostapd_dfs_start_channel_switch(iface);
 		return;
@@ -223,6 +228,19 @@ struct hostapd_channel_data * mxl_dfs_get_valid_channel(struct hostapd_iface *if
 
 bool mxl_hostapd_handle_radar(struct hostapd_iface *iface, int cf1, int bw)
 {
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if (iface->mxl_iface.in_scan) {
+		wpa_printf(MSG_INFO, "Radar detected during scan, not initiating channel switch");
+		return true;
+	}
+
+	/* if radar event happens during a scan triggered by iw, which started
+	 * while CAC was in progress ignore event */
+	if (iface->mxl_iface.cac_required){
+		wpa_printf(MSG_INFO, "CAC pending, not initiating channel switch");
+		return true;
+	}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	if (cf1 && bw) {
 		if (mxl_hostapd_handle_sb_dfs_radar(iface, cf1, bw))
@@ -244,7 +262,19 @@ bool mxl_hostapd_handle_radar(struct hostapd_iface *iface, int cf1, int bw)
 		mxl_hostapd_set_zwdfs_antenna(iface->bss[0], 0);
 	}
 
+#ifdef CONFIG_ACS
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if (!iface->conf->mxl_conf.acs_init_done)
+		return false;
+
+	mxl_acs_radar_switch(iface);
+	return true;
+#else
 	return false;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+#else
+	return false;
+#endif
 }
 
 bool mxl_hostapd_check_rbm(struct hostapd_iface *iface, int ch_pos)
diff --git a/src/ap/mxl_dfs_file.c b/src/ap/mxl_dfs_file.c
index f5100e91b..0bba4043c 100644
--- a/src/ap/mxl_dfs_file.c
+++ b/src/ap/mxl_dfs_file.c
@@ -17,7 +17,6 @@
 #include "hostapd.h"
 #include "common/hw_features_common.h"
 #include "mxl_dfs_common.h"
-int  mxl_is_in_chanlist(struct hostapd_iface *iface, struct hostapd_channel_data *chan);
 
 static int mxl_hostapd_dfs_channel_state_file_update(struct hostapd_iface *iface, int update_time)
 {
diff --git a/src/ap/mxl_events.c b/src/ap/mxl_events.c
index 0f75c114f..8dbd2bc7a 100644
--- a/src/ap/mxl_events.c
+++ b/src/ap/mxl_events.c
@@ -20,6 +20,9 @@
 
 enum mxl_event_type {
 	EVENT_MXL_FLUSH_STATIONS_RX,
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	EVENT_MXL_CHAN_DATA,
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	EVENT_MXL_RADAR,
 	EVENT_MXL_COC,
 	EVENT_MXL_SOFTBLOCK_DROP,
@@ -36,6 +39,13 @@ union mxl_event_data {
 		size_t data_len;
 	} flush_stations;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	struct chan_data {
+		const u8 *data;
+		size_t data_len;
+	} chan_data;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	struct radar {
 		const u8 *data;
 		size_t data_len;
@@ -64,6 +74,9 @@ static const char * mxl_event_to_string(enum mxl_event_type event)
 #define E2S(n) case EVENT_ ## n: return #n
 	switch (event) {
 	E2S(MXL_FLUSH_STATIONS_RX);
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	E2S(MXL_CHAN_DATA);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	E2S(MXL_RADAR);
 	E2S(MXL_COC);
 	E2S(MXL_SOFTBLOCK_DROP);
@@ -97,6 +110,26 @@ static void mxl_event_flush_stations_rx(struct hostapd_data *hapd,
 	mxl_hostapd_clear_old(iface, flush);
 }
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+static void mxl_event_chan_data(struct hostapd_data *hapd,
+					const u8 *data, size_t data_len)
+{
+	struct hostapd_iface *iface = hapd->iface;
+
+	/* Discard event if interface didn't finished initialization.
+	 * This may happen when driver sends irrelevant events due to station mode actions
+	 */
+	if (iface->state == HAPD_IFACE_UNINITIALIZED ||
+	    iface->state == HAPD_IFACE_DISABLED ||
+	    iface->state == HAPD_IFACE_COUNTRY_UPDATE ) {
+		wpa_printf(MSG_DEBUG, "discard driver event (%s) - interface not ready yet", __FUNCTION__);
+		return;
+	}
+
+	mxl_hostapd_update_channel_data(iface, data, data_len);
+}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 static void mxl_event_radar_detected(struct hostapd_data *hapd, const u8 *data, size_t data_len)
 {
 	/* Discard event if interface didn't finished initialization.
@@ -186,6 +219,15 @@ static void mxl_process_event(void *ctx, enum mxl_event_type event,
 					data->flush_stations.data,
 					data->flush_stations.data_len);
 		break;
+#ifdef CONFIG_ACS
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	case EVENT_MXL_CHAN_DATA:
+		mxl_event_chan_data(hapd,
+					data->chan_data.data,
+					data->chan_data.data_len);
+		break;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+#endif /* CONFIG_ACS */
 	case EVENT_MXL_RADAR:
 		mxl_event_radar_detected(hapd, data->radar.data, data->radar.data_len);
 		break;
@@ -223,6 +265,17 @@ void mxl_drv_event_flush_stations(void *ctx, const u8 *data, size_t data_len)
 	mxl_process_event(ctx, EVENT_MXL_FLUSH_STATIONS_RX, &event);
 }
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+void mxl_drv_event_chan_data(void *ctx, const u8 *data, size_t data_len)
+{
+	union mxl_event_data event;
+	os_memset(&event, 0, sizeof(event));
+	event.chan_data.data = data;
+	event.chan_data.data_len = data_len;
+	mxl_process_event(ctx, EVENT_MXL_CHAN_DATA, &event);
+}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 void mxl_drv_event_radar(void *ctx, const u8 *data, size_t data_len)
 {
 	union mxl_event_data event;
diff --git a/src/ap/mxl_hostapd.c b/src/ap/mxl_hostapd.c
index 6e274334c..8fd5608a5 100644
--- a/src/ap/mxl_hostapd.c
+++ b/src/ap/mxl_hostapd.c
@@ -36,6 +36,9 @@
 #ifdef CONFIG_AFC
 #include "mxl_afc.h"
 #endif /* CONFIG_AFC */
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 #define COC_POWER_1x1_STATE 1
 #define COC_POWER_2x2_STATE 2
@@ -1780,6 +1783,8 @@ void mxl_hostapd_setup_interface_post(struct hostapd_iface *iface)
 	struct mxl_hostapd_config *mxl_conf = &hapd->iconf->mxl_conf;
 	int ap_retry_limit_cfg[3];
 
+	mxl_acs_set_bgscan_interval(hapd);
+
 	/* Set AP retry limit only if user configured this */
 	ap_retry_limit_cfg[0] = mxl_conf->ap_retry_limit;
 	ap_retry_limit_cfg[1] = mxl_conf->ap_retry_limit_data;
@@ -2021,6 +2026,7 @@ int is_5ghz_op_class(u8 op_class)
 {
 	return op_class >= 115 && op_class <= 130;
 }
+
 int nl80211_nlmsg_set_default_size_vendor_mxl(size_t nlmsg_new_size);
 
 static void mxl_hostapd_nl80211_driver_init(struct hostapd_iface *iface)
@@ -2039,7 +2045,14 @@ static void mxl_hostapd_nl80211_driver_init(struct hostapd_iface *iface)
 
 void mxl_hostapd_driver_init(struct hostapd_iface *iface, struct wpa_init_params *params)
 {
+	struct hostapd_data *hapd = iface->bss[0];
+
 	iface->mxl_iface.allow_scan_during_cac = -1;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	iface->mxl_iface.cac_required = 0;
+
+	params->scan_timeout = hapd->conf->mxl_bss_conf.scan_timeout;
+#endif/* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	mxl_hostapd_nl80211_driver_init(iface);
 }
@@ -2677,6 +2690,9 @@ int mxl_hostapd_no_ir_channel_list_updated(struct hostapd_iface *iface)
 	 *   channel of the connected AP interface.
 	 */
 	if (iface->conf->acs && !iface->conf->mxl_conf.is_client_mode) {
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		iface->conf->mxl_conf.acs_init_done = 0;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		iface->conf->channel = 0;
 	}
 
@@ -3538,3 +3554,10 @@ size_t mxl_hostapd_get_mbssid_tx_bss_idx(struct hostapd_iface *iface)
 
 	return MULTIBSS_REFERENCE_BSS_IDX;
 }
+
+void mxl_acs_set_bgscan_interval(struct hostapd_data *hapd)
+{
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	mxl_acs_set_bgscan_int(hapd);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+}
diff --git a/src/ap/mxl_hostapd.h b/src/ap/mxl_hostapd.h
index 53130e588..6fd0d2424 100644
--- a/src/ap/mxl_hostapd.h
+++ b/src/ap/mxl_hostapd.h
@@ -16,6 +16,9 @@
 
 #include "../utils/mxl_common.h"
 #include "../drivers/driver.h"
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #include "mxl_sub_band_dfs.h"
 #include "mxl_zwdfs.h"
 #include "sta_info.h"
@@ -70,8 +73,51 @@ struct hostapd_failsafe_freq_params {
 struct mxl_hostapd_iface {
 	u32 sta_aid_link[MXL_AID_WORDS];
 	s8 stas_free_reason; /* the reason for all stations remove */
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	unsigned int acs_update_in_progress:1;
+	unsigned int cac_required:1;
+	int in_scan;
+
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+#ifdef CONFIG_ACS
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	acs_candidate_table candidates[MAX_CANDIDATES]; /* MAX_CANDIDATES == all possible bondings */
+	u32 num_candidates;
+	int selected_candidate;
+	u32 min_noise;
+	u32 acs_num_bss; /* over the whole band */
+	u32 max_tx_power; /* over the whole band */
+	u32 max_num_bss_pen;
+
+	enum hostapd_acs_6g_scan_status {
+		SCAN_6G_IDLE = 1,    /* SCAN is not on-going */
+		SCAN_6G_STARTED,     /* Scan request is sent to kernel/driver for scanning */
+		SCAN_6G_WAITING,     /* FOR RNR SCAN waiting for lower bands to complete or timeout to expire */
+		SCAN_6G_DONE,        /* scan request sent Kernel/driver is completed */
+		SCAN_6G_COMPLETE     /* All scan request for 6G is completed - proceed for rank calculation */
+	} acs_6g_scan_status;
+
+	enum hostapd_acs_6g_scan_type {
+		SCAN_6G_NONE = 1,
+		SCAN_6G_PSC_OPT,          /* 6G Preferred Scanning Channels + Optional scanning channels (user configured) */
+		SCAN_6G_RNR_PASSIVE,      /* 6G NON-PSC channels derived from RNR IE for PASSIVE scanning */
+		SCAN_6G_FULL_BAND,        /* SCAN all channels for 6G BAND */
+		SCAN_6G_UNII5_UNII7_BAND, /* SCAN UNII5 and UNII7 BAND channels for 6G */
+	} acs_6g_scan_type;
+
+	int acs_rnr_available;
+#define MAX_6GHZ_CH 59
+	int acs_6ghz_passive_ch_list[MAX_6GHZ_CH];
+	int acs_6ghz_passive_ch_num;
+	bool retrigger_acs;
+	bool acs_bgscan;
+	bool dfs_bg_cac;
+	int acs_reenable_iface;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	int acs_user_config_cw;
 	int acs_user_config_op_class;
+#endif /* CONFIG_ACS */
+
 	int allow_scan_during_cac;
 	struct hostapd_failsafe_freq_params failsafe;
 	u8 rbm; /* Radar Bit Map */
@@ -188,6 +234,15 @@ int mxl_hostapd_get_aid(struct hostapd_data *hapd, struct sta_info *sta);
 void mxl_hostapd_free_aid(struct hostapd_data *hapd, struct sta_info *sta);
 void mxl_hostapd_clear_old(struct hostapd_iface *iface, s32 flush);
 bool mxl_hostapd_is_recovery(struct hostapd_iface *iface);
+
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+enum hostapd_iface_state;
+#ifdef CONFIG_ACS
+void mxl_hostapd_update_channel_data(struct hostapd_iface *iface, const u8 *data, size_t data_len);
+#endif /* CONFIG_ACS */
+void mxl_hostapd_set_state_pre(struct hostapd_iface *iface, enum hostapd_iface_state s);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 int mxl_hostapd_get_num_width(enum oper_chan_width width, int secondary);
 const char * mxl_hostapd_channel_switch_text(enum hostapd_channel_switch_reason s);
 void mxl_hostapd_channel_switch_reason_set(struct hostapd_iface *iface,
@@ -269,4 +324,5 @@ void mxl_hostapd_check_limit_reached(struct hostapd_data *hapd, const u8 *sta_ad
 int mxl_hostapd_check_and_reorder_bss_conf(struct hostapd_iface *iface, struct hostapd_config *newconf);
 struct hostapd_data *mxl_hostapd_get_setup_mbssid_bss(struct hostapd_iface *iface, size_t idx);
 size_t mxl_hostapd_get_mbssid_tx_bss_idx(struct hostapd_iface *iface);
+void mxl_acs_set_bgscan_interval(struct hostapd_data *hapd);
 #endif /* MXL_HOSTAPD_H */
diff --git a/src/ap/mxl_hostapd_proprietary.c b/src/ap/mxl_hostapd_proprietary.c
new file mode 100644
index 000000000..be657927f
--- /dev/null
+++ b/src/ap/mxl_hostapd_proprietary.c
@@ -0,0 +1,40 @@
+/******************************************************************************
+
+         Copyright (c) 2024, MaxLinear, Inc.
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "hostapd.h"
+#include "ap_drv_ops.h"
+#include "ap_config.h"
+#include "sta_info.h"
+#include "beacon.h"
+#include "mxl_hostapd.h"
+#include "common/vendor_cmds_copy.h"
+#include "ieee802_11.h"
+#include "mxl_config.h"
+#include "common/mxl_ieee802_11_defs.h"
+#include "hw_features.h"
+#include "common/hw_features_common.h"
+#include "common/wpa_ctrl.h"
+#include "mxl_beacon.h"
+#include "mxl_wpa_auth.h"
+#include "mxl_sta_info.h"
+#include "common/mxl_ieee802_11_common.h"
+#include "mxl_dfs_common.h"
+#include "dfs.h"
+void mxl_hostapd_set_state_pre(struct hostapd_iface *iface, enum hostapd_iface_state s)
+{
+#ifdef CONFIG_ACS
+	iface->mxl_iface.acs_bgscan = ((HAPD_IFACE_ENABLED == iface->state) && (HAPD_IFACE_ACS == s));
+#else
+	(void)iface;
+	(void)s;
+#endif /* CONFIG_ACS */
+}
diff --git a/src/ap/mxl_rrm.c b/src/ap/mxl_rrm.c
index 43f14b1f4..377980f6c 100644
--- a/src/ap/mxl_rrm.c
+++ b/src/ap/mxl_rrm.c
@@ -488,7 +488,10 @@ int mxl_hostapd_send_beacon_req(struct hostapd_data *hapd, const u8 *addr,
 static void mxl_rrm_reset_scan_callback(struct hostapd_iface *iface)
 {
 #ifdef CONFIG_ACS
-	iface->scan_cb = NULL;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	void mxl_acs_set_bg_scan_callback(struct hostapd_iface *iface);
+	mxl_acs_set_bg_scan_callback(iface);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #else
 	iface->scan_cb = NULL;
 #endif
diff --git a/src/ap/mxl_sub_band_dfs.c b/src/ap/mxl_sub_band_dfs.c
index 05c811744..7403a3b41 100644
--- a/src/ap/mxl_sub_band_dfs.c
+++ b/src/ap/mxl_sub_band_dfs.c
@@ -233,6 +233,45 @@ mxl_hostapd_sb_dfs_check_cntr(struct hostapd_iface *iface, u8 rbm)
 static bool
 mxl_hostapd_sub_dfs_curr_better_than_failsafe(struct hostapd_iface *iface)
 {
+#ifdef  CONFIG_VENDOR_MXL_PROPRIETARY
+#ifdef CONFIG_ACS
+	u8 chan_failsafe_prim;
+	int rank_current_idx, rank_failsafe_idx, chan_failsafe_sec_offs, failsafe_center_idx;
+	int chan_current_bw;
+
+	if (iface->mxl_iface.failsafe.freq == 0)
+		return false;
+
+	if (!mxl_acs_is_smart(iface))
+		return false;
+
+	if (!iface->conf->mxl_conf.acs_init_done)
+		return false;
+
+	if (HOSTAPD_MODE_IEEE80211A != ieee80211_freq_to_chan(iface->mxl_iface.failsafe.freq, &chan_failsafe_prim))
+		return false;
+
+	chan_current_bw = mxl_hostapd_get_num_width(hostapd_get_oper_chwidth(iface->conf), iface->conf->secondary_channel);
+
+	rank_current_idx = mxl_hostapd_acs_get_candidates_rank_idx(iface,
+								   iface->conf->channel,
+								   iface->conf->secondary_channel,
+								   chan_current_bw);
+
+	failsafe_center_idx = 36 + (iface->mxl_iface.failsafe.center_freq1 - 5180) / 5;
+
+	chan_failsafe_sec_offs = mxl_hostapd_get_secondary_offset(chan_failsafe_prim, iface->mxl_iface.failsafe.bandwidth, failsafe_center_idx);
+	rank_failsafe_idx = mxl_hostapd_acs_get_candidates_rank_idx(iface,
+								    chan_failsafe_prim,
+								    chan_failsafe_sec_offs,
+								    iface->mxl_iface.failsafe.bandwidth);
+
+	wpa_printf(MSG_DEBUG, "SB DFS: Rank indexes BW comparison: current %d, failsafe %d", rank_current_idx, rank_failsafe_idx);
+	return mxl_hostapd_acs_compare_ranks(iface, rank_current_idx, rank_failsafe_idx);
+#else
+	return false;
+#endif /* CONFIG_ACS */
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	return false;
 }
 
diff --git a/src/ap/mxl_zwdfs.c b/src/ap/mxl_zwdfs.c
index 3699af882..8097199f1 100644
--- a/src/ap/mxl_zwdfs.c
+++ b/src/ap/mxl_zwdfs.c
@@ -22,7 +22,6 @@
 #include "common/mxl_wpa_ctrl.h"
 #include "common/hw_features_common.h"
 #include "ap/mxl_hostapd.h"
-int  mxl_is_in_chanlist(struct hostapd_iface *iface, struct hostapd_channel_data *chan);
 
 static bool mxl_hostapd_is_zwdfs_iface(struct hostapd_iface *iface)
 {
@@ -694,3 +693,75 @@ int mxl_hostapd_handle_zwdfs_switch(struct hostapd_iface *iface, int success, in
 	}
 	return 0;
 }
+
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+int mxl_acs_request_background_cac(struct hostapd_iface *iface)
+{
+	int res;
+	struct csa_settings settings = {0};
+	struct hostapd_hw_modes *cmode = iface->current_mode;
+
+	/* check if background dfs cac enabled */
+	if (!iface->mxl_iface.dfs_bg_cac) {
+		return 0;
+	}
+
+	settings.cs_count = mxl_hostapd_get_cs_count(iface);
+	res = hostapd_set_freq_params(&settings.freq_params, iface->conf->hw_mode, iface->freq,
+			iface->conf->channel, iface->conf->enable_edmg,
+			iface->conf->edmg_channel, iface->conf->ieee80211n,
+			iface->conf->ieee80211ac, iface->conf->ieee80211ax, iface->conf->ieee80211be,
+			iface->conf->secondary_channel,
+			hostapd_get_oper_chwidth(iface->conf),
+			hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
+			hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
+			cmode ? cmode->vht_capab : 0,
+			cmode ? &cmode->he_capab[IEEE80211_MODE_AP] : NULL,
+			cmode ? &cmode->eht_capab[IEEE80211_MODE_AP] : NULL);
+
+	if (res) {
+		wpa_printf(MSG_ERROR, "DFS failed to calculate CSA freq params");
+		return -1;
+	}
+
+	/* Start ZWDFS CAC in background */
+	if (mxl_hostapd_start_background_cac(iface, &settings)) {
+		wpa_printf(MSG_ERROR, "%s: Failed to start Background CAC in ZWDFS antenna\n", __func__);
+		return -1;
+	}
+
+	return 1;
+}
+
+bool mxl_acs_set_background_cac(struct hostapd_iface *iface)
+{
+	bool res = false;
+
+	if (iface->state == HAPD_IFACE_DFS) {
+		if (iface->mxl_iface.dfs_bg_cac) {
+			iface->mxl_iface.dfs_bg_cac = false;
+			res = true;
+		}
+	} else {
+		iface->mxl_iface.dfs_bg_cac = false;
+		res = false;
+	}
+	return res;
+}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
+int mxl_acs_request_bg_cac(struct hostapd_iface *iface)
+{
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	return mxl_acs_request_background_cac(iface);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+	return 0;
+}
+
+bool mxl_acs_set_bg_cac(struct hostapd_iface *iface)
+{
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	return mxl_acs_set_background_cac(iface);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+	return false;
+}
diff --git a/src/ap/mxl_zwdfs.h b/src/ap/mxl_zwdfs.h
index b84cd8f89..7977e21a8 100644
--- a/src/ap/mxl_zwdfs.h
+++ b/src/ap/mxl_zwdfs.h
@@ -31,4 +31,6 @@ int mxl_hostapd_zwdfs_restart_cac(struct hostapd_iface *iface, u8 chan, enum cha
 void mxl_hostapd_zwdfs_cac_on_radar(struct hostapd_iface *iface, struct csa_settings *settings);
 int mxl_hostapd_handle_zwdfs_switch(struct hostapd_iface *iface, int success, int freq, int chan_width, int cf1, int cf2);
 int mxl_hostapd_zwdfs_cac_on_autoCoC(struct hostapd_iface *iface);
+int mxl_acs_request_bg_cac(struct hostapd_iface *iface);
+bool mxl_acs_set_bg_cac(struct hostapd_iface *iface);
 #endif /* MXL_ZWDFS_H */
diff --git a/src/common/ieee802_11_common.c b/src/common/ieee802_11_common.c
index 13c2e3531..c0384ea73 100644
--- a/src/common/ieee802_11_common.c
+++ b/src/common/ieee802_11_common.c
@@ -253,6 +253,13 @@ static int ieee802_11_parse_vendor_specific(const u8 *pos, size_t elen,
 		}
 		break;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	case OUI_LTQ:
+		elems->mxl_fils_ie = pos;
+		elems->mxl_fils_ie_len = elen;
+		break;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	default:
 		wpa_printf(MSG_EXCESSIVE, "unknown vendor specific "
 			   "information element ignored (vendor OUI "
diff --git a/src/common/ieee802_11_common.h b/src/common/ieee802_11_common.h
index 9493cf048..31985ecd8 100644
--- a/src/common/ieee802_11_common.h
+++ b/src/common/ieee802_11_common.h
@@ -124,6 +124,9 @@ struct ieee802_11_elems {
 	const u8 *rsn_selection;
 	const u8 *rnr;
 #ifdef CONFIG_VENDOR_MXL
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	const u8 *mxl_fils_ie;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	const u8 *multilink_ie;
 	const u8 *non_inheritance;
 	const u8 *wfa_capability_elem;
@@ -201,6 +204,9 @@ struct ieee802_11_elems {
 	u8 rnr_len;
 	size_t rsn_selection_len;
 #ifdef CONFIG_VENDOR_MXL
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	u8 mxl_fils_ie_len;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	u8 multilink_ie_len;
 	u8 non_inheritance_len;
 	u8 wfa_capability_elem_len;
diff --git a/src/common/mxl_defs.h b/src/common/mxl_defs.h
index ea759e50d..e2ae853d5 100644
--- a/src/common/mxl_defs.h
+++ b/src/common/mxl_defs.h
@@ -14,6 +14,11 @@
 #ifndef MXL_DEFS_H
 #define MXL_DEFS_H
 
+#define SCAN_TIMEOUT_DEFAULT		300 /* seconds */
+#define SCAN_TIMEOUT_MAX		600
+#define SCAN_TIMEOUT_MIN		30
+#define ACS_BGSCAN_INT_MAX		1440 /* minutes */
+#define ACS_BGSCAN_INT_MIN		15
 #define WAVE_FIRST_5G_CHAN              (36)
 #define WAVE_FIRST_5G_FREQ              (5000u + (5 * WAVE_FIRST_5G_CHAN))
 #define WAVE_FIRST_6G_CHAN              (1)
diff --git a/src/common/mxl_ieee802_11_common.c b/src/common/mxl_ieee802_11_common.c
index 76930b751..8e57c953e 100644
--- a/src/common/mxl_ieee802_11_common.c
+++ b/src/common/mxl_ieee802_11_common.c
@@ -15,6 +15,9 @@
 #include "utils/list.h"
 #include "utils/common.h"
 #include "ieee802_11_common.h"
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+#include "../ap/mxl_acs.h"
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #include "mxl_ieee802_11_common.h"
 
 #define MLO_TYPE_BASIC 0
@@ -34,6 +37,21 @@ bool mxl_scan_res_bss_below_threshold(struct wpa_scan_results *scan_res, int bss
 	return false;
 }
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+void mxl_ieee80211_rnr_info_delete(struct dl_list *rnr_scan_6g_ap_info)
+{
+	rnr_scan_ap_info_t *scan_ap_info, *tmp;
+
+	if (dl_list_empty(rnr_scan_6g_ap_info))
+		return;
+
+	dl_list_for_each_safe(scan_ap_info, tmp, rnr_scan_6g_ap_info, rnr_scan_ap_info_t, list) {
+		dl_list_del(&scan_ap_info->list);
+		os_free(scan_ap_info);
+	}
+}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 int mxl_parse_optional_neighbor_fields(char **tmp_o, const char **end_o, u8 **nei_pos_o, const char **pos_o, u8 **nei_rep_o, size_t nei_rep_len)
 {
 	const char *pos = *pos_o;
diff --git a/src/common/mxl_ieee802_11_common.h b/src/common/mxl_ieee802_11_common.h
index 764074a38..2d8838086 100644
--- a/src/common/mxl_ieee802_11_common.h
+++ b/src/common/mxl_ieee802_11_common.h
@@ -15,9 +15,13 @@
 #define MXL_IEEE802_11_COMMON_H
 
 #include "drivers/driver.h"
+#include "utils/list.h"
 
 void mxl_scan_res_set_rssi_threshold(struct wpa_scan_results *scan_res, int rssi_threshold);
 bool mxl_scan_res_bss_below_threshold(struct wpa_scan_results *scan_res, int bss_rssi);
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+void mxl_ieee80211_rnr_info_delete(struct dl_list *rnr_scan_6g_ap_info);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 int mxl_parse_optional_neighbor_fields(char **tmp_o, const char **end_o, u8 **nei_pos_o, const char **pos_o, u8 **nei_rep_o, size_t nei_rep_len);
 bool mxl_is_6ghz_unii5_unii7(int freq);
 
diff --git a/src/common/mxl_ieee802_11_defs.h b/src/common/mxl_ieee802_11_defs.h
index 26b7ef448..654571a53 100644
--- a/src/common/mxl_ieee802_11_defs.h
+++ b/src/common/mxl_ieee802_11_defs.h
@@ -16,7 +16,7 @@
 
 #include "utils/list.h"
 
-#define STARTING_6G_FREQ_IN_MHZ                         5950
+#define STARTING_6G_FREQ_IN_MHZ				5950
 #define RNR_INFO_TBTT_HDR_TYPE                          0x03
 #define RNR_INFO_TBTT_HDR_FILTERED                      0x04
 #define RNR_INFO_TBTT_HDR_COLOC                         0x08
diff --git a/src/common/mxl_vendor.h b/src/common/mxl_vendor.h
index 670acca98..d5ad20826 100644
--- a/src/common/mxl_vendor.h
+++ b/src/common/mxl_vendor.h
@@ -42,6 +42,9 @@
 MXL_EXPORT_EVENT_API(mxl_drv_event_radar)
 
 MXL_EXPORT_HOSTAPD_EVENT_API(mxl_drv_event_flush_stations)
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+MXL_EXPORT_HOSTAPD_EVENT_API(mxl_drv_event_chan_data)
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 MXL_EXPORT_HOSTAPD_EVENT_API(mxl_drv_event_coc)
 MXL_EXPORT_HOSTAPD_EVENT_API(mxl_drv_event_softblock_drop)
 MXL_EXPORT_HOSTAPD_EVENT_API(mxl_drv_event_wds_connect)
diff --git a/src/common/vendor_cmds_copy.h b/src/common/vendor_cmds_copy.h
index 569c9e4da..ee74d4c0c 100644
--- a/src/common/vendor_cmds_copy.h
+++ b/src/common/vendor_cmds_copy.h
@@ -796,6 +796,35 @@ struct mxl_vendor_ml_critical_update {
 *                           Event structures                                   *
 *******************************************************************************/
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+/* Data for EVENT_LTQ_CHAN_DATA events */
+struct intel_vendor_channel_data
+{
+  u32 channel;
+  int BW;
+  u32 primary;
+  u32 secondary;
+  u32 freq;
+  u32 load;
+  u32 busy_time;
+  u32 total_time;
+  u32 calibration; /* success mask */
+  u32 num_bss;
+  u32 dynBW20;
+  u32 dynBW40;
+  u32 dynBW80;
+  u32 dynBW160;
+  u32 tx_power;
+  int rssi;
+  u32 snr;
+  int cwi_noise;
+  u32 not_80211_rx_evt; /* Used only by legacy statistcis */
+  u32 ext_sta_rx;
+
+  u32 filled_mask;
+} __attribute__ ((packed));
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 /* Data for EVENT_LTQ_CSA_RECEIVED */
 struct intel_vendor_csa_received {
   u32 bandwidth;
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index a1ec284ab..55b1936c9 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -2624,6 +2624,10 @@ struct wpa_init_params {
 	size_t num_bridge;
 
 	u8 *own_addr; /* buffer for writing own MAC address */
+
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	u32 scan_timeout;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 };
 
 
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 750f13ebb..5cb1e8b01 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -2458,6 +2458,10 @@ static void * wpa_driver_nl80211_drv_init(void *ctx, const char *ifname,
 	bss->drv = drv;
 	bss->ctx = ctx;
 #ifdef CONFIG_VENDOR_MXL
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	bss->scan_timeout = SCAN_TIMEOUT_DEFAULT;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	for (i = 0; i < MAX_NUM_MLD_LINKS; i++)
 		bss->links[i].link_id = NL80211_DRV_LINK_ID_NA;
 #endif /* CONFIG_VENDOR_MXL */
@@ -5584,6 +5588,7 @@ static int wpa_driver_nl80211_set_ap(void *priv,
 		goto fail;
 #endif /* CONFIG_FILS */
 
+#ifndef CONFIG_VENDOR_MXL
 	if (params->punct_bitmap) {
 		wpa_printf(MSG_DEBUG, "nl80211: Puncturing bitmap=0x%04x",
 			   params->punct_bitmap);
@@ -5591,6 +5596,7 @@ static int wpa_driver_nl80211_set_ap(void *priv,
 				params->punct_bitmap))
 			goto fail;
 	}
+#endif /* CONFIG_VENDOR_MXL */
 
 #ifdef CONFIG_DRIVER_NL80211_QCA
 	if (cmd == NL80211_CMD_NEW_BEACON && params->allowed_freqs)
@@ -8874,6 +8880,9 @@ static void *i802_init(struct hostapd_data *hapd,
 	}
 
 	bss->br_ifindex = br_ifindex;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	bss->scan_timeout = params->scan_timeout;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	for (i = 0; i < params->num_bridge; i++) {
 		if (params->bridge[i]) {
@@ -10042,6 +10051,9 @@ static int nl80211_set_param(void *priv, const char *param)
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	char *pos;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	const char scan_timeout_str[] = "scan_timeout=";
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	if (param == NULL)
 		return 0;
@@ -10056,6 +10068,21 @@ static int nl80211_set_param(void *priv, const char *param)
 	}
 #endif /* CONFIG_P2P */
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	pos = os_strstr(param, scan_timeout_str);
+	if (pos) {
+		int val;
+
+		pos += sizeof(scan_timeout_str) - 1;
+		val = atoi(pos);
+		if ((val >= SCAN_TIMEOUT_MIN) && (val <= SCAN_TIMEOUT_MAX))
+			bss->scan_timeout = val;
+		else
+			wpa_printf(MSG_ERROR, "scan_timeout %d out of range %d..%d, using default",
+			           val, SCAN_TIMEOUT_MIN, SCAN_TIMEOUT_MAX);
+	}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	if (os_strstr(param, "use_monitor=1"))
 		drv->use_monitor = 1;
 
diff --git a/src/drivers/driver_nl80211.h b/src/drivers/driver_nl80211.h
index 17d90b952..ada84ebfe 100644
--- a/src/drivers/driver_nl80211.h
+++ b/src/drivers/driver_nl80211.h
@@ -96,6 +96,10 @@ struct i802_bss {
 	struct nl80211_wiphy_data *wiphy_data;
 	struct dl_list wiphy_list;
 	u8 rand_addr[ETH_ALEN];
+
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	u32 scan_timeout;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 };
 
 struct drv_nl80211_if_info {
diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index 143d7278d..f4f601b82 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -3259,6 +3259,15 @@ static void mxl_nl80211_handle_flush_stations(struct wpa_driver_nl80211_data *dr
 	mxl_drv_event_flush_stations(drv->ctx, data, len);
 }
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+static void mxl_nl80211_handle_chan_data(struct wpa_driver_nl80211_data *drv,
+				const u8 *data, size_t len)
+{
+	wpa_printf(MSG_DEBUG, "nl80211: Receive MXL vendor event: channel data, ctx=%p", drv->ctx);
+	mxl_drv_event_chan_data(drv->ctx, data, len);
+}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY*/
+
 static void mxl_nl80211_handle_radar(struct wpa_driver_nl80211_data *drv, const u8 *data, size_t len)
 {
 	wpa_printf(MSG_DEBUG, "nl80211: Receive MXL vendor event: radar detected, ctx=%p", drv->ctx);
@@ -3342,12 +3351,17 @@ static void ltq_nl80211_handle_csa_received(struct wpa_driver_nl80211_data *drv,
 }
 
 static void nl80211_vendor_event_mxl(struct wpa_driver_nl80211_data *drv,
-				     u32 subcmd, u8 *data, size_t len)
+				     struct i802_bss *bss, u32 subcmd, u8 *data, size_t len)
 {
 	switch (subcmd) {
 		case LTQ_NL80211_VENDOR_EVENT_FLUSH_STATIONS:
 			mxl_nl80211_handle_flush_stations(drv, data, len);
 			break;
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		case LTQ_NL80211_VENDOR_EVENT_CHAN_DATA:
+			mxl_nl80211_handle_chan_data(drv, data, len);
+			break;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		case LTQ_NL80211_VENDOR_EVENT_CSA_RECEIVED:
 			ltq_nl80211_handle_csa_received(drv, data, len);
 			break;
@@ -3460,6 +3474,7 @@ static void nl80211_vendor_event_brcm(struct wpa_driver_nl80211_data *drv,
 
 
 static void nl80211_vendor_event(struct wpa_driver_nl80211_data *drv,
+				 struct i802_bss *bss,
 				 struct nlattr **tb)
 {
 	u32 vendor_id, subcmd, wiphy = 0;
@@ -3508,7 +3523,7 @@ static void nl80211_vendor_event(struct wpa_driver_nl80211_data *drv,
 	switch (vendor_id) {
 #ifdef CONFIG_DRIVER_NL80211_MXL
 	case OUI_LTQ:
-		nl80211_vendor_event_mxl(drv, subcmd, data, len);
+		nl80211_vendor_event_mxl(drv, bss, subcmd, data, len);
 		break;
 #endif
 	case OUI_QCA:
@@ -4268,7 +4283,7 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 		nl80211_stop_ap(drv, tb);
 		break;
 	case NL80211_CMD_VENDOR:
-		nl80211_vendor_event(drv, tb);
+		nl80211_vendor_event(drv, bss, tb);
 		break;
 	case NL80211_CMD_NEW_PEER_CANDIDATE:
 		nl80211_new_peer_candidate(drv, tb);
diff --git a/src/drivers/driver_nl80211_scan.c b/src/drivers/driver_nl80211_scan.c
index a42fd5d93..296286b52 100644
--- a/src/drivers/driver_nl80211_scan.c
+++ b/src/drivers/driver_nl80211_scan.c
@@ -252,7 +252,11 @@ nl80211_scan_common(struct i802_bss *bss, u8 cmd,
 	params->filter_ssids = NULL;
 	drv->num_filter_ssids = params->num_filter_ssids;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if (is_ap_interface(drv->nlmode)) {
+#else /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	if (!drv->hostapd && is_ap_interface(drv->nlmode)) {
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		wpa_printf(MSG_DEBUG, "nl80211: Add NL80211_SCAN_FLAG_AP");
 		scan_flags |= NL80211_SCAN_FLAG_AP;
 	}
@@ -432,6 +436,9 @@ int wpa_driver_nl80211_scan(struct i802_bss *bss,
 		 */
 		timeout = 30;
 	}
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	timeout = bss->scan_timeout;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	wpa_printf(MSG_DEBUG, "Scan requested (ret=%d) - scan timeout %d "
 		   "seconds", ret, timeout);
 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
diff --git a/src/drivers/mxl_driver_nl80211.c b/src/drivers/mxl_driver_nl80211.c
index 0e8855cf0..46db72595 100644
--- a/src/drivers/mxl_driver_nl80211.c
+++ b/src/drivers/mxl_driver_nl80211.c
@@ -21,6 +21,21 @@
 #include "mxl_driver_nl80211.h"
 #include "mxl_driver.h"
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+bool nl80211_scan_running(void *priv)
+{
+	struct i802_bss *bss;
+	struct wpa_driver_nl80211_data *drv;
+
+	if (!priv)
+		return false;
+
+	bss = priv;
+	drv = bss->drv;
+	return (drv->scan_state == SCAN_STARTED);
+}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 /**
  * mxl_wpa_driver_nl80211_scan_abort_timeout - Scan timeout to report scan abortion
  * @eloop_ctx: Driver private data
diff --git a/src/drivers/mxl_driver_nl80211.h b/src/drivers/mxl_driver_nl80211.h
index 9107929f1..246fe1c2b 100644
--- a/src/drivers/mxl_driver_nl80211.h
+++ b/src/drivers/mxl_driver_nl80211.h
@@ -23,6 +23,9 @@ struct i802_bss;
 	C2S(NL80211_CMD_SET_DFS_STATE) \
 	C2S(NL80211_CMD_ML_CHAN_SWITCH_DONE_NOTIFY)
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+bool nl80211_scan_running(void *priv);
+#endif
 int mxl_nl80211_abort_scan(struct i802_bss *bss);
 int mxl_nl80211_set_channel_dfs_state(void *priv, enum nl80211_dfs_state dfs_state,
 				      int freq, int dfs_time, int dfs_debug);
diff --git a/wpa_supplicant/Makefile b/wpa_supplicant/Makefile
index e40556b41..74155499c 100644
--- a/wpa_supplicant/Makefile
+++ b/wpa_supplicant/Makefile
@@ -1968,6 +1968,9 @@ endif
 ifdef CONFIG_VENDOR_MXL
 CFLAGS += -DCONFIG_VENDOR_MXL
 CFLAGS += -DCONFIG_VENDOR_MXL_BUILD_FOR_SUPPLICANT
+ifndef CONFIG_MXL_OSS_BUILD
+CFLAGS += -DCONFIG_VENDOR_MXL_PROPRIETARY
+endif
 OBJS += ../src/common/mxl_ieee802_11_common.o
 OBJS += mxl_supplicant.o
 OBJS += mxl_events.o
diff --git a/wpa_supplicant/mxl_supplicant.c b/wpa_supplicant/mxl_supplicant.c
index 43721fcd9..f3f712163 100644
--- a/wpa_supplicant/mxl_supplicant.c
+++ b/wpa_supplicant/mxl_supplicant.c
@@ -27,6 +27,24 @@
 #include "driver_i.h"
 #include "bss.h"
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+void mxl_scan_update_6g_rnr_ap_info(struct wpa_supplicant *wpa_s, struct wpa_driver_scan_params *params, int *num_chans, bool is_6ghz)
+{
+	if (is_6ghz) {
+		rnr_scan_ap_info_t *scan_ap_info_tmp;
+		dl_list_for_each(scan_ap_info_tmp, &wpa_s->global->rnr_scan_6g_ap_info, rnr_scan_ap_info_t, list)
+		{
+			if (is_6ghz_psc_frequency(scan_ap_info_tmp->freq))
+				continue;
+
+			params->freqs[(*num_chans)++] = scan_ap_info_tmp->freq;
+			wpa_printf(MSG_DEBUG,"RNR freq added to 6G scan channel list =  %d\n",scan_ap_info_tmp->freq);
+		}
+		mxl_ieee80211_rnr_info_delete(&wpa_s->global->rnr_scan_6g_ap_info);
+	}
+}
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 int mxl_supplicant_drv_get_vendor_data(struct wpa_supplicant *wpa_s,
 			int vendor_id, int subcmd,
 			void *input_data, size_t input_data_size,
diff --git a/wpa_supplicant/mxl_supplicant.h b/wpa_supplicant/mxl_supplicant.h
index 40285ac1c..25503944f 100644
--- a/wpa_supplicant/mxl_supplicant.h
+++ b/wpa_supplicant/mxl_supplicant.h
@@ -25,6 +25,9 @@ int mxl_supplicant_drv_get_vendor_data(struct wpa_supplicant *wpa_s,
 #define MXL_SUPP_DRV_VENDOR_GET(cmd__, in_ptr__, in_size__, out_ptr__, out_size__) \
 	mxl_supplicant_drv_get_vendor_data(wpa_s, OUI_LTQ, (cmd__), (void*)(in_ptr__), (in_size__), (void*)(out_ptr__), (out_size__))
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+void mxl_scan_update_6g_rnr_ap_info(struct wpa_supplicant *wpa_s, struct wpa_driver_scan_params *params, int *num_chans, bool is_6ghz);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 void mxl_supplicant_override_network_modes(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid);
 void mxl_multi_ap_process_assoc_resp(struct wpa_ssid *ssid, struct multi_ap_params *multi_ap);
 int mxl_supplicant_dump_vendor_elements(const struct wpa_bss *bss, char *buf, char *end);
diff --git a/wpa_supplicant/scan.c b/wpa_supplicant/scan.c
index 99a1481fa..27cf9c05e 100644
--- a/wpa_supplicant/scan.c
+++ b/wpa_supplicant/scan.c
@@ -23,6 +23,10 @@
 #include "bss.h"
 #include "scan.h"
 #include "mesh.h"
+#ifdef CONFIG_VENDOR_MXL
+#include "mxl_supplicant.h"
+#include "common/mxl_ieee802_11_common.h"
+#endif /* CONFIG_VENDOR_MXL */
 
 static struct wpabuf * wpa_supplicant_extra_ies(struct wpa_supplicant *wpa_s);
 
@@ -880,8 +884,17 @@ int wpa_add_scan_freqs_list(struct wpa_supplicant *wpa_s,
 		    !is_6ghz_psc_frequency(mode->channels[i].freq))
 			continue;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+		/* TODO investigate possibility to remove this check */
+		if (is_6ghz && !is_6ghz_psc_frequency(mode->channels[i].freq))
+			continue;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 		params->freqs[num_chans++] = mode->channels[i].freq;
 	}
+
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	mxl_scan_update_6g_rnr_ap_info(wpa_s, params, &num_chans, is_6ghz);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	params->freqs[num_chans] = 0;
 
 	return 0;
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index ea10722d1..fda094488 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -8000,6 +8000,9 @@ struct wpa_global * wpa_supplicant_init(struct wpa_params *params)
 		return NULL;
 	dl_list_init(&global->p2p_srv_bonjour);
 	dl_list_init(&global->p2p_srv_upnp);
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	dl_list_init(&global->rnr_scan_6g_ap_info);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	global->params.daemonize = params->daemonize;
 	global->params.wait_for_monitor = params->wait_for_monitor;
 	global->params.dbus_ctrl_interface = params->dbus_ctrl_interface;
diff --git a/wpa_supplicant/wpa_supplicant_i.h b/wpa_supplicant/wpa_supplicant_i.h
index 7c77b679b..a24e6025c 100644
--- a/wpa_supplicant/wpa_supplicant_i.h
+++ b/wpa_supplicant/wpa_supplicant_i.h
@@ -333,6 +333,9 @@ struct wpa_global {
 #endif /* CONFIG_WIFI_DISPLAY */
 
 	struct psk_list_entry *add_psk; /* From group formation */
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	struct dl_list rnr_scan_6g_ap_info; /* struct rnr_scan_ap_info */
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 #ifdef UBUS_SUPPORT
 	struct ubus_object ubus_global;
-- 
2.43.0

