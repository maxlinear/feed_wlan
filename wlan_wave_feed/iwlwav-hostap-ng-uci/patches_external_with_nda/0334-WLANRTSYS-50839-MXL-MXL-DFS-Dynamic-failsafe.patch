From 68c29f2e0aed188bd1c977db3bb2cd7ab92fc199 Mon Sep 17 00:00:00 2001
From: spatel <spatel@maxlinear.com>
Date: Thu, 10 Oct 2024 20:20:23 +0530
Subject: [PATCH] WLANRTSYS-50839 [MXL] MXL DFS Dynamic failsafe

---
 hostapd/Makefile                     |   1 +
 hostapd/ctrl_iface.c                 |   4 +
 hostapd/mxl_config.c                 |   4 +
 hostapd/mxl_config_proprietary.c     |  17 +++++
 hostapd/mxl_ctrl_iface.c             |  10 +++
 hostapd/mxl_ctrl_iface.h             |   2 +
 hostapd/mxl_ctrl_iface_proprietary.c |  20 +++++
 src/ap/mxl_common_proprietary.c      | 109 +++++++++++++++++++++++++++
 src/ap/mxl_config.h                  |   2 +
 src/ap/mxl_dfs_common.c              |  21 +++++-
 src/ap/mxl_dfs_common.h              |   6 ++
 src/ap/mxl_zwdfs.c                   |  20 +++++
 12 files changed, 215 insertions(+), 1 deletion(-)
 create mode 100644 src/ap/mxl_common_proprietary.c

diff --git a/hostapd/Makefile b/hostapd/Makefile
index 26c8381ec..e0a384698 100644
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -417,6 +417,7 @@ OBJS += mxl_config_proprietary.o
 OBJS += mxl_ctrl_iface_proprietary.o
 OBJS += ../src/ap/mxl_dfs_debug.o
 OBJS += ../src/ap/mxl_hostapd_proprietary.o
+OBJS += ../src/ap/mxl_common_proprietary.o
 endif
 ifdef CONFIG_AFC
 OBJS += ../src/ap/mxl_afc.o
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 3d58a03a6..13364e89d 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -1500,6 +1500,10 @@ static int hostapd_ctrl_iface_get(struct hostapd_data *hapd, char *cmd,
 		if (os_snprintf_error(buflen, res))
 			return -1;
 		return res;
+#ifdef CONFIG_VENDOR_MXL
+	} else if (mxl_hostapd_ctrl_iface_get(hapd, cmd, buf, buflen, &res)) {
+		return res;
+#endif /* CONFIG_VENDOR_MXL */
 	}
 
 	return -1;
diff --git a/hostapd/mxl_config.c b/hostapd/mxl_config.c
index b4d112683..dd42fbe8a 100644
--- a/hostapd/mxl_config.c
+++ b/hostapd/mxl_config.c
@@ -1715,6 +1715,10 @@ int mxl_hostapd_config_fill (struct hostapd_config *conf,
 		mxl_conf->sub_band_dfs = val;
 	} else if (os_strcmp(buf, "dfs_channels_state_file_location") == 0) {
 		mxl_conf->dfs_channels_state_file = os_strdup(pos);
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+        } else if(mxl_config_check_dynamic_failsafe(conf, buf, pos)) {
+                return 1;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	} else if (os_strcmp(buf, "process_radar_slave_events") == 0) {
 		int val = atoi(pos);
 		if (!IS_VALID_BOOL_RANGE(val)) {
diff --git a/hostapd/mxl_config_proprietary.c b/hostapd/mxl_config_proprietary.c
index 96148962f..ec51404f4 100644
--- a/hostapd/mxl_config_proprietary.c
+++ b/hostapd/mxl_config_proprietary.c
@@ -22,6 +22,22 @@
 #include "ap/beacon.h"
 #include "ap/ap_drv_ops.h"
 
+int mxl_config_check_dynamic_failsafe(struct hostapd_config *conf, const char *buf, char* pos)
+{
+	struct mxl_hostapd_config *mxl_conf = &conf->mxl_conf;
+	if (os_strcmp(buf, "dynamic_failsafe") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Invalid dynamic_failsafe %d", val);
+			return 0;
+		}
+		mxl_conf->dynamic_failsafe = val;
+	} else {
+		return 0;
+	}
+	return 1;
+}
+
 int mxl_config_check_dfs_debug_chan(struct hostapd_config *conf, const char *buf, char* pos)
 {
 	struct mxl_hostapd_config *mxl_conf = &conf->mxl_conf;
@@ -447,6 +463,7 @@ memcpy_fail:
 continue_no_fail:
 #endif /* CONFIG_ACS */
 
+	mxl_conf->dynamic_failsafe = 1;
 	return 0;
 }
 
diff --git a/hostapd/mxl_ctrl_iface.c b/hostapd/mxl_ctrl_iface.c
index f16f2a9e4..a084d5e16 100644
--- a/hostapd/mxl_ctrl_iface.c
+++ b/hostapd/mxl_ctrl_iface.c
@@ -3376,6 +3376,16 @@ int mxl_hostapd_ctrl_iface_set(struct hostapd_data *hapd, char *cmd, int *ret)
 	return 1;
 }
 
+int mxl_hostapd_ctrl_iface_get(struct hostapd_data *hapd, char *cmd, char *buf, size_t buflen, int *reply_len)
+{
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if (mxl_hostapd_ctrl_iface_get_dynamic_failsafe(hapd, cmd, buf, buflen, reply_len)) {
+		return *reply_len;
+	}
+#endif
+	return 0;
+}
+
 int mxl_hostapd_ctrl_iface_req_beacon(struct hostapd_data *hapd,
 				 char *cmd, char *reply,
 				 size_t reply_size)
diff --git a/hostapd/mxl_ctrl_iface.h b/hostapd/mxl_ctrl_iface.h
index 751685422..073229852 100644
--- a/hostapd/mxl_ctrl_iface.h
+++ b/hostapd/mxl_ctrl_iface.h
@@ -29,6 +29,7 @@ int mxl_hostapd_ctrl_iface_update_mbss_beacon(struct hostapd_data *hapd);
 char * mxl_dfs_info(struct hostapd_channel_data *chan);
 int mxl_hostapd_ctrl_iface_req_beacon(struct hostapd_data *hapd, char *cmd, char *reply, size_t reply_size);
 int mxl_hostapd_ctrl_iface_set(struct hostapd_data *hapd, char *cmd, int *ret);
+int mxl_hostapd_ctrl_iface_get(struct hostapd_data *hapd, char *cmd, char *buf, size_t buflen, int *reply_len);
 int mxl_hostapd_ctrl_iface_get_power_mode(struct hostapd_iface *iface,
 					  char *buf, size_t buflen);
 int mxl_hostapd_ctrl_iface_set_power_mode(struct hostapd_iface *iface, const char *cmd,
@@ -46,5 +47,6 @@ int mxl_hostapd_ctrl_iface_receive_process_acs(struct hostapd_data *hapd,
                                               int *reply_len);
 int mxl_hostapd_ctrl_iface_check_acs(struct hostapd_iface *iface, const struct csa_settings *settings, enum chan_width bandwidth);
 int mxl_hostapd_ctrl_iface_acs_start(struct hostapd_iface *iface, enum chan_width bw);
+int mxl_hostapd_ctrl_iface_get_dynamic_failsafe(struct hostapd_data *hapd, char *cmd, char *buf, size_t buflen, int *reply_len);
 #endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #endif /* MXL_CTRL_IFACE_H */
diff --git a/hostapd/mxl_ctrl_iface_proprietary.c b/hostapd/mxl_ctrl_iface_proprietary.c
index 483ab7042..3de573258 100644
--- a/hostapd/mxl_ctrl_iface_proprietary.c
+++ b/hostapd/mxl_ctrl_iface_proprietary.c
@@ -366,3 +366,23 @@ int mxl_hostapd_ctrl_iface_acs_start(struct hostapd_iface *iface, enum chan_widt
 
 	return mxl_acs_start(iface);
 }
+
+int mxl_hostapd_ctrl_iface_get_dynamic_failsafe(struct hostapd_data *hapd, char *cmd, char *buf, size_t buflen, int *reply_len)
+{
+	int res = 0;
+	struct mxl_hostapd_config *mxl_conf = &hapd->iface->conf->mxl_conf;
+
+	if (os_strcmp(cmd, "dynamic_failsafe") == 0) {
+		res = sprintf_s(buf, buflen, "%d\n", mxl_conf->dynamic_failsafe);
+	} else if (os_strcmp(cmd, "dynamic_edca") == 0) {
+		res = sprintf_s(buf, buflen, "%d\n", mxl_conf->dynamic_edca);
+	} else {
+		return 0;
+	}
+
+	if (res <= 0)
+		res = -1;
+
+	*reply_len = res;
+	return 1;
+}
diff --git a/src/ap/mxl_common_proprietary.c b/src/ap/mxl_common_proprietary.c
new file mode 100644
index 000000000..e4f7ad46d
--- /dev/null
+++ b/src/ap/mxl_common_proprietary.c
@@ -0,0 +1,109 @@
+/******************************************************************************
+
+         Copyright (c) 2024, MaxLinear, Inc.
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "radius/radius.h"
+#include "drivers/driver.h"
+#include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
+#include "common/wpa_ctrl.h"
+#include "common/dpp.h"
+#include "common/sae.h"
+#include "common/hw_features_common.h"
+#include "crypto/random.h"
+#include "p2p/p2p.h"
+#include "wps/wps.h"
+#include "fst/fst.h"
+#include "wnm_ap.h"
+#include "hostapd.h"
+#include "ieee802_11.h"
+#include "ieee802_11_auth.h"
+#include "sta_info.h"
+#include "accounting.h"
+#include "tkip_countermeasures.h"
+#include "ieee802_1x.h"
+#include "wpa_auth.h"
+#include "wps_hostapd.h"
+#include "ap_drv_ops.h"
+#include "ap_config.h"
+#include "ap_mlme.h"
+#include "hw_features.h"
+#include "dfs.h"
+#include "beacon.h"
+#include "mbo_ap.h"
+#include "dpp_hostapd.h"
+#include "fils_hlp.h"
+#include "neighbor_db.h"
+#include "common/linux_bridge.h"
+#include "drivers/linux_ioctl.h"
+#include "mxl_acs.h"
+#include "mxl_dfs_common.h"
+
+struct hostapd_channel_data *
+mxl_dfs_get_channel_dynamic_failsafe(struct hostapd_iface *iface,
+                                     int *secondary_channel,
+                                     u8 *vht_oper_centr_freq_seg0_idx,
+                                     u8 *vht_oper_centr_freq_seg1_idx,
+                                     bool skip_usable,
+                                     struct hostapd_freq_params* freq_params)
+{
+#ifdef CONFIG_ACS
+	int primary_freq;
+	struct hostapd_channel_data *channel;
+	struct acs_candidate_table *failsafe;
+	failsafe = mxl_acs_get_failsafe_channel(iface, skip_usable);
+	int cf1;
+
+	if (!failsafe)
+		return NULL;
+
+	wpa_printf(MSG_DEBUG, "Dynamic failsafe: Got candidate %d, sec %d, freq %d, bw %d",
+		failsafe->primary, failsafe->secondary, failsafe->freq, failsafe->width);
+
+	primary_freq = hostapd_chan_to_freq(failsafe->primary, false);
+	channel = mxl_hostapd_hw_get_channel_data(iface, primary_freq);
+	if (!channel) {
+		wpa_printf(MSG_ERROR, "DFS dynamic failsafe: Failed to get channel data for channel %d",
+			failsafe->primary);
+		return NULL;
+	}
+
+	cf1 = failsafe->freq + failsafe->width / 2 - 10;
+	ieee80211_freq_to_chan(cf1, vht_oper_centr_freq_seg0_idx);
+	*secondary_channel = mxl_hostapd_get_secondary_offset(channel->chan, failsafe->width, *vht_oper_centr_freq_seg0_idx);
+	hostapd_set_oper_chwidth(iface->conf, mxl_get_oper_width(failsafe->width));
+
+	if (freq_params) {
+		memset(freq_params, 0, sizeof(*freq_params));
+		freq_params->channel = channel->chan;
+		freq_params->freq = primary_freq;
+
+		/* center_freq = low_freq + width / 2 - 10 */
+		freq_params->center_freq1 = cf1;
+		freq_params->center_freq2 = 0; /* 80+80 Not supported */
+		freq_params->bandwidth = failsafe->width;
+
+		if (iface->conf->ieee80211n)
+			freq_params->ht_enabled = 1;
+		if (iface->conf->ieee80211ac)
+			freq_params->vht_enabled = 1;
+
+		mxl_hostapd_set_conf_from_freq_params(iface, freq_params);
+		*vht_oper_centr_freq_seg0_idx = hostapd_get_oper_centr_freq_seg0_idx(iface->conf);
+		*vht_oper_centr_freq_seg1_idx = hostapd_get_oper_centr_freq_seg1_idx(iface->conf);
+	}
+
+	return channel;
+#else
+	return NULL;
+#endif
+}
diff --git a/src/ap/mxl_config.h b/src/ap/mxl_config.h
index 39916336b..ce462ba9a 100644
--- a/src/ap/mxl_config.h
+++ b/src/ap/mxl_config.h
@@ -49,6 +49,7 @@ void mxl_hostapd_config_fill_acs(struct hostapd_config *conf, char *pos);
 void mxl_hostapd_config_free_acs(struct hostapd_config *conf);
 int mxl_hostapd_config_check_acs(struct hostapd_config *conf, int full_config);
 int mxl_config_check_dfs_debug_chan(struct hostapd_config *conf, const char *buf, char* pos);
+int mxl_config_check_dynamic_failsafe(struct hostapd_config *conf, const char *buf, char* pos);
 #endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 #define CCA_TH_SIZE 5
@@ -387,6 +388,7 @@ struct mxl_hostapd_config {
 	int acs_exclude_opclass_ch_count;
 #endif /* CONFIG_ACS */
 	int dfs_debug_chan;
+	int dynamic_failsafe;
 #endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 
 	int allow_scan_during_cac;
diff --git a/src/ap/mxl_dfs_common.c b/src/ap/mxl_dfs_common.c
index 36ee9f13f..c1e5f41a9 100644
--- a/src/ap/mxl_dfs_common.c
+++ b/src/ap/mxl_dfs_common.c
@@ -128,6 +128,20 @@ mxl_dfs_get_valid_channel_failsafe(struct hostapd_iface *iface,
 {
 	struct hostapd_channel_data *channel = NULL;
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	if (iface->conf->mxl_conf.dynamic_failsafe) {
+		channel = mxl_dfs_get_channel_dynamic_failsafe(iface,
+							       secondary_channel,
+							       vht_oper_centr_freq_seg0_idx,
+							       vht_oper_centr_freq_seg1_idx,
+							       skip_usable,
+							       NULL);
+	}
+
+	if (channel)
+		return channel;
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	if (0 != iface->mxl_iface.failsafe.freq) {
 		wpa_printf(MSG_DEBUG, "Failsafe channel: switching to fixed fail-safe channel %d", iface->mxl_iface.failsafe.freq);
 		channel = mxl_dfs_get_channel_fixed_failsafe(iface, secondary_channel,
@@ -140,6 +154,9 @@ mxl_dfs_get_valid_channel_failsafe(struct hostapd_iface *iface,
 
 bool mxl_dfs_is_failsafe_enabled(struct hostapd_iface *iface)
 {
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	return iface->conf->mxl_conf.dynamic_failsafe || (0 != iface->mxl_iface.failsafe.freq);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 	return (0 != iface->mxl_iface.failsafe.freq);
 }
 
@@ -175,9 +192,11 @@ void mxl_hostapd_dfs_cac_restart(struct hostapd_iface *iface)
 #ifdef CONFIG_ACS
 #ifdef CONFIG_VENDOR_MXL_PROPRIETARY
 		if (!mxl_dfs_is_failsafe_enabled(iface) && iface->conf->mxl_conf.acs_init_done)
+#else
+		if (!mxl_dfs_is_failsafe_enabled(iface))
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 			mxl_hostapd_handle_radar(iface, 0, 0);
 		else
-#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 #endif
 			mxl_hostapd_dfs_start_channel_switch(iface);
 		return;
diff --git a/src/ap/mxl_dfs_common.h b/src/ap/mxl_dfs_common.h
index 0eadd3ea4..d897ebc62 100644
--- a/src/ap/mxl_dfs_common.h
+++ b/src/ap/mxl_dfs_common.h
@@ -75,6 +75,12 @@ int mxl_hostapd_dfs_start_cac(struct hostapd_iface *iface, int freq,
 			      int ht_enabled, int chan_offset, int chan_width,
 			      int cf1, int cf2);
 int mxl_dfs_check_chans_available(struct hostapd_iface *iface, int start_chan_idx, int n_chans);
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+struct hostapd_channel_data *
+mxl_dfs_get_channel_dynamic_failsafe(struct hostapd_iface *iface, int *secondary_channel,
+				     u8 *vht_oper_centr_freq_seg0_idx, u8 *vht_oper_centr_freq_seg1_idx,
+				     bool skip_usable, struct hostapd_freq_params* freq_params);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
 void mxl_dfs_cut_cw_by_half(struct hostapd_iface *iface, bool backup);
 void mxl_dfs_restore_original_cw(struct hostapd_iface *iface);
 
diff --git a/src/ap/mxl_zwdfs.c b/src/ap/mxl_zwdfs.c
index 34c6dfc89..1cda4e3b6 100644
--- a/src/ap/mxl_zwdfs.c
+++ b/src/ap/mxl_zwdfs.c
@@ -301,6 +301,10 @@ int mxl_hostapd_set_zwdfs_antenna(struct hostapd_data *hapd, int enable)
 		return -1;
 	}
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	iface->conf->mxl_conf.dynamic_failsafe = 0; /* turn off dynamic failsafe */
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
 	/* set failsafe channel to channel retreived by set_first_non_dfs_channel().
 	 * this + disabling dynamic failsafe, will make sure zwdfs radio will not
 	 * jump to another DFS channel upon radar hit
@@ -604,6 +608,9 @@ void mxl_hostapd_zwdfs_cac_on_radar(struct hostapd_iface *iface, struct csa_sett
 	int err = -1;
 	struct csa_settings new_chan_settings;
 	struct hostapd_channel_data *channel = NULL;
+	int secondary_channel;
+	u8 vht_oper_centr_freq_seg0_idx;
+	u8 vht_oper_centr_freq_seg1_idx;
 
 	/* If the new channel is a static failsafe channel, then no need for ZWDFS and
 	 * directly set the channel to operational vaps.
@@ -644,6 +651,19 @@ void mxl_hostapd_zwdfs_cac_on_radar(struct hostapd_iface *iface, struct csa_sett
 		goto fail;
 	}
 
+#ifdef CONFIG_VENDOR_MXL_PROPRIETARY
+	/* Until ZWDFS CAC gets completed for the new best channel, check if we can
+	 * switch operational channel to best available channel.
+	 */
+	channel = mxl_dfs_get_channel_dynamic_failsafe(iface,
+						       &secondary_channel,
+						       &vht_oper_centr_freq_seg0_idx,
+						       &vht_oper_centr_freq_seg1_idx,
+						       true,
+						       &settings->freq_params);
+#endif /* CONFIG_VENDOR_MXL_PROPRIETARY */
+
+
 	if (!channel) {
 		/* Try to set first non-DFS channel to the operational vaps until ZWDFS CAC completed. */
 		if (!mxl_set_first_non_dfs_channel(iface)) {
-- 
2.43.0

