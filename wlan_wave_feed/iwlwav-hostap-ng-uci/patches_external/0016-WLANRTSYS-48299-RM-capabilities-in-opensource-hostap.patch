From e0f27cca2cf2154c693f0e951c6c83da6fb85539 Mon Sep 17 00:00:00 2001
From: Jurijs Soloveckis <jsoloveckis@maxlinear.com>
Date: Thu, 2 Feb 2023 15:33:24 +0100
Subject: [PATCH] WLANRTSYS-48299: RM capabilities in opensource hostapd: full
 feature

1) rrm: beacon report protocol - request, report and self report

    Add beacon request via RRM.
    The Beacon request/report pair enables a STA to request from another STA a
    list of APs whose beacons it can receive on a specified channel or channels.
    The Beacon report request/response provides a means for a requesting STA to
    obtain received beacon, probe response, and measurement pilot information
    from a responding STA.

    To enable the support of beacon report measurement from the conf file:
    passive: rrm_beacon_report_passive=1
    table:   rrm_beacon_report_table=1
    active measurements are not supported by the AP.

    To enable the support of manipulate the beacon report measurements
    from conf file:
    rrm_manipulate_measurement=1
    if this flag is enabled, then upon beacon report  measurement request
    from the STA, the AP will make the measurements and notify the "AP-Manager"
    instead of sending the response.

    Request from AP to STA: (cli_command)
    req_beacon <dst> <num_of_repetitions> <measurement_req_mode> <op_class>
    <channel> <rand_int> <duration> <mode-"active"/"passive"/"table"> <bssid>
    [beacon_rep=<0-10>,<0-255>]
    [rep_detail=<0-2>]
    [ssid=<ssid>] [rep_detail=<0-2>] [rep_cond=<0-10>,<0-255>]
    [ap_ch_report=[<channel 1>[,<channel 2>[..,<channel N>]]]
    [req_elements=[<element 1>[,<element 2>[..,<element N>]]]
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

    Response from STA to AP: (notification)
    RRM-BEACON-REP-RECEIVED <ifname> <sta_mac_addr> dialog_token=<dialog_token>
    measurement_rep_mode=<measurement_rep_mode> op_class=<op_class>
    channel=<channel> start_time=<start_time> duration=<duration>
    frame_info=<frame_info> rcpi=<rcpi> rsni=<rsni> bssid=<bssid>
    antenna_id=<ant_id> parent_tsf=<tsf>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]
    [timestamp=<time_stamp> beacon_int=<beacon_int>]
    all the below data is in HEX:
    [capab_info=<capab_info> ssid=<ssid> rm_capa=<rm_capa>
    vendor_specific=<vendor_specific> rsn_info=<rsn_info>]

    Request from STA to AP: (notification)
    RRM-BEACON-REP-REQUEST-RECEIVED <ifname> <sta_mac_addr>
    dialog_token=<dialog_token> measurement_token=<measurement_token>
    measurement_rep_mode=<measurement_rep_mode> op_class=<op_class>
    channel=<channel> start_time=<start_time> duration=<duration>
    frame_info=<frame_info> rcpi=<rcpi> rsni=<rsni> bssid=<bssid>
    antenna_id=<ant_id> parent_tsf=<tsf>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]
    [timestamp=<time_stamp> beacon_int=<beacon_int>]
    all the below data is in HEX:
    [capab_info=<capab_info> ssid=<ssid> rm_capa=<rm_capa>
    vendor_specific=<vendor_specific> rsn_info=<rsn_info>]

    Response from AP to STA: (cli_command)
    report_beacon <dst> <dialog_token> <measurement_token>
    <measurement_rep_mode> <op_class> <channel> <start_time>
    <duration> <frame_info> <rcpi> <rsni> <bssid> <ant_id> <tsf>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]
    [rep_frame_body=<length>,<frame_body hexdump>]

    Self beacon request: (cli_command)
    req_self_beacon <rand_int> <duration>
    <mode-"active"/"passive"/"table">

    Self beacon respone: (notification)
    RRM-SELF-BEACON-REP-RECEIVED <ifname> <sta_mac_addr>
    measurement_rep_mode=<measurement_rep_mode> op_class=<op_class>
    channel=<channel> start_time=<start_time> duration=<duration>
    frame_info=<frame_info> rcpi=<rcpi> rsni=<rsni> bssid=<bssid>
    antenna_id=<ant_id> parent_tsf=<tsf>

    increased the receiving pending buf size from 256 to 512
    because the beacon report notifications was too long.

    the measurement of the beacon report could be done only on the
    current channel that the AP works.

    arguments description:

    destination address (dst):
    MAC address of an associated STA.

    operating class (op_class):
    If the Wide Bandwidth Channel Switch subelement is not included,
    the Operating Class field indicates the operating class that identifies
    the channel set for which the measurement request applies. The Country,
    Operating Class, and Channel Number fields together specify the channel
    frequency and spacing for which the measurement request applies.
    the operating class value depends on the regulatory domain (1-255).
    Also, in case the Wide Bandwidth Channel Switch subelement is included,
    the operating class is disregarded.

    channel:
    for operating classes that encompass a primary channel but do not identify
    the location of the primary channel, the Channel Number field value is
    either 0 or 255; otherwise, the Channel Number field value is 0,255, or
    the channel number for which the measurement request applies.

    Randomization Interval (rand_int):
    Randomization Interval specifies the upper bound of the random delay to
    be used prior to making the measurement, expressed in units of TUs
    (0..65535).

    duration:
    beacon report request:
    the Measurement Duration field is set to the preferred or mandatory
    duration of the requested measurement, expressed in units of TUs
    (0..65535).
    beacon report response:
    Measurement Duration is set to the duration over which the Beacon report
    was measured, expressed in units of TUs.

    mode:
    Measurement Mode indicates the mode to be used for the measurement.
    valid values are: "passive", "active" or "table".

    bssid:
    The BSSID field indicates the BSSID of the BSS(s) for which a beacon
    report is requested. When requesting beacon reports for all BSSs on the
    channel, the BSSID field contains the wildcard BSSID (ff:ff:ff:ff:ff:ff),
    otherwise the BSSID field contains a specific BSSID for a single BSS.

    ssid:
    The SSID subelement indicates the ESS(s) or IBSS(s) for which a beacon
    report is requested. When SSID is not included in a Beacon request, the
    default wildcard SSID is used; otherwise the SSID is included in the
    Beacon request and contains a specific SSID for a single ESS or IBSS.
    The wildcard SSID is used to represent all possible SSIDs.

    report detail (rep_detail):
    defines the level of detail per AP to be reported to the requesting STA.
    0: No fixed-length fields or elements.
    1: All fixed-length fields and any requested elements in the Request
    element if present.
    2: All fixed-length fields and elements (default, used when Reporting
    Detail subelement is not included in a Beacon request).

    report condition (rep_cond):
    The Beacon Reporting subelement indicates the condition for issuing a
    Beacon report. The Beacon Reporting subelement is optionally present in
    a Beacon request for repeated measurements; otherwise it is not present.
    argument includ 2 values: condition (0-10), and threshold.
    For Reporting Conditions 1 and 2, the threshold value is a logarithmic
    function of the received signal power, as defined in the RCPI measurement
    subclause for the associated PHY Type. For Reporting Conditions 3 and 4,
    the threshold value is a logarithmic function of the signal-to-noise
    ratio, as described in RSNI element. For Reporting Conditions 5 to 10,
    the offset value is an 8-bit 2s complement integer in units of 0.5 dBm.

    ap channel report (ap_ch_report):
    The AP Channel Report element contains a list of channels where a STA is
    likely to find an AP.
    the argument format is: ap_ch_report=<ch1>[,<ch2>..<ch N>]

    request elements (req_elements):
    The Requested Element IDs are the list of elements that are requested to
    be included in the Probe Response or Information Response frame. The
    Requested Element IDs are listed in order of increasing element ID.
    the argument format is: req_elements=<e1>[,<e2>,..<e N>]

    measurement start time (start_time):
    actual Measurement Start Time is set to the value of the measuring STA
    TSF timer at the time the measurement started.
    represensted as 64 bit deciaml format.

    frame info (frame_info):
    Bits 0-6: Condensed PHY Type indicates the physical medium type on which
    the Beacon, Measurement Pilot, or Probe Response frame being reported was
    received. It has an integer value between 0 and 127 coded according to
    the value of the PHY type.
    Bit 7: Reported Frame Type indicates the type of frame reported. A value
    of 0 indicates a Beacon or Probe Response frame; a value of 1 indicates a
    Measurement Pilot frame.

    rcpi:
    RCPI indicates the received channel power of the Beacon, Measurement
    Pilot, or Probe Response frame, which is a logarithmic function of the
    received signal power, as defined in the RCPI measurement subclause for
    the indicated PHY Type.
    represensted as 8 bit hex format.

    rsni:
    RSNI indicates the received signal-to-noise indication for the Beacon,
    Measurement Pilot, or Probe Response frame.
    represensted as 8 bit hex format.

    antenna id (antenna_id):
    The Antenna ID field contains the identifying number for the antenna(s)
    used for this measurement.
    represensted as 8 bit hex format.

    parent tsf (parent_tsf):
    The Parent TSF field contains the lower 4 octets of the measuring STA
    TSF timer value at the start of reception of the first octet of the
    timestamp field of the reported Beacon, Measurement Pilot, or Probe
    Response frame at the time the Beacon, Measurement Pilot, or Probe
    Response frame being reported was received.
    represensted as 32 bit hex format.

2) rrm: link measurement protocol - request and response

    To enable the support of link measurement from the conf file:
    rrm_link_measurement=1

    To enable the support of manipulate the link measurements from conf file:
    rrm_manipulate_measurement=1
    if this flag is enabled, then upon link measurement request from the STA,
    the AP will make the measurements and notify the "AP-Manager"
    instead of sending the response.

    Request from AP to STA:
    req_link_measurement <dst>

    Response from STA to AP:
    RRM-LINK-MEASUREMENT-RECEIVED <sta_mac_addr>
    tpc_report=<transmit_power>,<link_margin>
    rx_ant_id=<rx_ant_id> tx_ant_id=<tx_ant_id> rcpi=<rcpi> rsni=<rsni>
    [dmg_link_margin=<activity>,<mcs>,<link_margin>,<snr>,<reference_timestamp>]
    [dmg_link_adapt_ack=<activity>,<reference_timestamp>]

    Request from STA to AP:
    RRM-LINK-MEASUREMENT-REQUEST-RECEIVED <sta_mac_addr>
    dialog_token=<dialog_token> tpc_report=<transmit_power>,<link_margin>
    rx_ant_id=<rx_ant_id> tx_ant_id=<tx_ant_id> rcpi=<rcpi> rsni=<rsni>
    [dmg_link_margin=<activity>,<mcs>,<link_margin>,<snr>,<reference_timestamp>]
    [dmg_link_adapt_ack=<activity>,<reference_timestamp>]

    Response from AP to STA:
    link_measurement_report <dst> <dialog_token> <rx_ant_id> <tx_ant_id>
    <rcpi> <rsni> tpc_report=<transmit_power>,<link_margin>
    [dmg_link_margin=<activity>,<mcs>,<link_margin>,<snr>,<reference_timestamp>]
    [dmg_link_adapt_ack=<activity>,<reference_timestamp>]

3) rrm: channel load protocol - request and response

    To enable the support of channel load measurement from the conf file:
    rrm_channel_load=1

    To enable the support of manipulate the link measurements from conf file:
    rrm_manipulate_measurement=1
    if this flag is enabled, then upon channel load measurement request
    from the STA, the AP will make the measurements and notify the "AP-Manager"
    instead of sending the response.

    Request from AP to STA: (cli_command)
    req_channel_load <dst> <num_of_repetitions> <measurement_req_mode>
    <op_class> <channel> <rand_int> <duration> [ch_load_rep=<0-2>,<0-255>]
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

    Response from STA to AP: (notification)
    RRM-CHANNEL-LOAD-RECEIVED <ifname> <sta_mac_addr>
    measurement_rep_mode=<measurement_rep_mode> op_class=<op_class>
    channel=<channel> start_time=<start_time> duration=<duration>
    channel_load=<channel_load>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

    Request from STA to AP: (notification)
    RRM-CHANNEL-LOAD-REQUEST-RECEIVED <ifname> <sta_mac_addr>
    dialog_token=<dialog_token> measurement_token=<measurement_token>
    measurement_rep_mode=<measurement_rep_mode> op_class=<op_class>
    channel=<channel> start_time=<start_time> duration=<duration>
    channel_load=<channel_load>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

    Response from AP to STA: (cli_command)
    report_channel_load <dst> <dialog_token> <measurement_token>
    <measurement_rep_mode> <op_class> <channel> <start_time> <duration>
    <channel_load>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

4) rrm: noise histogram protocol - request and response

    To enable the support of noise histogram measurement from the conf file:
    rrm_noise_histogram=1

    To enable the support of manipulate the noise histogram measurements
    from conf file:
    rrm_manipulate_measurement=1
    if this flag is enabled, then upon noise histogram  measurement request
    from the STA, the AP will make the measurements and notify the "AP-Manager"
    instead of sending the response.

    Request from AP to STA: (cli_command)
    req_noise_histogram <dst> <num_of_repetitions> <measurement_req_mode>
    <op_class> <channel> <rand_int> <duration>
    [noise_histogram_rep=<0-2>,<0-255>]
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

    Response from STA to AP: (notification)
    RRM-NOISE-HISTOGRAM-RECEIVED <ifname> <sta_mac_addr>
    measurement_rep_mode=<measurement_rep_mode> op_class=<op_class>
    channel=<channel> start_time=<start_time> duration=<duration>
    antenna_id=<ant_id> anpi=<anpi>
    ipi=<11 octets with comma delimiter between each one>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

    Request from STA to AP: (notification)
    RRM-NOISE-HISTOGRAM-REQUEST-RECEIVED <ifname> <sta_mac_addr>
    dialog_token=<dialog_token> measurement_token=<measurement_token>
    measurement_rep_mode=<measurement_rep_mode> op_class=<op_class>
    channel=<channel> start_time=<start_time> duration=<duration>
    antenna_id=<ant_id> anpi=<anpi>
    ipi=<11 octets with comma delimiter between each one>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

    Response from AP to STA: (cli_command)
    report_noise_histogram <dst> <dialog_token> <measurement_token>
    <measurement_rep_mode> <op_class> <channel> <start_time> <duration>
    <ant_id> <anpi> <ipi(no11 octets with comma delimiter between each one)>
    [wide_band_ch_switch=<new channel width>,
    <new channel center frequency segment 0>,
    <new channel center frequency segment 1>]

5) rrm: sta statistics protocol - request and response

    To enable the support of STA statistics from the conf file:
    rrm_sta_statistics=1

    To enable the support of manipulate the STA statistics from conf file:
    rrm_manipulate_measurement=1
    if this flag is enabled, then upon STA statistics request from the STA,
    the AP will make the measurements and notify the "AP-Manager"
    instead of sending the response.

    Request from AP to STA:
    req_sta_statistics <dst> <num_of_repetitions> <measurement_req_mode>
    <peer_mac_addr> <rand_int> <duration> <group_identity>
    [trig_rep_sta_counters=<measurement_count>,<trigger_timeout>,
    <sta_counter_trigger_condition>[,<dot11FailedCountThreshold>,
    <dot11FCSErrorCountThreshold>,<dot11MultipleRetryCountThreshold>,
    <dot11FrameDuplicateCountThreshold>,<dot11RTSFailureCountThreshold>,
    <dot11AckFailureCountThreshold>,<dot11RetryCountThreshold>]]
    [trig_rep_qos_sta_counters=<measurement_count>,<trigger_timeout>,
    <qos_sta_counter_trigger_condition>[,<dot11QoSFailedCountThreshold>,
    <dot11QoSRetryCountThreshold>,<dot11QoSMultipleRetryCountThreshold>,
    <dot11QoSFrameDuplicateCountThreshold>,<dot11QoSRTSCountFailureThreshold>,
    <dot11QoSAckFailureCountThreshold>,<dot11QoSDiscardedCountThreshold>]]
    [trig_rep_rsna_counters=<measurement_count>,<trigger_timeout>,
    <rsna_counter_trigger_condition>[,<dot11RSNAStatsCMACICVErrorsThreshold>,
    <dot11RSNAStatsCMACReplaysThreshold>,
    <dot11RSNAStatsRobustMgmtCCMPReplaysThreshold>,
    <dot11RSNAStatsTKIPICVErrorsThreshold>,
    <dot11RSNAStatsTKIPReplaysThreshold>,
    <dot11RSNAStatsCCMPDecryptErrorsThreshold>,
    <dot11RSNAStatsCCMPReplaysThreshold>]]

    Response from STA to AP:
    RRM-STA-STATISTICS-RECEIVED <ifname> <sta_mac_addr>
    measurement_rep_mode=<measurement_rep_mode> duration=<duration>
    group_identity=<group_identity>
    statistics_group_data=<statistics_group_data
    (different data for each group identity,
    4 octets counters with commas between them)>
    [rep_reason=<rep_reason_data(1 byte of bitmap data -
    different data for each group identity)>]

    Request from AP to STA:
    RRM-STA-STATISTICS-REQUEST-RECEIVED <ifname> <sta_mac_addr>
    dialog_token=<dialog_token> measurement_token=<measurement_token>
    measurement_rep_mode=<measurement_rep_mode> duration=<duration>
    group_identity=<group_identity>
    statistics_group_data=<statistics_group_data
    (different data for each group identity,
    4 octets counters with commas between them)>
    [rep_reason=<rep_reason_data(1 byte of bitmap data -
    different data for each group identity)>]

    Response from AP to STA:
    report_sta_statistics <dst> <dialog_token> <measurement_token>
    <measurement_rep_mode> <duration> <group_identity>
    <statistics_group_data(different data for each group identity,
    4 octets counters with commas between them)>
    [rep_reason=<rep_reason_data(1 byte of bitmap data -
    different data for each group identity)>]
---
 hostapd/Makefile                   |    1 +
 hostapd/ctrl_iface.c               | 1208 +++++++++++++-
 hostapd/hostapd_cli.c              |  394 ++++-
 hostapd/mxl_ctrl_iface.c           | 2438 ++++++++++++++++++++++++++++
 hostapd/mxl_ctrl_iface.h           |    1 +
 hostapd/mxl_hostapd_cli.c          |  129 ++
 hostapd/mxl_hostapd_cli.h          |   34 +
 src/ap/ap_drv_ops.c                |    5 +-
 src/ap/ap_drv_ops.h                |   38 +-
 src/ap/beacon.c                    |   10 +
 src/ap/beacon.h                    |    1 +
 src/ap/ctrl_iface_ap.c             |   76 +-
 src/ap/ctrl_iface_ap.h             |    4 +-
 src/ap/dfs.c                       |    3 +-
 src/ap/drv_callbacks.c             |   45 +-
 src/ap/hostapd.c                   |   89 +-
 src/ap/hostapd.h                   |    7 +-
 src/ap/hw_features.c               |   51 +
 src/ap/hw_features.h               |   13 +
 src/ap/ieee802_11.c                |   10 +-
 src/ap/ieee802_11_auth.h           |    3 +
 src/ap/mxl_dfs_common.c            |    2 +-
 src/ap/mxl_dfs_common.h            |    2 +-
 src/ap/mxl_hostapd.c               |   10 +
 src/ap/mxl_hostapd.h               |   10 +
 src/ap/mxl_rrm.c                   | 2113 ++++++++++++++++++++++++
 src/ap/mxl_rrm.h                   |   90 +
 src/ap/rrm.c                       |   35 +
 src/ap/sta_info.c                  |  138 +-
 src/ap/sta_info.h                  |    2 +
 src/ap/utils.c                     |   86 +
 src/common/cli.h                   |    4 +
 src/common/ieee802_11_defs.h       |    1 +
 src/common/mxl_ieee802_11_defs.h   |   67 +-
 src/common/mxl_wpa_ctrl.h          |   16 +
 src/common/vendor_cmds_copy.h      |  124 ++
 src/common/wpa_ctrl.h              |    3 +
 src/drivers/driver.h               |   55 +
 src/drivers/driver_common.c        |    1 +
 src/drivers/driver_nl80211.c       |   91 +-
 src/drivers/driver_nl80211_event.c |   23 +
 src/utils/mxl_common.h             |    4 +
 wpa_supplicant/ap.c                |    2 +-
 43 files changed, 7370 insertions(+), 69 deletions(-)
 create mode 100644 src/ap/mxl_rrm.c
 create mode 100644 src/ap/mxl_rrm.h

diff --git a/hostapd/Makefile b/hostapd/Makefile
index 9370b4b5c..944e399ae 100644
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -371,6 +371,7 @@ OBJS += ../src/ap/mxl_sub_band_dfs.o
 OBJS += ../src/ap/mxl_dfs_file.o
 OBJS += ../src/ap/mxl_zwdfs.o
 OBJS += ../src/ap/mxl_softblock.o
+OBJS += ../src/ap/mxl_rrm.o
 endif
 
 include ../src/drivers/drivers.mak
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 218018e81..98866b91d 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -68,6 +68,13 @@
 #include "fst/fst_ctrl_iface.h"
 #include "config_file.h"
 #include "ctrl_iface.h"
+#ifdef CONFIG_VENDOR_MXL
+#include "mxl_ctrl_iface.h"
+#include "common/mxl_ieee802_11_common.h"
+#include "ap/ieee802_11_auth.h"
+#include "ap/mxl_dfs_common.h"
+#endif /* CONFIG_VENDOR_MXL */
+#include "ap/hw_features.h"
 
 
 #define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
@@ -2563,11 +2570,21 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 	unsigned int i;
 	int bandwidth;
 	u8 chan;
+	int tx_ant_mask = -1, rx_ant_mask = -1;
+	char *str, *pos2;
+	bool switch_type_scan = false;
 
 	ret = hostapd_parse_csa_settings(pos, &settings);
 	if (ret)
 		return ret;
 
+	if (os_strstr(pos, " auto-ht")) {
+		settings.freq_params.ht_enabled = iface->conf->ieee80211n;
+		settings.freq_params.vht_enabled = iface->conf->ieee80211ac;
+		settings.freq_params.he_enabled = iface->conf->ieee80211ax;
+		settings.freq_params.eht_enabled = iface->conf->ieee80211be;
+	}
+
 	ret = hostapd_ctrl_check_freq_params(&settings.freq_params,
 					     settings.punct_bitmap);
 	if (ret) {
@@ -2576,6 +2593,47 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 		return ret;
 	}
 
+	str = os_strstr(pos, "tx_ant_mask=");
+	if (str) {
+		str += sizeof("tx_ant_mask=") - 1;
+		tx_ant_mask = strtol(str, &pos2, 10);
+		if (str == pos2 || tx_ant_mask < 0) {
+			wpa_printf(MSG_ERROR, "chan_switch: invalid tx_ant_mask provided");
+			return -1;
+		}
+	}
+
+	str = os_strstr(pos, "rx_ant_mask=");
+	if (str) {
+		str += sizeof("rx_ant_mask=") - 1;
+		rx_ant_mask = strtol(str, &pos2, 10);
+		if (str == pos2 || rx_ant_mask < 0) {
+			wpa_printf(MSG_ERROR, "chan_switch: invalid rx_ant_mask provided");
+			return -1;
+		}
+	}
+
+	if ((tx_ant_mask >= 0 && rx_ant_mask < 0) || (rx_ant_mask >= 0 && tx_ant_mask < 0)) {
+		wpa_printf(MSG_ERROR, "chan_switch: changing only TX or RX "
+				      "antenna mask is not possible");
+		return -1;
+	}
+
+	str = os_strstr(pos, "switch_type=");
+	if (str) {
+		str += sizeof("switch_type=") - 1;
+		if (!strncmp(str, "scan", sizeof("scan") - 1))
+			switch_type_scan = true;
+	}
+
+	if (tx_ant_mask >= 0) {
+		ret = mxl_hostapd_drv_set_antenna(iface, tx_ant_mask, rx_ant_mask);
+		if (ret < 0) {
+			wpa_printf(MSG_ERROR, "chan_switch: setting antenna mask failed: %s",
+			strerror(errno));
+		}
+	}
+
 	switch (settings.freq_params.bandwidth) {
 	case 40:
 		bandwidth = CHAN_WIDTH_40;
@@ -2612,6 +2670,8 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 	if (iface->cac_started)
 		dfs_range++;
 #endif /* CONFIG_VENDOR_MXL */
+
+	iface->block_tx = false;
 	if (dfs_range) {
 		ret = ieee80211_freq_to_chan(settings.freq_params.freq, &chan);
 		if (ret == NUM_HOSTAPD_MODES) {
@@ -2637,6 +2697,8 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 			   settings.freq_params.center_freq1);
 
 		/* Perform CAC and switch channel */
+		if (!iface->cac_started && switch_type_scan)
+			iface->block_tx = true;
 		hostapd_switch_channel_fallback(iface, &settings.freq_params);
 		return 0;
 	}
@@ -3099,6 +3161,11 @@ static int hostapd_ctrl_iface_req_beacon(struct hostapd_data *hapd,
 	int ret;
 	u8 req_mode = 0;
 
+#ifdef CONFIG_VENDOR_MXL
+	if (os_strstr(cmd, "req_mode=") == NULL)
+		return mxl_hostapd_ctrl_iface_req_beacon(hapd, (char*)cmd, reply, reply_size);
+#endif /* CONFIG_VENDOR_MXL */
+
 	if (hwaddr_aton(cmd, addr))
 		return -1;
 	pos = os_strchr(cmd, ' ');
@@ -3410,6 +3477,1049 @@ static int hostapd_ctrl_iface_link_remove(struct hostapd_data *hapd, char *cmd,
 #endif /* CONFIG_IEEE80211BE */
 
 
+static int hostapd_ctrl_iface_deny_mac(struct hostapd_data *hapd, const char *cmd)
+{
+	const char *pos;
+	struct hostapd_iface *iface = hapd->iface;
+	u8 remove = 0;
+	int ret, i, status;
+	struct multi_ap_blacklist entry;
+
+	os_memset(&entry, 0, sizeof(entry));
+	if (hwaddr_aton(cmd, entry.addr))
+		return -1;
+
+	pos = os_strchr(cmd, ' ');
+	if (pos) {
+		pos++;
+		if (os_strcmp(pos, "1") == 0)
+			remove = 1;
+	}
+
+	pos = os_strstr(cmd, "reject_sta=");
+	if (pos) {
+		pos += sizeof("reject_sta=") - 1;
+		status = atoi(pos);
+		if (status < 0) {
+			wpa_printf(MSG_ERROR, "deny_mac: invalid reject status code");
+			return -1;
+		}
+		entry.status = status;
+	}
+
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *bss = iface->bss[i];
+
+		ret = mxl_ieee802_11_multi_ap_set_deny_mac(bss, &entry, remove);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int hostapd_ctrl_iface_sta_steer(struct hostapd_data *hapd, const char *cmd)
+{
+	u8 sta_addr[ETH_ALEN], bssid[ETH_ALEN];
+	const char *pos, *btm_parameters = NULL;
+	struct hostapd_iface *iface = hapd->iface;
+	struct sta_info *sta = NULL;
+	int ret = 0, i, status;
+	errno_t err;
+	struct multi_ap_blacklist entry;
+
+	os_memset(&entry, 0, sizeof(entry));
+	if (hwaddr_aton(cmd, sta_addr) || is_zero_ether_addr(sta_addr)) {
+		wpa_printf(MSG_DEBUG, "sta_steer: invalid station MAC Address.");
+		return -1;
+	}
+
+	os_memset(bssid, 0, sizeof(bssid));
+	pos = os_strchr(cmd, ' ');
+	if (pos && (*(pos + 1) != '\0')) {
+		pos++;
+		if (hwaddr_aton(pos, bssid)) {
+			btm_parameters = pos;
+		} else {
+			btm_parameters = os_strchr(pos + 1, ' ');
+		}
+	}
+
+	pos = os_strstr(cmd, "reject_sta=");
+	if (pos) {
+		pos += sizeof("reject_sta=") - 1;
+		status = atoi(pos);
+		if (status < 0) {
+			wpa_printf(MSG_ERROR, "sta_steer: invalid reject status code");
+			return -1;
+		}
+		entry.status = status;
+	}
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], sta_addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+#if 0
+	if (!sta || !sta->btm_supported) {
+#else
+	if (!sta) {
+		UNUSED_VAR(btm_parameters);
+#endif
+		/*Station is not associated or does not support BSS Transition Management.
+		 Use black list mechanism .*/
+
+		wpa_printf(MSG_DEBUG,
+				"Steer STA " MACSTR " , station is not associated to BSS "
+				"or does not support BTM.", MAC2STR(sta_addr));
+
+		err = memcpy_s(entry.addr, sizeof(entry.addr), sta_addr, sizeof(sta_addr));
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			return -1;
+		}
+		ret = hostapd_drv_sta_steer(hapd, &entry, bssid);
+		if (ret < 0)
+			return ret;
+		status = entry.status ? entry.status : WLAN_REASON_UNSPECIFIED;
+
+		for (i = 0; i < iface->num_bss; i++) {
+			struct hostapd_data *bss = iface->bss[i];
+
+			/* remove STA from all BSS, except the specified one */
+			if (os_memcmp(bss->own_addr, bssid, sizeof(bssid))) {
+				hostapd_drv_sta_disassoc(bss, sta_addr, status);
+				sta = ap_get_sta(bss, sta_addr);
+				if (sta)
+					ap_sta_disassociate(bss, sta, status);
+				mxl_ieee802_11_multi_ap_blacklist_add(bss, &entry);
+			} else {
+				mxl_ieee802_11_multi_ap_blacklist_remove(bss, &entry);
+			}
+		}
+	}
+#if 0 // ToDo: BTM
+	else {
+		int res;
+		/* Station supports 802.11v BTM, send BSS Transition Management
+		 Request instead of black listing station. */
+		char buf[2000], ret_buf[32];
+		wpa_printf(MSG_DEBUG, "Steer STA " MACSTR ", station supports BTM.",
+				MAC2STR(sta_addr));
+
+		res = sprintf_s(buf, sizeof(buf), MACSTR " %s", MAC2STR(sta_addr),
+			  btm_parameters ? btm_parameters : "");
+		if (res <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, res);
+			return -1;
+		}
+
+		ret = hostapd_ctrl_iface_bss_tm_req(hapd, buf, ret_buf, 32);
+		if (ret > 0)
+			ret = 0;
+	}
+#endif
+
+	return ret;
+}
+
+static int hostapd_ctrl_iface_sta_allow(struct hostapd_data *hapd, const char *cmd)
+{
+	u8 sta_addr[ETH_ALEN];
+	rsize_t len;
+	errno_t err;
+	int i, j, ret = 0, count = 0;
+	const char *pos;
+	struct hostapd_iface *iface = hapd->iface;
+	u8 *stations = NULL;
+	struct multi_ap_blacklist entry;
+	const char *buffer_end_address = cmd + MAX_BUFF_LEN - 9;
+
+	if (cmd[0] == ' ')
+		cmd++;
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		pos = cmd;
+		/* count the number of stations and verify the validity */
+		while (pos && (*pos != '\0')) {
+			if (hwaddr_aton(pos, sta_addr))
+				return -1;
+			count++;
+			pos = os_strchr(pos, ' ');
+			if (pos)
+				pos++;
+		}
+		if (count == 0)
+			return -1;
+		stations = os_malloc(count * ETH_ALEN);
+		if (!stations)
+			return -ENOMEM;
+		pos = cmd;
+		for (i = 0; i < count; i++) {
+			hwaddr_aton(pos, stations + i * ETH_ALEN);
+			pos = os_strchr(pos, ' ');
+			if (!pos)
+				break;
+			pos++;
+		}
+	}
+
+	os_memset(&entry, 0, sizeof(entry));
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *bss = iface->bss[i];
+
+		ret = hostapd_drv_sta_allow(bss, stations, count);
+		if (ret < 0)
+			break;
+
+		for (j = 0; j < count; j++) {
+			err = memcpy_s(entry.addr, sizeof(entry.addr), &stations[ETH_ALEN * j], ETH_ALEN);
+			if (EOK != err) {
+				wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+				os_free(stations);
+				return -1;
+			}
+			mxl_ieee802_11_multi_ap_blacklist_remove(bss, &entry);
+		}
+
+	}
+
+	os_free(stations);
+	return ret;
+}
+
+static int hostapd_ctrl_iface_get_sta_measurements(struct hostapd_data *hapd,
+	const char *cmd, char *buf, size_t buflen)
+{
+
+	/* the following defines have to be aligned with mtlk_wssa_net_modes_supported_e
+	 * from mtlk driver file mtlkwssa_drvinfo.h
+	 */
+#define INTEL_11A_SUPPORTED  0x00000001
+#define INTEL_11B_SUPPORTED  0x00000002
+#define INTEL_11G_SUPPORTED  0x00000004
+#define INTEL_11N_SUPPORTED  0x00000008
+#define INTEL_11AC_SUPPORTED 0x00000010
+#define INTEL_11AX_SUPPORTED 0x00000020
+
+	u8 sta_addr[ETH_ALEN];
+	int ret, len = 0;
+	struct intel_vendor_sta_info sta_info;
+	struct sta_info *sta;
+
+	hapd = mxl_get_bss_index(cmd, hapd->iface);
+	if (hapd == NULL) {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	cmd = os_strchr(cmd, ' ');
+	if (cmd)
+		cmd++;
+	else {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	if (hwaddr_aton(cmd, sta_addr)) {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	sta = ap_get_sta(hapd, sta_addr);
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	ret = MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_STA_MEASUREMENTS, sta_addr, ETH_ALEN, &sta_info, sizeof(sta_info));
+	if (ret) {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret < 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	/* Device.WiFi.AccessPoint.{i}.AssociatedDevice.{i}. */
+	ret = sprintf_s(buf, buflen, "MACAddress="MACSTR"\n", MAC2STR(sta_addr));
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "OperatingStandard=");
+	if (ret <= 0)
+		return len;
+	len += ret;
+	if (sta_info.NetModesSupported & INTEL_11A_SUPPORTED) {
+		ret = sprintf_s(buf + len, buflen - len, "a ");
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+	if (sta_info.NetModesSupported & INTEL_11B_SUPPORTED) {
+		ret = sprintf_s(buf + len, buflen - len, "b ");
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+	if (sta_info.NetModesSupported & INTEL_11G_SUPPORTED) {
+		ret = sprintf_s(buf + len, buflen - len, "g ");
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+	if (sta_info.NetModesSupported & INTEL_11N_SUPPORTED) {
+		ret = sprintf_s(buf + len, buflen - len, "n ");
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+	if (sta_info.NetModesSupported & INTEL_11AC_SUPPORTED) {
+		ret = sprintf_s(buf + len, buflen - len, "ac ");
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+	if (sta_info.NetModesSupported & INTEL_11AX_SUPPORTED) {
+		ret = sprintf_s(buf + len, buflen - len, "ax ");
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+	/* replace the last space with newline */
+	buf[len - 1] = '\n';
+	ret = sprintf_s(buf + len, buflen - len,
+		"AuthenticationState=%s\n",
+		sta ? (sta->flags & WLAN_STA_AUTH ? "1" : "0") : "UNKNOWN");
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "LastDataDownlinkRate=%d\n",
+		sta_info.LastDataDownlinkRate);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "LastDataUplinkRate=%d\n",
+		sta_info.LastDataUplinkRate);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "SignalStrength=%d\n",
+		sta_info.SignalStrength);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "ShortTermRSSIAverage=%d %d %d %d\n",
+		sta_info.ShortTermRSSIAverage[0],
+		sta_info.ShortTermRSSIAverage[1],
+		sta_info.ShortTermRSSIAverage[2],
+		sta_info.ShortTermRSSIAverage[3]);
+	if (ret <= 0)
+		return len;
+	len += ret;
+
+	ret = sprintf_s(buf + len, buflen - len, "SNR=%d %d %d %d\n",
+	sta_info.snr[0], sta_info.snr[1], sta_info.snr[2], sta_info.snr[3]);
+	if (ret <= 0)
+		return len;
+	len += ret;
+
+	ret = sprintf_s(buf + len, buflen - len, "Active=%s\n", sta ? "1" : "0");
+	if (ret <= 0)
+		return len;
+	len += ret;
+	/* Device.WiFi.AccessPoint.{i}.AssociatedDevice.{i}.Stats. */
+	ret = sprintf_s(buf + len, buflen - len, "BytesSent=%llu\n",
+		sta_info.BytesSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "BytesReceived=%llu\n",
+		sta_info.BytesReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "PacketsSent=%llu\n",
+		sta_info.PacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "PacketsReceived=%llu\n",
+		sta_info.PacketsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "MaxRate=%d\n",
+		sta_info.MaxRate);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "ErrorsSent=%d\n",
+		sta_info.ErrorsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "RetransCount=%d\n",
+		sta_info.RetransCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "RetryCount=%d\n",
+		sta_info.RetryCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "MultipleRetryCount=UNKNOWN\n");
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "FailedRetransCount=%d\n",
+		sta_info.FailedRetransCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+
+	/* peer Phy related information */
+	if (sta_info.RateInfoFlag) { /* available */
+		ret = sprintf_s(buf + len, buflen - len, "PhyMode=%d\n", sta_info.RatePhyMode);
+		if (ret <= 0)
+			return len;
+		len += ret;
+		ret = sprintf_s(buf + len, buflen - len, "Nss=%d\n", sta_info.RateNss);
+		if (ret <= 0)
+			return len;
+		len += ret;
+		ret = sprintf_s(buf + len, buflen - len, "CbwMHz=%d\n", sta_info.RateCbwMHz);
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+
+	ret = sprintf_s(buf + len, buflen - len, "TxStbcMode=%d\n", sta_info.TxStbcMode);
+	if (ret <= 0)
+		return len;
+	len += ret;
+
+	ret = sprintf_s(buf + len, buflen - len, "pairwise_cipher=%x\n", sta->wpa_sm ? wpa_auth_get_pairwise(sta->wpa_sm) : 0);
+	if (ret <= 0)
+		return len;
+	len += ret;
+
+	ret = sprintf_s(buf + len, buflen - len, "wpa_key_mgmt=%x\n", sta->wpa_sm ? wpa_auth_sta_key_mgmt(sta->wpa_sm) : 0);
+	if (ret <= 0)
+		return len;
+	len += ret;
+
+	return len;
+}
+
+static int hostapd_ctrl_iface_get_vap_measurements(struct hostapd_data *hapd,
+	const char *cmd, char *buf, size_t buflen)
+{
+	int ret, len = 0;
+	struct intel_vendor_vap_info vap_info;
+
+	hapd = mxl_get_bss_index(cmd, hapd->iface);
+	if (hapd == NULL) {
+		ret = sprintf_s(buf, buflen, "FAIL: bss index\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	ret = MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_VAP_MEASUREMENTS, NULL, 0, &vap_info, sizeof(vap_info));
+	if (ret) {
+		ret = sprintf_s(buf, buflen, "FAIL: vap measurements\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	ret = sprintf_s(buf + len, buflen - len, "Name=%s\n",
+		hapd->conf->iface);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "Enable=%d\n",
+		hapd->started);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "BSSID="MACSTR"\n",
+		MAC2STR(hapd->own_addr));
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "SSID=%s\n",
+		wpa_ssid_txt(hapd->conf->ssid.ssid,
+		hapd->conf->ssid.ssid_len));
+	if (ret <= 0)
+		return len;
+	len += ret;
+	/* Device.WiFi.SSID.{i}.Stats. */
+	ret = sprintf_s(buf + len, buflen - len, "BytesSent=%llu\n",
+		vap_info.traffic_stats.BytesSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "BytesReceived=%llu\n",
+		vap_info.traffic_stats.BytesReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "PacketsSent=%llu\n",
+		vap_info.traffic_stats.PacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "PacketsReceived=%llu\n",
+		vap_info.traffic_stats.PacketsReceived);
+	if (ret < 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "ErrorsSent=%d\n",
+		vap_info.error_stats.ErrorsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "RetransCount=%d\n",
+		vap_info.RetransCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "FailedRetransCount=%d\n",
+		vap_info.FailedRetransCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "RetryCount=%d\n",
+		vap_info.RetryCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "MultipleRetryCount=%d\n",
+		vap_info.MultipleRetryCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "ACKFailureCount=%d\n",
+		vap_info.ACKFailureCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "AggregatedPacketCount=%d\n",
+		vap_info.AggregatedPacketCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "ErrorsReceived=%d\n",
+		vap_info.error_stats.ErrorsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "UnicastPacketsSent=%d\n",
+		vap_info.traffic_stats.UnicastPacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "UnicastPacketsReceived=%d\n",
+		vap_info.traffic_stats.UnicastPacketsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "DiscardPacketsSent=%d\n",
+		vap_info.error_stats.DiscardPacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "DiscardPacketsReceived=%d\n",
+		vap_info.error_stats.DiscardPacketsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "MulticastPacketsSent=%d\n",
+		vap_info.traffic_stats.MulticastPacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len,
+		"MulticastPacketsReceived=%d\n",
+		vap_info.traffic_stats.MulticastPacketsReceived);
+  if (ret <= 0)
+    return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len,
+		"BroadcastPacketsSent=%d\n",
+		vap_info.traffic_stats.BroadcastPacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len,
+		"BroadcastPacketsReceived=%d\n",
+		vap_info.traffic_stats.BroadcastPacketsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len,
+		"UnknownProtoPacketsReceived=%d\n",
+	vap_info.UnknownProtoPacketsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+
+	return len;
+}
+
+static int hostapd_ctrl_iface_get_radio_state (enum hostapd_iface_state state)
+{
+	switch (state) {
+	case HAPD_IFACE_ENABLED:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static int hostapd_ctrl_iface_get_radio_info(struct hostapd_data *hapd,
+	const char *cmd, char *buf, size_t buflen)
+{
+	int ret = 0, len = 0;
+	struct intel_vendor_radio_info radio_info;
+	enum hostapd_iface_state state = hapd->iface->state;
+
+	ret = MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_RADIO_INFO, NULL, 0, &radio_info, sizeof(radio_info));
+	if (ret) {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	ret = sprintf_s(buf + len, buflen - len, "Name=%s\n",
+		hapd->conf->iface);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "HostapdEnabled=%d\n",
+		hostapd_ctrl_iface_get_radio_state(state));
+	if (ret <= 0)
+		return len;
+	len += ret;
+	/* Device.WiFi.Radio.{i}. */
+	ret = sprintf_s(buf + len, buflen - len, "TxEnabled=%d\n",
+		radio_info.Enable);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "Channel=%d\n",
+		radio_info.Channel);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	/* Device.WiFi.Radio.{i}.Stats. */
+	ret = sprintf_s(buf + len, buflen - len, "BytesSent=%llu\n",
+		radio_info.traffic_stats.BytesSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "BytesReceived=%llu\n",
+		radio_info.traffic_stats.BytesReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "PacketsSent=%llu\n",
+		radio_info.traffic_stats.PacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "PacketsReceived=%llu\n",
+		radio_info.traffic_stats.PacketsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "ErrorsSent=%d\n",
+		radio_info.error_stats.ErrorsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "ErrorsReceived=%d\n",
+		radio_info.error_stats.ErrorsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "DiscardPacketsSent=%d\n",
+		radio_info.error_stats.DiscardPacketsSent);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len,
+		"DiscardPacketsReceived=%d\n",
+		radio_info.error_stats.DiscardPacketsReceived);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "PLCPErrorCount=UNKNOWN\n");
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "FCSErrorCount=%d\n",
+		radio_info.FCSErrorCount);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len,
+		"InvalidMACCount=UNKNOWN\n");
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len,
+		"PacketsOtherReceived=UNKNOWN\n");
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "Noise=%d\n",
+		radio_info.Noise);
+	if (ret < 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "BSS load=%d\n",
+		radio_info.load);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "TxPower=%.2f\n",
+		radio_info.tx_pwr_cfg / 100.);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "RxAntennas=%d\n",
+		radio_info.num_rx_antennas);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	ret = sprintf_s(buf + len, buflen - len, "TxAntennas=%d\n",
+		radio_info.num_tx_antennas);
+	if (ret <= 0)
+		return len;
+	len += ret;
+	if (!radio_info.primary_center_freq) {
+		ret = sprintf_s(buf + len, buflen - len, "Freq=UNKNOWN\n");
+		if (ret <= 0)
+			return len;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, "OperatingChannelBandwidt=UNKNOWN\n");
+		if (ret <= 0)
+			return len;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, "Cf1=UNKNOWN\n");
+		if (ret <= 0)
+			return len;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, "Dfs_chan=UNKNOWN\n");
+		if (ret <= 0)
+			return len;
+		len += ret;
+	} else {
+		ret = sprintf_s(buf + len, buflen - len, "Freq=%d\n",
+			radio_info.primary_center_freq);
+		if (ret <= 0)
+			return len;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, "OperatingChannelBandwidt=%d\n",
+			radio_info.width);
+		if (ret <= 0)
+			return len;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, "Cf1=%d\n",
+			radio_info.center_freq1);
+		if (ret <= 0)
+			return len;
+		len += ret;
+
+		ret = sprintf_s(buf + len, buflen - len, "Dfs_chan=%d\n",
+		ieee80211_is_dfs(radio_info.primary_center_freq,hapd->iface->hw_features,hapd->iface->num_hw_features));
+		if (ret <= 0)
+			return len;
+		len += ret;
+	}
+
+	return len;
+}
+
+struct hostapd_channel_data * mxl_hostapd_get_mode_channel(struct hostapd_iface *iface, unsigned int freq);
+
+static int
+hostapd_is_chandef_valid (struct hostapd_iface *iface, unsigned int center_freq, unsigned int bandwidth)
+{
+	int valid = 0;
+	unsigned int cur_freq;
+	unsigned int low_freq, high_freq;
+
+	if (!iface->current_mode)
+		return 0;
+
+	low_freq  = center_freq - bandwidth/2 + 10;
+	high_freq = center_freq + bandwidth/2 - 10;
+
+	for (cur_freq = low_freq; cur_freq <= high_freq; cur_freq += 20) {
+		if (!mxl_hostapd_get_mode_channel(iface, cur_freq))
+			return 0;
+
+		valid = 1;
+	}
+	return valid;
+}
+
+static int hostapd_ctrl_iface_unconnected_sta(struct hostapd_data *hapd, const char *cmd)
+{
+	struct intel_vendor_unconnected_sta_req_cfg req;
+	char *pos;
+	unsigned int bandwidth;
+	struct sta_info *sta;
+
+	os_memset(&req, 0, sizeof(req));
+
+	if (hwaddr_aton(cmd, req.addr))
+		return -1;
+
+	pos = os_strstr(cmd, " ");
+	if (pos) {
+		pos++;
+		req.freq = atoi(pos);
+		if (!hostapd_is_chandef_valid(hapd->iface, req.freq, 20)) {
+			wpa_printf(MSG_ERROR, "unconnected_sta: invalid freq provided");
+			return -1;
+		}
+	} else {
+		wpa_printf(MSG_ERROR, "unconnected_sta: freq not specified");
+		return -1;
+	}
+
+	pos = os_strstr(cmd, "center_freq1=");
+	if (pos) {
+		pos += sizeof("center_freq1=") - 1;
+		req.center_freq1 = atoi(pos);
+	} else {
+		wpa_printf(MSG_ERROR, "unconnected_sta: center_freq1 not specified");
+		return -1;
+	}
+
+	pos = os_strstr(cmd, "center_freq2=");
+	if (pos) {
+		pos += sizeof("center_freq2=") - 1;
+		req.center_freq2 = atoi(pos);
+	}
+
+	pos = os_strstr(cmd, "bandwidth=");
+	if (pos) {
+		pos += sizeof("bandwidth=") - 1;
+		bandwidth = atoi(pos);
+	} else {
+		wpa_printf(MSG_ERROR, "unconnected_sta: bandwidth not specified");
+		return -1;
+	}
+
+	switch (bandwidth) {
+		case 20:
+			req.bandwidth = NL80211_CHAN_WIDTH_20;
+			break;
+		case 40:
+			req.bandwidth = NL80211_CHAN_WIDTH_40;
+			break;
+		case 80:
+			if (req.center_freq2)
+				req.bandwidth = NL80211_CHAN_WIDTH_80P80;
+			else
+				req.bandwidth = NL80211_CHAN_WIDTH_80;
+			break;
+		case 160:
+			req.bandwidth = NL80211_CHAN_WIDTH_160;
+			break;
+		default:
+			wpa_printf(MSG_ERROR, "unconnected_sta: invalid bandwidth provided");
+			return -1;
+	}
+
+	if (!hostapd_is_chandef_valid(hapd->iface, req.center_freq1, bandwidth)) {
+		wpa_printf(MSG_ERROR, "unconnected_sta: invalid center_freq1 provided");
+		return -1;
+	}
+
+	if (req.center_freq2 &&
+		!hostapd_is_chandef_valid(hapd->iface, req.center_freq2, bandwidth)) {
+		wpa_printf(MSG_ERROR, "unconnected_sta: invalid center_freq2 provided");
+		return -1;
+	}
+
+	sta = ap_get_sta(hapd, req.addr);
+	if (sta) {
+		wpa_printf(MSG_ERROR, "unconnected_sta: disconnect STA "MACSTR" first",
+		MAC2STR(req.addr));
+		return -1;
+	}
+
+	return hostapd_drv_unconnected_sta(hapd, &req);
+}
+
+/* checks weather channel exists */
+static int hostapd_ctrl_iface_restricted_chan_number_check_cb(struct hostapd_iface *iface,
+	int channel)
+{
+	if (!hostapd_hw_get_channel_data_from_ch(iface, channel))
+		return -1;
+	return 0;
+}
+
+/* Sets channel as restricted. Ignores channels that are already disabled. */
+static int hostapd_ctrl_iface_restricted_chan_number_cb(struct hostapd_iface *iface,
+	int channel)
+{
+	struct hostapd_channel_data* ch_data;
+
+	ch_data = hostapd_hw_get_channel_data_from_ch(iface, channel);
+	if (!ch_data)
+		return -1;
+	if (!(ch_data->flag & HOSTAPD_CHAN_DISABLED)) {
+		ch_data->flag |= HOSTAPD_CHAN_DISABLED;
+		ch_data->flag |= HOSTAPD_CHAN_RESTRICTED;
+	}
+
+	return 0;
+}
+
+/* checks weather any channel in given range exists */
+static int hostapd_ctrl_iface_restricted_chan_range_check_cb(struct hostapd_iface *iface,
+	int channel_from, int channel_to)
+{
+	int i;
+
+	for (i = channel_from; i <= channel_to; i++) {
+		if (hostapd_hw_get_channel_data_from_ch(iface, i)) {
+			return 0;
+		}
+	}
+	return -1;
+}
+
+/* Sets channels in given range as restricted. Ignores channels that are already
+ * disabled. */
+static int hostapd_ctrl_iface_restricted_chan_range_cb(struct hostapd_iface *iface,
+	int channel_from, int channel_to)
+{
+	bool exists = false;
+	int i;
+	struct hostapd_channel_data* ch_data;
+
+	for (i = channel_from; i <= channel_to; i++) {
+		ch_data = hostapd_hw_get_channel_data_from_ch(iface, i);
+		if (!ch_data)
+			continue;
+		exists = true;
+		if (!(ch_data->flag & HOSTAPD_CHAN_DISABLED)) {
+			ch_data->flag |= HOSTAPD_CHAN_DISABLED;
+			ch_data->flag |= HOSTAPD_CHAN_RESTRICTED;
+		}
+	}
+	if (exists)
+		return 0;
+	else
+		return -1;
+}
+
+static int hostapd_ctrl_iface_set_restricted_chan(struct hostapd_iface *iface, const char *cmd)
+{
+	char *end;
+	struct hostapd_hw_modes *mode;
+	int i;
+	struct hostapd_channel_data *ch;
+
+	if (!iface->current_mode)
+		return -1;
+	mode = iface->current_mode;
+
+	/* check list for validity */
+	if (hostapd_get_list(cmd, &end, iface,
+		hostapd_ctrl_iface_restricted_chan_number_check_cb,
+		hostapd_ctrl_iface_restricted_chan_range_check_cb))
+		return -1;
+
+	/* clear restricted flag on all channels */
+	for (i = 0; i < mode->num_channels; i++) {
+		ch = &iface->current_mode->channels[i];
+		if ((ch->flag & HOSTAPD_CHAN_DISABLED) &&
+			(ch->flag & HOSTAPD_CHAN_RESTRICTED)) {
+			ch->flag &= ~HOSTAPD_CHAN_DISABLED;
+			ch->flag &= ~HOSTAPD_CHAN_RESTRICTED;
+		}
+	}
+
+	/* set restricted flag on specified channels */
+	return hostapd_get_list(cmd, &end, iface,
+		hostapd_ctrl_iface_restricted_chan_number_cb,
+		hostapd_ctrl_iface_restricted_chan_range_cb);
+}
+
+static int hostapd_ctrl_iface_get_restricted_chan(struct hostapd_iface *iface,
+	const char *cmd, char *buf, size_t buflen)
+{
+	int ret = 0, len = 0, i;
+	struct hostapd_hw_modes *mode;
+	struct hostapd_channel_data *ch;
+
+	if (!iface->current_mode)
+		return -1;
+
+	mode = iface->current_mode;
+
+	for (i = 0; i < mode->num_channels; i++) {
+		ch = &iface->current_mode->channels[i];
+		if ((ch->flag & HOSTAPD_CHAN_DISABLED) &&
+			(ch->flag & HOSTAPD_CHAN_RESTRICTED)) {
+			ret = sprintf_s(buf + len, buflen - len, "%d ", ch->chan);
+			if (ret <= 0)
+				break;
+			len += ret;
+		}
+	}
+
+	if (len > 0)
+		buf[len - 1] = '\n';
+
+	return len;
+}
+
 static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      char *buf, char *reply,
 					      int reply_size,
@@ -3468,8 +4578,8 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "MIB ", 4) == 0) {
 		reply_len = hostapd_ctrl_iface_mib(hapd, reply, reply_size,
 						   buf + 4);
-	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
-		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
+	} else if (os_strncmp(buf, "STA-FIRST ", 10) == 0) {
+		reply_len = hostapd_ctrl_iface_sta_first(hapd, buf + 10, reply,
 							 reply_size);
 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
 		reply_len = hostapd_ctrl_iface_sta(hapd, buf + 4, reply,
@@ -3970,6 +5080,41 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 			reply_len = -1;
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
+#ifdef CONFIG_VENDOR_MXL
+	} else if (mxl_hostapd_ctrl_iface_receive_process(hapd, buf, reply, reply_size, &reply_len)) {
+#endif /* CONFIG_VENDOR_MXL */
+	} else if (os_strncmp(buf, "DENY_MAC ", 9) == 0) {
+		if (hostapd_ctrl_iface_deny_mac(hapd, buf + 9))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "STA_STEER ", 10) == 0) {
+		wpa_printf(MSG_EXCESSIVE, "%s; *** Received 'STA_STEER' (buf= '%s') ***\n", __FUNCTION__, buf);
+		if (hostapd_ctrl_iface_sta_steer(hapd, buf + 10))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "STA_ALLOW", 9) == 0) {
+		wpa_printf(MSG_EXCESSIVE, "%s; *** Received 'STA_ALLOW' (buf= '%s') ***\n", __FUNCTION__, buf);
+		if (hostapd_ctrl_iface_sta_allow(hapd, buf + 9))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "GET_STA_MEASUREMENTS ", 21) == 0) {
+		wpa_printf(MSG_EXCESSIVE, "%s; *** Received 'GET_STA_MEASUREMENTS' (buf= '%s') ***\n", __FUNCTION__, buf);
+		reply_len = hostapd_ctrl_iface_get_sta_measurements(hapd, buf + 21, reply,
+					reply_size);
+	} else if (os_strncmp(buf, "GET_VAP_MEASUREMENTS ", 21) == 0) {
+		wpa_printf(MSG_EXCESSIVE, "%s; *** Received 'GET_VAP_MEASUREMENTS' (buf= '%s') ***\n", __FUNCTION__, buf);
+		reply_len = hostapd_ctrl_iface_get_vap_measurements(hapd, buf + 21, reply,
+					reply_size);
+	} else if (os_strncmp(buf, "GET_RADIO_INFO", 14) == 0) {
+		wpa_printf(MSG_EXCESSIVE, "%s; *** Received 'GET_RADIO_INFO' (buf= '%s') ***\n", __FUNCTION__, buf);
+		reply_len = hostapd_ctrl_iface_get_radio_info(hapd, NULL, reply,
+					reply_size);
+	} else if (os_strncmp(buf, "UNCONNECTED_STA_RSSI ", 21) == 0) {
+		if (hostapd_ctrl_iface_unconnected_sta(hapd, buf + 21))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "RESTRICTED_CHANNELS", 19) == 0) {
+		if (hostapd_ctrl_iface_set_restricted_chan(hapd->iface, buf + 19))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "GET_RESTRICTED_CHANNELS", 23) == 0) {
+		reply_len = hostapd_ctrl_iface_get_restricted_chan(hapd->iface, NULL, reply,
+					reply_size);
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
@@ -4098,9 +5243,62 @@ static void hostapd_ctrl_iface_msg_cb(void *ctx, int level,
 				      const char *txt, size_t len)
 {
 	struct hostapd_data *hapd = ctx;
-	if (hapd == NULL)
+	char *buf, *pos;
+	size_t total, ifacelen, bufsize;
+	errno_t err;
+
+	if ((hapd == NULL) || (hapd->iface->bss[0] == NULL))
+		return;
+
+	pos = os_strchr(txt, ' ');
+	if (pos == NULL)
+		total = len;
+	else {
+		total = pos - txt;
+		pos++;
+	}
+
+	bufsize = len + sizeof(hapd->conf->iface);
+	buf = os_malloc(bufsize);
+	if (buf == NULL)
 		return;
-	hostapd_ctrl_iface_send(hapd, level, type, txt, len);
+
+	ifacelen = strnlen_s(hapd->conf->iface, sizeof(hapd->conf->iface));
+	if (!IS_VALID_RANGE(ifacelen, AP_MIN_VALID_CHAR, sizeof(hapd->conf->iface) - 1)) {
+		wpa_printf(MSG_ERROR, "hostapd_ctrl_iface_msg_cb - wrong len");
+		os_free(buf);
+		return;
+	}
+	err = memcpy_s(buf, bufsize, txt, total);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		os_free(buf);
+		return;
+	}
+	buf[total] = ' ';
+	total++;
+	err = memcpy_s(buf + total, bufsize - total, hapd->conf->iface, ifacelen);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		os_free(buf);
+		return;
+	}
+	total += ifacelen;
+	if (pos) {
+		buf[total] = ' ';
+		total++;
+		err = memcpy_s(buf + total, bufsize - total, pos, len - (pos - txt));
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			os_free(buf);
+			return;
+		}
+	}
+
+	/* send all events to the first VAP */
+	hapd = hapd->iface->bss[0];
+	hostapd_ctrl_iface_send(hapd, level, type, buf, len + ifacelen + 1);
+	os_free(buf);
 }
 
 
@@ -4357,6 +5555,8 @@ void hostapd_ctrl_iface_deinit(struct hostapd_data *hapd)
 {
 	struct wpa_ctrl_dst *dst, *prev;
 
+	wpa_msg(hapd->msg_ctx, MSG_INFO, HOSTAPD_DISCONNECTED);
+
 	if (hapd->ctrl_sock > -1) {
 #ifndef CONFIG_CTRL_IFACE_UDP
 		char *fname;
diff --git a/hostapd/hostapd_cli.c b/hostapd/hostapd_cli.c
index 6ffaf87e3..996ed3b4b 100644
--- a/hostapd/hostapd_cli.c
+++ b/hostapd/hostapd_cli.c
@@ -16,6 +16,9 @@
 #include "utils/edit.h"
 #include "common/version.h"
 #include "common/cli.h"
+#ifdef CONFIG_VENDOR_MXL
+#include "mxl_hostapd_cli.h"
+#endif /* CONFIG_VENDOR_MXL */
 
 #ifndef CONFIG_NO_CTRL_IFACE
 
@@ -378,16 +381,16 @@ static int hostapd_cli_cmd_deauthenticate(struct wpa_ctrl *ctrl, int argc,
 					  char *argv[])
 {
 	char buf[64];
-	if (argc < 1) {
-		printf("Invalid 'deauthenticate' command - exactly one "
-		       "argument, STA address, is required.\n");
+	if (argc < 2) {
+		printf("Invalid 'deauthenticate' command - two arguments: "
+		       "BSS name and STA address are required.\n");
 		return -1;
 	}
-	if (argc > 1)
-		os_snprintf(buf, sizeof(buf), "DEAUTHENTICATE %s %s",
-			    argv[0], argv[1]);
+	if (argc > 2)
+		os_snprintf(buf, sizeof(buf), "DEAUTHENTICATE %s %s %s",
+			    argv[0], argv[1], argv[2]);
 	else
-		os_snprintf(buf, sizeof(buf), "DEAUTHENTICATE %s", argv[0]);
+		os_snprintf(buf, sizeof(buf), "DEAUTHENTICATE %s %s", argv[0], argv[1]);
 	return wpa_ctrl_command(ctrl, buf);
 }
 
@@ -397,15 +400,15 @@ static int hostapd_cli_cmd_disassociate(struct wpa_ctrl *ctrl, int argc,
 {
 	char buf[64];
 	if (argc < 1) {
-		printf("Invalid 'disassociate' command - exactly one "
-		       "argument, STA address, is required.\n");
+		printf("Invalid 'disassociate' command - two arguments: "
+		       "BSS name and STA address are required.\n");
 		return -1;
 	}
-	if (argc > 1)
-		os_snprintf(buf, sizeof(buf), "DISASSOCIATE %s %s",
-			    argv[0], argv[1]);
+	if (argc > 2)
+		os_snprintf(buf, sizeof(buf), "DISASSOCIATE %s %s %s",
+			    argv[0], argv[1], argv[2]);
 	else
-		os_snprintf(buf, sizeof(buf), "DISASSOCIATE %s", argv[0]);
+		os_snprintf(buf, sizeof(buf), "DISASSOCIATE %s %s", argv[0], argv[1]);
 	return wpa_ctrl_command(ctrl, buf);
 }
 
@@ -784,11 +787,37 @@ static int hostapd_cli_cmd_all_sta(struct wpa_ctrl *ctrl, int argc,
 				   char *argv[])
 {
 	char addr[32], cmd[64];
+	int res, total;
+	char *tmp;
+
+	if (argc != 1) {
+		printf("Invalid ALL_STA command\n usage: <BSS_name>\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "STA-FIRST");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	total = res;
+	tmp = cmd + total;
+	res = sprintf_s(tmp, sizeof(cmd) - total, " %s", argv[0]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
 
-	if (wpa_ctrl_command_sta(ctrl, "STA-FIRST", addr, sizeof(addr), 1))
+	if (wpa_ctrl_command_sta(ctrl, cmd, addr, sizeof(addr), 1))
 		return 0;
+
 	do {
-		snprintf(cmd, sizeof(cmd), "STA-NEXT %s", addr);
+		res = sprintf_s(cmd, sizeof(cmd), "STA-NEXT %s %s", argv[0], addr);
+		if (res <= 0) {
+			printf("%s: sprintf_s error %d", __func__, res);
+			return -1;
+		}
 	} while (wpa_ctrl_command_sta(ctrl, cmd, addr, sizeof(addr), 1) == 0);
 
 	return -1;
@@ -1191,7 +1220,8 @@ static int hostapd_cli_cmd_chan_switch(struct wpa_ctrl *ctrl,
 		       "arguments (count and freq)\n"
 		       "usage: <cs_count> <freq> [sec_channel_offset=] "
 		       "[center_freq1=] [center_freq2=] [bandwidth=] "
-		       "[blocktx] [ht|vht|he|eht]\n");
+		       "[blocktx] [ht|vht|he|eht] [tx_ant_mask=<> rx_ant_mask=<>] "
+		       "[switch_type=<normal/scan>] [acs_scan_mode]\n");
 		return -1;
 	}
 
@@ -1580,11 +1610,13 @@ static int hostapd_cli_cmd_poll_sta(struct wpa_ctrl *ctrl, int argc,
 }
 
 
+#ifndef CONFIG_VENDOR_MXL
 static int hostapd_cli_cmd_req_beacon(struct wpa_ctrl *ctrl, int argc,
 				      char *argv[])
 {
 	return hostapd_cli_cmd(ctrl, "REQ_BEACON", 2, argc, argv);
 }
+#endif /* CONFIG_VENDOR_MXL */
 
 
 static int hostapd_cli_cmd_reload_wpa_psk(struct wpa_ctrl *ctrl, int argc,
@@ -1602,6 +1634,294 @@ static int hostapd_cli_cmd_driver(struct wpa_ctrl *ctrl, int argc, char *argv[])
 #endif /* ANDROID */
 
 
+static int hostapd_cli_cmd_deny_mac(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	char cmd[256];
+	int res, total, i;
+	char *tmp;
+
+	if (argc < 1 || argc > 3) {
+		printf("Invalid DENY_MAC command\n"
+			"usage: <addr> <[0]/1> [reject_sta=]\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "DENY_MAC %s", argv[0]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	total = res;
+	for (i = 1; i < argc; i++) {
+		tmp = &cmd[total];
+		res = sprintf_s(tmp, sizeof(cmd) - total, " %s", argv[i]);
+		if (res <= 0) {
+			printf("%s: sprintf_s error %d", __func__, res);
+			return -1;
+		}
+		total += res;
+	}
+
+	return wpa_ctrl_command(ctrl, cmd);
+}
+
+static int hostapd_cli_cmd_sta_steer(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	char cmd[256];
+	int res, total, i;
+	char *tmp;
+
+	if (argc < 1) {
+		printf("Invalid STA_STEER command\n"
+				"usage: <addr> [BSSID]\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "STA_STEER %s", argv[0]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	total = res;
+	for (i = 1; i < argc; i++) {
+		tmp = &cmd[total];
+		res = sprintf_s(tmp, sizeof(cmd) - total, " %s", argv[i]);
+		if (res <= 0) {
+			printf("%s: sprintf_s error %d", __func__, res);
+			return -1;
+		}
+		total += res;
+	}
+
+	return wpa_ctrl_command(ctrl, cmd);
+}
+
+static int hostapd_cli_cmd_sta_allow(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	 char cmd[256];
+	int res, total, i;
+
+	if (argc < 0) {
+		printf("Invalid number of arguments for STA_ALLOW command.\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "STA_ALLOW");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		goto err;
+	}
+
+	total = 0;
+	for(i = 0; i < argc; i++) {
+		total += res;
+		if ((res < 0) || (total >= (sizeof(cmd) - 1)))
+			goto err;
+		res = sprintf_s(cmd + total, sizeof(cmd) - total, " %s", argv[i]);
+		if (res <= 0) {
+			printf("%s: sprintf_s error %d", __func__, res);
+			return -1;
+		}
+	}
+	total += res;
+	if ((res < 0) || (total >= (sizeof(cmd) - 1)))
+		goto err;
+
+	return wpa_ctrl_command(ctrl, cmd);
+
+err:
+	printf("Too long STA_ALLOW command.\n");
+	return -1;
+}
+
+static int hostapd_cli_cmd_unconnected_sta(struct wpa_ctrl *ctrl,
+	int argc, char *argv[])
+{
+	char cmd[256];
+	int res, total;
+	char *tmp;
+
+	if (argc < 4) {
+		printf("Invalid unconnected_sta command: needs at least four "
+			"arguments (address, frequency, center frequency and bandwidth)\n"
+			"usage: <address> <freq> <center_freq1=> [center_freq2=] "
+			"<bandwidth=>\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "UNCONNECTED_STA_RSSI %s %s %s %s",
+		argv[0], argv[1], argv[2], argv[3]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	if (argc == 5) {
+		total = res;
+		tmp = cmd + total;
+		res = sprintf_s(tmp, sizeof(cmd) - total, " %s", argv[4]);
+		if (res <= 0) {
+			printf("%s: sprintf_s error %d", __func__, res);
+			return -1;
+		}
+	}
+
+	return wpa_ctrl_command(ctrl, cmd);
+}
+
+static int hostapd_cli_cmd_sta_measurements(struct wpa_ctrl *ctrl, int argc,
+	char *argv[])
+{
+	char cmd[256];
+	int res, total, i;
+
+	if (argc != 2) {
+		printf("Invalid GET_STA_MEASUREMENTS command\n"
+			"usage: <BSS_name> <addr>\n");
+	return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "GET_STA_MEASUREMENTS");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		goto err;
+	}
+
+	total = 0;
+	for(i = 0; i < argc; i++) {
+		total += res;
+		if ((res < 0) || (total >= (sizeof(cmd) - 1)))
+			goto err;
+		res = sprintf_s(cmd + total, sizeof(cmd) - total, " %s", argv[i]);
+		if (res <= 0) {
+			printf("%s: sprintf_s error %d", __func__, res);
+			goto err;
+		}
+	}
+	total += res;
+	if ((res < 0) || (total >= (sizeof(cmd) - 1)))
+		goto err;
+
+	return wpa_ctrl_command(ctrl, cmd);
+
+err:
+	printf("Too long GET_STA_MEASUREMENTS command.\n");
+	return -1;
+}
+
+static int hostapd_cli_cmd_vap_measurements(struct wpa_ctrl *ctrl, int argc,
+	char *argv[])
+{
+
+	char cmd[256];
+	int res, total;
+	char *tmp;
+
+	if (argc != 1) {
+		printf("Invalid GET_VAP_MEASUREMENTS command\n"
+			"usage: <BSS_name>\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "GET_VAP_MEASUREMENTS");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	total = res;
+	tmp = cmd + total;
+	res = sprintf_s(tmp, sizeof(cmd) - total, " %s", argv[0]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	return wpa_ctrl_command(ctrl, cmd);
+}
+
+static int hostapd_cli_cmd_radio_info(struct wpa_ctrl *ctrl, int argc,
+	char *argv[])
+{
+	char cmd[256];
+	int res;
+
+	if (argc != 0) {
+		printf("radio_info doesn't require parameters\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "GET_RADIO_INFO");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+
+	return wpa_ctrl_command(ctrl, cmd);
+}
+
+static int hostapd_cli_cmd_set_restricted_chan(struct wpa_ctrl *ctrl,
+	int argc, char *argv[])
+{
+	char cmd[256];
+	int res, total = 0, i;
+
+	if (argc < 0) {
+		printf("Invalid number of arguments for RESTRICTED_CHANNELS command.\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "RESTRICTED_CHANNELS");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		goto err;
+	}
+
+	total = 0;
+	for(i = 0; i < argc; i++) {
+		total += res;
+		if ((res < 0) || (total >= (sizeof(cmd) - 1)))
+			goto err;
+		res = sprintf_s(cmd + total, sizeof(cmd) - total, " %s", argv[i]);
+		if (res <= 0) {
+			printf("%s: sprintf_s error %d", __func__, res);
+			goto err;
+		}
+	}
+	total += res;
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		goto err;
+	}
+
+	return wpa_ctrl_command(ctrl, cmd);
+
+err:
+	printf("Too long RESTRICTED_CHANNELS command.\n");
+	return -1;
+}
+
+static int hostapd_cli_cmd_get_restricted_chan(struct wpa_ctrl *ctrl,
+	int argc, char *argv[])
+{
+	char cmd[24];
+	int res;
+
+	if (argc != 0) {
+		printf("get_restricted_chan doesn't require parameters\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "GET_RESTRICTED_CHANNELS");
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+	return wpa_ctrl_command(ctrl, cmd);
+}
+
 struct hostapd_cli_cmd {
 	const char *cmd;
 	int (*handler)(struct wpa_ctrl *ctrl, int argc, char *argv[]);
@@ -1623,17 +1943,17 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	{ "sta", hostapd_cli_cmd_sta, hostapd_complete_stations,
 	  "<addr> = get MIB variables for one station" },
 	{ "all_sta", hostapd_cli_cmd_all_sta, NULL,
-	   "= get MIB variables for all stations" },
+	  "<bss> = get MIB variables for all stations for bss" },
 	{ "list_sta", hostapd_cli_cmd_list_sta, NULL,
 	   "= list all stations" },
 	{ "new_sta", hostapd_cli_cmd_new_sta, NULL,
 	  "<addr> = add a new station" },
 	{ "deauthenticate", hostapd_cli_cmd_deauthenticate,
 	  hostapd_complete_stations,
-	  "<addr> = deauthenticate a station" },
+	  "<bss> <addr> = deauthenticate a station" },
 	{ "disassociate", hostapd_cli_cmd_disassociate,
 	  hostapd_complete_stations,
-	  "<addr> = disassociate a station" },
+	  "<bss> <addr> = disassociate a station" },
 #ifdef CONFIG_TAXONOMY
 	{ "signature", hostapd_cli_cmd_signature, hostapd_complete_stations,
 	  "<addr> = get taxonomy signature for a station" },
@@ -1803,14 +2123,50 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 #endif /* CONFIG_VENDOR_MXL */
 	{ "poll_sta", hostapd_cli_cmd_poll_sta, hostapd_complete_stations,
 	  "<addr> = poll a STA to check connectivity with a QoS null frame" },
+#ifndef CONFIG_VENDOR_MXL
 	{ "req_beacon", hostapd_cli_cmd_req_beacon, NULL,
 	  "<addr> [req_mode=] <measurement request hexdump>  = send a Beacon report request to a station" },
+#endif /* CONFIG_VENDOR_MXL */
 	{ "reload_wpa_psk", hostapd_cli_cmd_reload_wpa_psk, NULL,
 	  "= reload wpa_psk_file only" },
 #ifdef ANDROID
 	{ "driver", hostapd_cli_cmd_driver, NULL,
 	  "<driver sub command> [<hex formatted data>] = send driver command data" },
 #endif /* ANDROID */
+#ifdef CONFIG_VENDOR_MXL
+	MXL_HOSTAPD_ADD_VENDOR_CLI
+#endif /* CONFIG_VENDOR_MXL */
+	{ "deny_mac", hostapd_cli_cmd_deny_mac, NULL,
+	  "<addr> <[0]/1> 0-add;1-remove station to/from blacklist\n"
+	  "[reject_sta=xx reject status code]" },
+	{ "sta_steer", hostapd_cli_cmd_sta_steer, NULL,
+	  "<addr> [BSSID] [reject_sta=xx reject status code]\n"
+	  "[pref=<1/0 is candidate list included>]\n"
+	  "[neighbor=<BSSID>,<BSSID Information>,<Operating Class>,\n"
+	  "<Channel Number>,<PHY Type>,<priority for this BSS>]\n"
+#ifdef CONFIG_MBO
+	  "[mbo==<reason>:<reassoc_delay>:<cell_pref, -1 indicates that\n"
+	  "cellular preference MBO IE should not be included>]\n"
+#endif /*CONFIG_MBO*/
+	  "[disassoc_imminent=<1/0>] [disassoc_timer=<value in milliseconds>]\n"
+	  "steer station to specified (V)AP" },
+	{ "sta_allow", hostapd_cli_cmd_sta_allow, NULL,
+	  "[addr1] [addr2] ... [addrX] add station(s) to whitelist"
+	  "without parameters will allow all STA's on this radio" },
+	{ "unconnected_sta", hostapd_cli_cmd_unconnected_sta, NULL,
+	  "<addr> <freq> <center_freq1=> [center_freq2=] <bandwidth=>\n"
+	  "get unconnected station statistics" },
+	{ "sta_measurements", hostapd_cli_cmd_sta_measurements, NULL,
+	  "<BSS_name> <addr> get station measurements" },
+	{ "vap_measurements", hostapd_cli_cmd_vap_measurements, NULL,
+	  "<BSS_name> get VAP measurements" },
+	{ "radio_info", hostapd_cli_cmd_radio_info, NULL,
+	  "get radio info" },
+	{ "set_restricted_chan", hostapd_cli_cmd_set_restricted_chan, NULL,
+	  "[list_of_channels]"
+	  " set restricted channels, list_of_channels example 1 6 11-13" },
+	{ "get_restricted_chan", hostapd_cli_cmd_get_restricted_chan, NULL,
+	  " get list of restricted channels" },
 	{ NULL, NULL, NULL, NULL }
 };
 
diff --git a/hostapd/mxl_ctrl_iface.c b/hostapd/mxl_ctrl_iface.c
index 1d56c7a2f..2fda5d841 100644
--- a/hostapd/mxl_ctrl_iface.c
+++ b/hostapd/mxl_ctrl_iface.c
@@ -28,6 +28,8 @@
 #include "mxl_ctrl_iface.h"
 #include "ap/ctrl_iface_ap.h"
 #include "ap/mxl_softblock.h"
+#include "ap/mxl_rrm.h"
+
 
 struct hostapd_data *mxl_get_bss_index(const char *cmd, struct hostapd_iface *iface)
 {
@@ -650,6 +652,2041 @@ static int mxl_hostapd_ctrl_iface_get_sta_softblock(struct hostapd_data *hapd, c
 	return ret;
 }
 
+/* IEEE Std 802.11-2016, 9.6.2.2 Measurement Request frame format */
+#define WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MIN 0x01
+#define WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MAX 0xff
+
+/* IEEE Std 802.11-2016, 9.4.2.21 Measurement Request element */
+#define WLAN_RRM_RADIO_MEASUREMENT_REQUEST_TOKEN_VALUE_MIN 0x01
+#define WLAN_RRM_RADIO_MEASUREMENT_REQUEST_TOKEN_VALUE_MAX 0xff
+
+/* IEEE Std 802.11-2016, 9.4.2.22 Measurement Report element */
+#define WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MIN 0x00
+#define WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MAX 0xff
+
+/* IEEE Std 802.11-2016, 9.4.2.40 Antenna element */
+#define WLAN_RRM_RADIO_MEASUREMENT_REPORT_ANTENNA_ID_MIN 0x01
+#define WLAN_RRM_RADIO_MEASUREMENT_REPORT_ANTENNA_ID_MAX 0xff
+
+static int mxl_hostapd_ctrl_iface_report_beacon(struct hostapd_data *hapd,
+		char *cmd)
+{
+	char *token, *context = NULL;
+	char *pos, *cmd_end;
+	u8 addr[ETH_ALEN], bssid[ETH_ALEN];
+	int op_class, channel, measurement_duration, dialog_token;
+	int measurement_token, measurement_rep_mode;
+	rsize_t len;
+	int frame_info, rcpi, rsni, antenna_id;
+	u32 parent_tsf;
+	u64 start_time;
+	s64 val;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REPORT_BEACON ") - 1;
+
+	u8 channel_width, channel_center_frequency0, channel_center_frequency1;
+	u8 *channel_width_p = NULL;
+	u8 *channel_center_frequency0_p = NULL, *channel_center_frequency1_p = NULL;
+	u8 rep_frame_body_length,  rep_frame_body[256];
+	u8 *rep_frame_body_p = NULL, *rep_frame_body_length_p = NULL;
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REP_BEACON - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REP_BEACON - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - dialog token is missing");
+		return -1;
+	}
+	dialog_token = atoi(token);
+	if (!IS_VALID_U8_RANGE(dialog_token)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - dialog token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - measurement token is missing");
+		return -1;
+	}
+	measurement_token = atoi(token);
+	if (!IS_VALID_RANGE(measurement_token, WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - measurement token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - measurement mode is missing");
+		return -1;
+	}
+	measurement_rep_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_rep_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - measurement mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - operation class is missing");
+		return -1;
+	}
+
+	op_class = atoi(token);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - channel is missing");
+		return -1;
+	}
+	channel = atoi(token);
+	/* Quote from IEEE80211-16, 9.4.2.22.7 Beacon report
+	   "The Operating Class field indicates the operating class that identifies the channel set of the received Beacon
+	   or Probe Response frame. The Country, Operating Class, and Channel Number fields together specify the
+	   channel frequency and spacing of the received Beacon or Probe Response frame. Valid operating classes are
+	   listed in Annex E." */
+	if (ieee80211_chan_to_freq(NULL, op_class, channel) < 0) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - channel/op_class combination is invalid");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - start time is missing");
+		return -1;
+	}
+
+	/* Any unsigned long long value
+	   returned by strtoull is within valid range. */
+	start_time = strtoull(token, NULL, 10);
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REQ_BEACON - measurement duration out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - frame info is missing");
+		return -1;
+	}
+	frame_info = atoi(token);
+	if (!IS_VALID_U8_RANGE(frame_info)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - frame info is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - rcpi is missing");
+		return -1;
+	}
+	rcpi = atoi(token);
+	if (!IS_VALID_U8_RANGE(rcpi)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - rcpi is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - rsni is missing");
+		return -1;
+	}
+	rsni = atoi(token);
+	if (!IS_VALID_U8_RANGE(rsni)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - rsni is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, bssid)) {
+		wpa_printf(MSG_ERROR, "CTRL: REP_BEACON - bad BSSID address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - antenna id is missing");
+		return -1;
+	}
+	antenna_id = atoi(token);
+	if (!IS_VALID_U8_RANGE(antenna_id)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - antenna id is out of range");
+		return -1;
+	}
+
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REP_BEACON - parent tsf is missing");
+		return -1;
+	}
+
+	val = atoll(token);
+	if (!IS_VALID_U32_RANGE(val)) {
+		   wpa_printf(MSG_ERROR,
+					  "CTRL: REP_BEACON - parent tsf is out of range");
+		   return -1;
+	}
+	parent_tsf = (u32)val;
+
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REP_BEACON - wrong len");
+		return -1;
+	}
+	/* optional tokens */
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	pos = os_strstr(token, "rep_frame_body=");
+	if (pos) {
+		int length;
+		errno_t err;
+		char *end, *comma;
+		pos += 15;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REP_BEACON - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma = os_strchr(pos, ',');
+		if (!comma || comma == pos || comma >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REP_BEACON - reported frame body format is invalid");
+			return -1;
+		}
+		comma++;
+		length = atoi(pos);
+		if (!IS_VALID_U8_RANGE(length)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REP_BEACON - reported frame body length is invalid");
+			return -1;
+		}
+		err = memcpy_s(rep_frame_body, sizeof(rep_frame_body), comma, length);
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: CTRL: REP_BEACON - memcpy_s error %d", __func__, err) ;
+			return -1;
+		}
+		rep_frame_body_length = (u8) length;
+		rep_frame_body_length_p = &rep_frame_body_length;
+		rep_frame_body_p = (u8 *)rep_frame_body;
+	}
+
+	pos = os_strstr(token, "wide_band_ch_switch=");
+	if (pos) {
+		int ch_width, ch_center_freq0, ch_center_freq1;
+		char *end, *comma1, *comma2;
+		pos += 20;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REP_BEACON - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REP_BEACON - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REP_BEACON - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma2++;
+		ch_width = atoi(pos);
+		/* Quote from IEE80211-2016: "The subfields New Channel Width, New Channel Center Frequency Segment 0, and New Channel Center
+		   Frequency Segment 1 have the same definition, respectively, as Channel Width, Channel Center Frequency
+		   Segment 0, and Channel Center Frequency Segment 1 in the VHT Operation Information field, described in
+		   Table 9-252." */
+		if (!IS_VALID_RANGE(ch_width, VHT_OPER_CHANWIDTH_20_40MHZ, VHT_OPER_CHANWIDTH_80P80MHZ)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REP_BEACON - channel width is invalid");
+			return -1;
+		}
+		ch_center_freq0 = atoi(comma1);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq0) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REPORT_CHANNEL_LOAD - channel center frequency 0 is invalid");
+		} else {
+			channel_center_frequency0 = (u8) ch_center_freq0;
+			channel_center_frequency0_p = &channel_center_frequency0;
+		}
+
+		ch_center_freq1 = atoi(comma2);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq1) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REP_BEACON - channel center frequency 1 is invalid");
+		} else {
+			channel_center_frequency1 = (u8) ch_center_freq1;
+			channel_center_frequency1_p = &channel_center_frequency1;
+		}
+
+		channel_width = (u8) ch_width;
+		channel_width_p = &channel_width;
+	}
+
+exit:
+	return mxl_hostapd_send_beacon_report_resp(hapd, addr, dialog_token,
+			measurement_token, measurement_rep_mode, op_class, channel,
+			start_time, measurement_duration, frame_info, rcpi, rsni,
+			bssid, antenna_id, parent_tsf, channel_width_p,
+			channel_center_frequency0_p, channel_center_frequency1_p,
+			rep_frame_body_p, rep_frame_body_length_p);
+}
+
+static int mxl_hostapd_ctrl_iface_req_self_beacon(struct hostapd_data *hapd,
+		char *cmd)
+{
+	char *token, *context = NULL;
+	int random_interval, mode, measurement_duration;
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_SELF_BEACON - random interval is missing");
+		return -1;
+	}
+	random_interval = atoi(token);
+	if (!IS_VALID_U16_RANGE(random_interval)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_SELF_BEACON - random interval out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_SELF_BEACON - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REQ_SELF_BEACON - measurement duration out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_SELF_BEACON - mode is missing");
+		return -1;
+	}
+	if (!os_strcmp(token, "passive")) {
+		mode = 0;
+	} else if (!os_strcmp(token, "active")) {
+		mode = 1;
+	} else if (!os_strcmp(token, "table")) {
+		mode = 2;
+	} else {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - mode is invalid");
+		return -1;
+	}
+
+	return mxl_hostapd_handle_self_beacon_req(hapd, random_interval,
+			measurement_duration, mode);
+}
+
+static int mxl_hostapd_ctrl_iface_req_link_measurement(struct hostapd_data *hapd,
+		char *cmd, char *buf, size_t buflen)
+{
+	u8 addr[ETH_ALEN];
+	char *token, *context = NULL;
+	int ret_dialog_token;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_LINK_MEASUREMENT - Bad destination address");
+		return -1;
+	}
+
+	ret_dialog_token = mxl_hostapd_send_link_measurement_req(hapd, addr);
+
+	if (ret_dialog_token < 0)
+		return -1;
+	return sprintf_s(buf, buflen, "dialog_token=%d\n", ret_dialog_token);
+}
+
+static int mxl_hostapd_ctrl_iface_link_measurement_report(struct hostapd_data *hapd,
+		char *cmd)
+{
+	rsize_t len;
+	u8 addr[ETH_ALEN];
+	char *token, *context = NULL;
+	char *pos, *cmd_end;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("LINK_MEASUREMENT_REPORT ") - 1;
+	int val;
+
+	struct rrm_link_measurement_report link_msmt_report;
+	struct dmg_link_margin dmg_margin, *dmg_margin_p = NULL;
+	struct dmg_link_adaptation_ack dmg_ack, *dmg_ack_p = NULL;
+
+	os_memset(&link_msmt_report, 0, sizeof(link_msmt_report));
+	os_memset(&dmg_margin, 0, sizeof(dmg_margin));
+	os_memset(&dmg_ack, 0, sizeof(dmg_ack));
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: LINK_MEASUREMENT_REPORT - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: LINK_MEASUREMENT_REPORT - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - dialog token is missing");
+		return -1;
+	}
+	val = atoi(token);
+	if(!IS_VALID_RANGE(val, WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MIN,
+					   WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - dialog token is out of range");
+		return -1;
+	}
+	val = link_msmt_report.dialog_token;
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - rx_ant_id is missing");
+		return -1;
+	}
+	val = atoi(token);
+	if (!IS_VALID_RANGE(val, WLAN_RRM_RADIO_MEASUREMENT_REPORT_ANTENNA_ID_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_ANTENNA_ID_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - rx_ant_id is out of range");
+		return -1;
+	}
+	link_msmt_report.rx_ant_id = (u8)val;
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - tx_ant_id is missing");
+		return -1;
+	}
+	val = atoi(token);
+	if (!IS_VALID_RANGE(val, WLAN_RRM_RADIO_MEASUREMENT_REPORT_ANTENNA_ID_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_ANTENNA_ID_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - tx_ant_id is out of range");
+		return -1;
+	}
+	link_msmt_report.tx_ant_id = (u8)val;
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: LINK_MEASUREMENT_REPORT - rcpi is missing");
+		return -1;
+	}
+	val = atoi(token);
+	if (!IS_VALID_U8_RANGE(val)) {
+		wpa_printf(MSG_ERROR,
+			  "CTRL: LINK_MEASUREMENT_REPORT - rcpi is out of range");
+		return -1;
+	}
+	link_msmt_report.rcpi = (u8)val;
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - rsni is missing");
+		return -1;
+	}
+	val = atoi(token);
+	if (!IS_VALID_U8_RANGE(val)) {
+	       wpa_printf(MSG_ERROR,
+			  "CTRL: LINK_MEASUREMENT_REPORT - rsni out of range");
+	       return -1;
+	}
+	link_msmt_report.rsni = (u8)val;
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: LINK_MEASUREMENT_REPORT - wrong len");
+		return -1;
+	}
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: LINK_MEASUREMENT_REPORT - tpc_report is missing");
+		return -1;
+	}
+
+	pos = os_strstr(token, "tpc_report=");
+	if (pos) {
+		char *end, *comma;
+		pos += 11;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos -1)) {
+				wpa_printf(MSG_ERROR, "CTRL: LINK_MEASUREMENT_REPORT - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma = os_strchr(pos, ',');
+		if (!comma || comma == pos || comma >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - tpc_report format is invalid");
+			return -1;
+		}
+		val = atoi(pos);
+		if (!IS_VALID_U8_RANGE(val)) {
+			 wpa_printf(MSG_ERROR,
+				       "CTRL: LINK_MEASUREMENT_REPORT - tpc_report.tx_power is invalid");
+			return -1;
+		}
+		link_msmt_report.tpc.tx_power = (u8)val;
+		comma++;
+		val = atoi(comma);
+		if (!IS_VALID_U8_RANGE(val)) {
+			 wpa_printf(MSG_ERROR,
+					 "CTRL: LINK_MEASUREMENT_REPORT - tpc_report.link_margin is invalid");
+			return -1;
+		}
+		link_msmt_report.tpc.link_margin = (u8)val;
+		link_msmt_report.tpc.eid = WLAN_EID_TPC_REPORT;
+		link_msmt_report.tpc.len = 2;
+	}
+
+	/* optional tokens */
+	pos = os_strstr(token, "dmg_link_margin=");
+	if (pos) {
+		char *end, *comma1, *comma2, *comma3, *comma4;
+		pos += 16;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: LINK_MEASUREMENT_REPORT - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_link_margin format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_link_margin format is invalid");
+			return -1;
+		}
+		comma2++;
+		comma3 = os_strchr(comma2, ',');
+		if (!comma3 || comma3 == comma2 || comma3 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_link_margin format is invalid");
+			return -1;
+		}
+		comma3++;
+		comma4 = os_strchr(comma3, ',');
+		if (!comma4 || comma4 == comma3 || comma4 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_link_margin format is invalid");
+			return -1;
+		}
+		comma4++;
+		val = atoi(pos);
+		if (!IS_VALID_RANGE(val, 0, 6)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_margin.activity is invalid");
+			return -1;
+		}
+		dmg_margin.activity = (u8)val;
+		val = atoi(comma1);
+		if (!IS_VALID_U8_RANGE(val)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_margin.mcs is invalid");
+			return -1;
+		}
+		dmg_margin.mcs = (u8)val;
+		val = atoi(comma2);
+		if (!IS_VALID_S8_RANGE(dmg_margin.link_margin)) {
+			wpa_printf(MSG_ERROR,
+				       "CTRL: LINK_MEASUREMENT_REPORT - dmg_margin.link_margin is invalid");
+			return -1;
+		}
+		dmg_margin.link_margin = (s8)val;
+		val = atoi(comma3);
+		if (!IS_VALID_U8_RANGE(val)) {
+			wpa_printf(MSG_ERROR,
+				       "CTRL: LINK_MEASUREMENT_REPORT - dmg_margin.snr is invalid");
+			return -1;
+		}
+		dmg_margin.snr = (u8)val;
+		dmg_margin.ref_timestamp = atoi(comma4);
+		dmg_margin.eid = WLAN_EID_DMG_LINK_MARGIN;
+		dmg_margin.len = 8;
+		dmg_margin_p = &dmg_margin;
+	}
+
+	pos = os_strstr(token, "dmg_link_adapt_ack=");
+	if (pos) {
+		char *end, *comma;
+		pos += 19;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: LINK_MEASUREMENT_REPORT - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma = os_strchr(pos, ',');
+		if (!comma || comma == pos || comma >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_link_adapt_ack format is invalid");
+			return -1;
+		}
+		val = atoi(pos);
+		if (!IS_VALID_RANGE(val, 0, 6)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: LINK_MEASUREMENT_REPORT - dmg_ack.activity is invalid");
+			return -1;
+		}
+		dmg_ack.activity = (u8)val;
+		comma++;
+		dmg_ack.ref_timestamp = atoi(comma);
+		dmg_ack.eid = WLAN_EID_DMG_LINK_ADAPTATION_ACK;
+		dmg_ack.len = 5;
+		dmg_ack_p = &dmg_ack;
+	}
+
+	wpa_printf(MSG_DEBUG, MACSTR
+			" dialog_token=%d rx_ant_id=%d tx_ant_id=%d rcpi=%d rsni=%d tpc_report=%d,%d dmg_margin=%d,%d,%d,%d,%d dmg_ack=%d,%d",
+			MAC2STR(addr), link_msmt_report.dialog_token,
+			link_msmt_report.rx_ant_id, link_msmt_report.tx_ant_id,
+			link_msmt_report.rcpi, link_msmt_report.rsni,
+			link_msmt_report.tpc.tx_power, link_msmt_report.tpc.link_margin,
+			dmg_margin.activity, dmg_margin.mcs, dmg_margin.link_margin,
+			dmg_margin.snr, dmg_margin.ref_timestamp, dmg_ack.activity,
+			dmg_ack.ref_timestamp);
+
+	return mxl_hostapd_send_link_measurement_report(hapd, addr, link_msmt_report,
+			dmg_margin_p, dmg_ack_p);
+}
+
+static int mxl_hostapd_ctrl_iface_req_channel_load(struct hostapd_data *hapd,
+		char *cmd, char *buf, size_t buflen)
+{
+	u8 addr[ETH_ALEN];
+	rsize_t len;
+	char *token, *context = NULL;
+	char *pos, *cmd_end;
+	int op_class, channel, random_interval, measurement_duration;
+	int num_of_repetitions, measurement_request_mode;
+	int ret_dialog_token;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REQ_CHANNEL_LOAD ") - 1;
+
+	u8 rep_cond, ch_load_ref_val;
+	u8 *rep_cond_p = NULL, *ch_load_ref_val_p = NULL;
+
+	u8 channel_width, channel_center_frequency0, channel_center_frequency1;
+	u8 *channel_width_p = NULL;
+	u8 *channel_center_frequency0_p = NULL, *channel_center_frequency1_p = NULL;
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_CHANNEL_LOAD - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_CHANNEL_LOAD - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - number of repetitions is missing");
+		return -1;
+	}
+	num_of_repetitions = atoi(token);
+	if (!IS_VALID_U16_RANGE(num_of_repetitions)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - number of repetitions is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - measurement request mode is missing");
+		return -1;
+	}
+	measurement_request_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_request_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - measurement request mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - operating class is missing");
+		return -1;
+	}
+
+	op_class = atoi(token);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_CHANNEL_LOAD - channel is missing");
+		return -1;
+	}
+	channel = atoi(token);
+	/* Quote from IEEE80211-2016, 9.4.2.21.5 Channel Load request:
+	  "If the Wide Bandwidth Channel Switch subelement is not included, the Operating Class field indicates the
+	  operating class that identifies the channel set for which the measurement request applies. The Country,
+	  Operating Class, and Channel Number fields together specify the channel frequency and spacing for which
+	  the measurement request applies. Valid operating classes are listed in Annex E, excluding operating classes
+	  that encompass a primary channel but do not identify the location of the primary channel.
+	  Number field indicates the channel number for which the measurement request applies. The Channel number is
+	  defined within an operating class as shown in Annex E.*/
+	if (ieee80211_chan_to_freq(NULL, op_class, channel) < 0) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - channel/op_class combination is ivalid");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - random interval is missing");
+		return -1;
+	}
+	random_interval = atoi(token);
+	if (!IS_VALID_U16_RANGE(random_interval)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - random interval out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_CHANNEL_LOAD - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REQ_CHANNEL_LOAD - measurement duration out of range");
+		return -1;
+	}
+
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_CHANNEL_LOAD - wrong len");
+		return -1;
+	}
+	/* optional tokens */
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	pos = os_strstr(token, "ch_load_rep=");
+	if (pos) {
+		int cond, ref_val;
+		char *end, *comma;
+		pos += 12;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			end = pos + os_strlen(pos);
+		}
+		comma = os_strchr(pos, ',');
+		if (!comma || comma == pos || comma >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_CHANNEL_LOAD - channel load reporting format is invalid");
+			return -1;
+		}
+		cond = atoi(pos);
+		if (cond < 0 || cond > 2) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_CHANNEL_LOAD - channel load reporting condition is invalid");
+			return -1;
+		}
+		comma++;
+		ref_val = atoi(comma);
+		if (!IS_VALID_U8_RANGE(ref_val)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_CHANNEL_LOAD - channel load reporting ref val is invalid");
+			return -1;
+		}
+		rep_cond = (u8) cond;
+		rep_cond_p = &rep_cond;
+		ch_load_ref_val = (u8) ref_val;
+		ch_load_ref_val_p = &ch_load_ref_val;
+	}
+
+	pos = os_strstr(token, "wide_band_ch_switch=");
+	if (pos) {
+		int ch_width, ch_center_freq0, ch_center_freq1;
+		char *end, *comma1, *comma2;
+		pos += 20;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_CHANNEL_LOAD - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_CHANNEL_LOAD - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_CHANNEL_LOAD - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma2++;
+		ch_width = atoi(pos);
+		/* Quote from IEE80211-2016: "The subfields New Channel Width, New Channel Center Frequency Segment 0, and New Channel Center
+		   Frequency Segment 1 have the same definition, respectively, as Channel Width, Channel Center Frequency
+		   Segment 0, and Channel Center Frequency Segment 1 in the VHT Operation Information field, described in
+		   Table 9-252."*/
+		if (!IS_VALID_RANGE(ch_width, VHT_OPER_CHANWIDTH_20_40MHZ, VHT_OPER_CHANWIDTH_80P80MHZ)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_CHANNEL_LOAD - channel width is invalid");
+			return -1;
+		}
+
+		ch_center_freq0 = atoi(comma1);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq0) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REQ_CHANNEL_LOAD - channel center frequency 0 is invalid");
+		} else {
+			channel_center_frequency0 = (u8) ch_center_freq0;
+			channel_center_frequency0_p = &channel_center_frequency0;
+		}
+
+		ch_center_freq1 = atoi(comma2);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq1) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REQ_CHANNEL_LOAD - channel center frequency 1 is invalid");
+		} else {
+			channel_center_frequency1 = (u8) ch_center_freq1;
+			channel_center_frequency1_p = &channel_center_frequency1;
+		}
+
+		channel_width = (u8) ch_width;
+		channel_width_p = &channel_width;
+	}
+
+exit:
+	ret_dialog_token = mxl_hostapd_send_channel_load_req(hapd, addr,
+			num_of_repetitions, measurement_request_mode, op_class, channel,
+			random_interval, measurement_duration, rep_cond_p,
+			ch_load_ref_val_p, channel_width_p, channel_center_frequency0_p,
+			channel_center_frequency1_p);
+
+	if (ret_dialog_token < 0)
+		return -1;
+	return sprintf_s(buf, buflen, "dialog_token=%d\n", ret_dialog_token);
+}
+
+
+static int mxl_hostapd_ctrl_iface_report_channel_load(struct hostapd_data *hapd,
+		char *cmd)
+{
+	u8 addr[ETH_ALEN];
+	rsize_t len;
+	char *token, *context = NULL;
+	char *pos, *cmd_end;
+	int op_class, channel, measurement_duration;
+	int dialog_token, measurement_token, measurement_rep_mode, channel_load;
+	u64 start_time;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REPORT_CHANNEL_LOAD ") - 1;
+
+	u8 channel_width, channel_center_frequency0, channel_center_frequency1;
+	u8 *channel_width_p = NULL;
+	u8 *channel_center_frequency0_p = NULL, *channel_center_frequency1_p = NULL;
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_CHANNEL_LOAD - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_CHANNEL_LOAD - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - dialog_token is missing");
+		return -1;
+	}
+	dialog_token = atoi(token);
+	if (!IS_VALID_RANGE(dialog_token, WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - dialog_token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - measurement_token is missing");
+		return -1;
+	}
+	measurement_token = atoi(token);
+	if (!IS_VALID_RANGE(measurement_token, WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - measurement_token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - measurement_rep_mode is missing");
+		return -1;
+	}
+	measurement_rep_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_rep_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - measurement_rep_mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - operating class is missing");
+		return -1;
+	}
+
+	op_class = atoi(token);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_CHANNEL_LOAD - channel is missing");
+		return -1;
+	}
+
+	channel = atoi(token);
+	/* Quote from IEEE80211-2016, Chapter 9.4.2.22.5 Channel Load report:
+	   "If the Wide Bandwidth Channel Switch subelement is not included, the Operating Class field indicates the
+	   operating class that identifies the channel set for which the measurement report applies. The Country,
+	   Operating Class, and Channel Number fields together specify the channel frequency and spacing for which
+	   the measurement report applies. Valid operating classes are listed in Annex E, excluding operating classes
+	   that encompass a primary channel but do not identify the location of the primary channel. The Channel
+	   Number field indicates the channel number for which the measurement report applies. Channel number is
+	   defined within an operating class as shown in Annex E." */
+	if (ieee80211_chan_to_freq(NULL, op_class, channel) < 0) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - channel/op_class combination is invalid");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - start_time is missing");
+		return -1;
+	}
+
+	start_time = strtoull (token, NULL, 10);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REPORT_CHANNEL_LOAD - measurement duration out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_CHANNEL_LOAD - channel_load is missing");
+		return -1;
+	}
+	channel_load = atoi(token);
+	if (!IS_VALID_U8_RANGE(channel_load)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REPORT_CHANNEL_LOAD - channel_load out of range");
+		return -1;
+	}
+
+	/* optional tokens */
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_CHANNEL_LOAD - wrong len");
+		return -1;
+	}
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	pos = os_strstr(token, "wide_band_ch_switch=");
+	if (pos) {
+		int ch_width, ch_center_freq0, ch_center_freq1;
+		char *end, *comma1, *comma2;
+		pos += 20;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REPORT_CHANNEL_LOAD - wrong len");
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_CHANNEL_LOAD - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_CHANNEL_LOAD - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma2++;
+		ch_width = atoi(pos);
+		if (!IS_VALID_RANGE(ch_width, VHT_OPER_CHANWIDTH_20_40MHZ, VHT_OPER_CHANWIDTH_80P80MHZ)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_CHANNEL_LOAD - channel width is invalid");
+			return -1;
+		}
+
+		ch_center_freq0 = atoi(comma1);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq0) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REPORT_CHANNEL_LOAD - channel center frequency 0 is invalid");
+		} else {
+			channel_center_frequency0 = (u8) ch_center_freq0;
+			channel_center_frequency0_p = &channel_center_frequency0;
+		}
+
+		ch_center_freq1 = atoi(comma2);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq1) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REPORT_CHANNEL_LOAD - channel center frequency 1 is invalid");
+		} else {
+			channel_center_frequency1 = (u8) ch_center_freq1;
+			channel_center_frequency1_p = &channel_center_frequency1;
+		}
+
+		channel_width = (u8) ch_width;
+		channel_width_p = &channel_width;
+	}
+
+exit:
+	return mxl_hostapd_send_channel_load_report(hapd, addr, dialog_token,
+			measurement_token, measurement_rep_mode, op_class, channel,
+			start_time, measurement_duration, channel_load, channel_width_p,
+			channel_center_frequency0_p, channel_center_frequency1_p);
+}
+
+static int mxl_hostapd_ctrl_iface_req_noise_histogram(struct hostapd_data *hapd,
+		char *cmd, char *buf, size_t buflen)
+{
+	u8 addr[ETH_ALEN];
+	char *token, *context = NULL;
+	char *pos, *cmd_end;
+	int op_class, channel, random_interval, measurement_duration;
+	int num_of_repetitions, measurement_request_mode;
+	int ret_dialog_token, len;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REQ_NOISE_HISTOGRAM ") - 1;
+
+	u8 rep_cond, anpi_ref_val;
+	u8 *rep_cond_p = NULL, *anpi_ref_val_p = NULL;
+
+	u8 channel_width, channel_center_frequency0, channel_center_frequency1;
+	u8 *channel_width_p = NULL;
+	u8 *channel_center_frequency0_p = NULL, *channel_center_frequency1_p = NULL;
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_NOISE_HISTOGRAM - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_NOISE_HISTOGRAM - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - number of repetitions is missing");
+		return -1;
+	}
+	num_of_repetitions = atoi(token);
+	if (!IS_VALID_U16_RANGE(num_of_repetitions)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - number of repetitions is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - measurement request mode is missing");
+		return -1;
+	}
+	measurement_request_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_request_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - measurement request mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - operating class is missing");
+		return -1;
+	}
+
+	op_class = atoi(token);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_NOISE_HISTOGRAM - channel is missing");
+		return -1;
+	}
+
+	channel = atoi(token);
+	/* Quote from IEEE80211-2016, Chapter 9.4.2.21.6 Noise Histogram request:
+	   "If the Wide Bandwidth Channel Switch subelement is not included, the Operating Class field indicates the
+	   operating class that identifies the channel set for which the measurement report applies. The Country,
+	   Operating Class, and Channel Number fields together specify the channel frequency and spacing for which
+	   the measurement report applies. Valid operating classes are listed in Annex E, excluding operating classes
+	   that encompass a primary channel but do not identify the location of the primary channel. The Channel
+	   Number field indicates the channel number for which the measurement report applies. Channel number is
+	   defined within an operating class as shown in Annex E." */
+	if (ieee80211_chan_to_freq(NULL, op_class, channel) < 0) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - channel/op_class combination is invalid");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - random interval is missing");
+		return -1;
+	}
+	random_interval = atoi(token);
+	if (!IS_VALID_U16_RANGE(random_interval)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - random interval out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_NOISE_HISTOGRAM - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REQ_NOISE_HISTOGRAM - measurement duration out of range");
+		return -1;
+	}
+
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_NOISE_HISTOGRAM - wrong len");
+		return -1;
+	}
+	/* optional tokens */
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	pos = os_strstr(token, "noise_histogram_rep=");
+	if (pos) {
+		int cond, ref_val;
+		char *end, *comma;
+		pos += 20;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_NOISE_HISTOGRAM - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma = os_strchr(pos, ',');
+		if (!comma || comma == pos || comma >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_NOISE_HISTOGRAM - noise histogram reporting format is invalid");
+			return -1;
+		}
+		cond = atoi(pos);
+		if (cond < 0 || cond > 2) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_NOISE_HISTOGRAM - noise histogram reporting condition is invalid");
+			return -1;
+		}
+		comma++;
+		ref_val = atoi(comma);
+		if (!IS_VALID_U8_RANGE(ref_val)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_NOISE_HISTOGRAM - channel load reporting ref val is invalid");
+			return -1;
+		}
+		rep_cond = (u8) cond;
+		rep_cond_p = &rep_cond;
+		anpi_ref_val = (u8) ref_val;
+		anpi_ref_val_p = &anpi_ref_val;
+	}
+
+	pos = os_strstr(token, "wide_band_ch_switch=");
+	if (pos) {
+		int ch_width, ch_center_freq0, ch_center_freq1;
+		char *end, *comma1, *comma2;
+		pos += 20;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_NOISE_HISTOGRAM - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_NOISE_HISTOGRAM - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_NOISE_HISTOGRAM - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma2++;
+		ch_width = atoi(pos);
+		if (!IS_VALID_RANGE(ch_width, VHT_OPER_CHANWIDTH_20_40MHZ, VHT_OPER_CHANWIDTH_80P80MHZ)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_NOISE_HISTOGRAM - channel width is invalid");
+			return -1;
+		}
+
+		ch_center_freq0 = atoi(comma1);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq0) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REQ_NOISE_HISTOGRAM - channel center frequency 0 is invalid");
+		} else {
+			channel_center_frequency0 = (u8) ch_center_freq0;
+			channel_center_frequency0_p = &channel_center_frequency0;
+		}
+
+		ch_center_freq1 = atoi(comma2);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq1) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REQ_NOISE_HISTOGRAM - channel center frequency 1 is invalid");
+		} else {
+			channel_center_frequency1 = (u8) ch_center_freq1;
+			channel_center_frequency1_p = &channel_center_frequency1;
+		}
+
+		channel_width = (u8) ch_width;
+		channel_width_p = &channel_width;
+	}
+
+exit:
+	ret_dialog_token = mxl_hostapd_send_noise_histogram_req(hapd, addr,
+			num_of_repetitions, measurement_request_mode, op_class, channel,
+			random_interval, measurement_duration, rep_cond_p, anpi_ref_val_p,
+			channel_width_p, channel_center_frequency0_p,
+			channel_center_frequency1_p);
+
+	if (ret_dialog_token < 0)
+		return -1;
+	return sprintf_s(buf, buflen, "dialog_token=%d\n", ret_dialog_token);
+}
+
+static int mxl_hostapd_ctrl_iface_report_noise_histogram(struct hostapd_data *hapd,
+		char *cmd)
+{
+	u8 addr[ETH_ALEN];
+	rsize_t len;
+	char *token, *context = NULL, *ipi_density_pos;
+	char *pos, *cmd_end;
+	int op_class, channel, measurement_duration, anpi, ant_id;
+	int dialog_token, measurement_token, measurement_rep_mode, i, val;
+	u64 start_time;
+	u8 ipi_density[RRM_NOISE_HISTO_IPI_DENSITY_SIZE] = {};
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REPORT_NOISE_HISTOGRAM ") - 1;
+
+	u8 channel_width, channel_center_frequency0, channel_center_frequency1;
+	u8 *channel_width_p = NULL;
+	u8 *channel_center_frequency0_p = NULL, *channel_center_frequency1_p = NULL;
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_NOISE_HISTOGRAM - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_NOISE_HISTOGRAM - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - dialog_token is missing");
+		return -1;
+	}
+	dialog_token = atoi(token);
+	if (!IS_VALID_RANGE(dialog_token, WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - dialog_token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - measurement_token is missing");
+		return -1;
+	}
+	measurement_token = atoi(token);
+	if (!IS_VALID_RANGE(measurement_token, WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - measurement_token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - measurement_rep_mode is missing");
+		return -1;
+	}
+	measurement_rep_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_rep_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - measurement_rep_mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - operating class is missing");
+		return -1;
+	}
+
+	op_class = atoi(token);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_NOISE_HISTOGRAM - channel is missing");
+		return -1;
+	}
+	channel = atoi(token);
+	/* Quote from IEEE80211-2016, Chapter 9.4.2.22.6 Noise Histogram report:
+	   "If the Wide Bandwidth Channel Switch subelement is not included, the Operating Class field indicates the
+	   operating class that identifies the channel set for which the measurement report applies. The Country,
+	   Operating Class, and Channel Number fields together specify the channel frequency and spacing for which
+	   the measurement report applies. Valid operating classes are listed in Annex E, excluding operating classes
+	   that encompass a primary channel but do not identify the location of the primary channel. The Channel
+	   Number field indicates the channel number for which the measurement report applies. Channel number is
+	   defined within an operating class as shown in Annex E." */
+	if (ieee80211_chan_to_freq(NULL, op_class, channel) < 0) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - channel/op_class combination is invalid");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - start_time is missing");
+		return -1;
+	}
+	start_time = strtoull (token, NULL, 10);
+	if (start_time <= 0) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - start_time out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REPORT_NOISE_HISTOGRAM - measurement duration out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - ant_id is missing");
+		return -1;
+	}
+	ant_id = atoi(token);
+	if (!IS_VALID_U8_RANGE(ant_id)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REPORT_NOISE_HISTOGRAM - ant_id out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - anpi is missing");
+		return -1;
+	}
+	anpi = atoi(token);
+	if (!IS_VALID_U8_RANGE(anpi)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REPORT_NOISE_HISTOGRAM - anpi out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_NOISE_HISTOGRAM - ipi_density[0] is missing");
+		return -1;
+	}
+
+	val = atoi(token);
+	if (!IS_VALID_U8_RANGE(val)) {
+		wpa_printf(MSG_ERROR,
+			"CTRL: REPORT_NOISE_HISTOGRAM - ipi_density[0] is out of range");
+		return -1;
+	}
+	ipi_density[0] = (u8)val;
+	ipi_density_pos = token;
+	for (i = 1; i < RRM_NOISE_HISTO_IPI_DENSITY_SIZE; i++) {
+		ipi_density_pos = os_strchr(ipi_density_pos, ',');
+		if (!ipi_density_pos) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_NOISE_HISTOGRAM - ipi_density[%d] is missing", i);
+			return -1;
+		}
+		ipi_density_pos++;
+		val = atoi(ipi_density_pos);
+		if (!IS_VALID_U8_RANGE(val)) {
+			wpa_printf(MSG_ERROR,
+				"CTRL: REPORT_NOISE_HISTOGRAM - ipi_density[%d] is out of range", i);
+			return -1;
+		}
+		ipi_density[i] = (u8)val;
+	}
+
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_NOISE_HISTOGRAM - wrong len");
+		return -1;
+	}
+	/* optional tokens */
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	pos = os_strstr(token, "wide_band_ch_switch=");
+	if (pos) {
+		int ch_width, ch_center_freq0, ch_center_freq1;
+		char *end, *comma1, *comma2;
+		pos += 20;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REPORT_NOISE_HISTOGRAM - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_NOISE_HISTOGRAM - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_NOISE_HISTOGRAM - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma2++;
+		ch_width = atoi(pos);
+		if (!IS_VALID_RANGE(ch_width, VHT_OPER_CHANWIDTH_20_40MHZ, VHT_OPER_CHANWIDTH_80P80MHZ)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_NOISE_HISTOGRAM - channel width is invalid");
+			return -1;
+		}
+
+		ch_center_freq0 = atoi(comma1);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq0) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REPORT_NOISE_HISTOGRAM - channel center frequency 0 is invalid");
+		} else {
+			channel_center_frequency0 = (u8) ch_center_freq0;
+			channel_center_frequency0_p = &channel_center_frequency0;
+		}
+
+		ch_center_freq1 = atoi(comma2);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq1) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REPORT_NOISE_HISTOGRAM - channel center frequency 1 is invalid");
+		} else {
+			channel_center_frequency1 = (u8) ch_center_freq1;
+			channel_center_frequency1_p = &channel_center_frequency1;
+		}
+
+		channel_width = (u8) ch_width;
+		channel_width_p = &channel_width;
+	}
+
+exit:
+	return mxl_hostapd_send_noise_histogram_report(hapd, addr, dialog_token,
+			measurement_token, measurement_rep_mode, op_class, channel,
+			start_time, measurement_duration, ant_id, anpi, ipi_density,
+			channel_width_p, channel_center_frequency0_p,
+			channel_center_frequency1_p);
+}
+
+/* return -1 = error
+ * return 1 = optional element exist
+ * return 0 = optional element does not exist
+ */
+static int mxl_parse_trigger_reporting_counters(char *token, char *pos, char *str,
+		struct rrm_trig_rep_counters *trig_rep_counters)
+{
+	s64 val;
+	pos = os_strstr(token, str);
+	if (pos) {
+		int i, len;
+		char *end, *comma1, *comma2, *counter_pos;
+		pos += 22;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, MAX_BUFF_LEN);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, MAX_BUFF_LEN)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_STA_STATISTICS - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_STA_STATISTICS - trig_rep_counters format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_STA_STATISTICS - trig_rep_counters format is invalid");
+			return -1;
+		}
+		comma2++;
+
+		val = atoll(pos);
+		if (!IS_VALID_U32_RANGE(val)) {
+			   wpa_printf(MSG_ERROR,
+						  "CTRL: REQ_STA_STATISTICS - measurement_count is invalid");
+			   return -1;
+		}
+		(*trig_rep_counters).measurement_count = (u32)val;
+
+		val = atoi(comma1);
+		if (!IS_VALID_U16_RANGE(val)) {
+			wpa_printf(MSG_ERROR,
+				       "CTRL: REQ_STA_STATISTICS - trigger_timeout is invalid");
+			return -1;
+		}
+		(*trig_rep_counters).trigger_timeout = (u16)val;
+		val = atoi(comma2);
+		if (!IS_VALID_U16_RANGE(val)) {
+			wpa_printf(MSG_ERROR,
+				       "CTRL: REQ_STA_STATISTICS - counters_trigger_condition is invalid");
+			return -1;
+		}
+		(*trig_rep_counters).counters_trigger_condition = (u16)val;
+		counter_pos = comma2;
+		for (i = 0; i < 7; i++) {
+			if (((*trig_rep_counters).counters_trigger_condition >> i) & 1) {
+				counter_pos = os_strchr(counter_pos, ',');
+				if (!counter_pos || counter_pos == pos || counter_pos >= end) {
+					wpa_printf(MSG_ERROR,
+							"CTRL: REQ_STA_STATISTICS - rep_sta_counters.counters format is invalid");
+					return -1;
+				}
+				counter_pos++;
+				(*trig_rep_counters).counters[i] = atoi(counter_pos);
+				(*trig_rep_counters).num_of_counters++;
+			}
+		}
+
+		return 1;
+	}
+
+	return 0;
+}
+
+static int mxl_hostapd_ctrl_iface_req_sta_statistics(struct hostapd_data *hapd,
+		char *cmd, char *buf, size_t buflen)
+{
+	u8 addr[ETH_ALEN], peer_addr[ETH_ALEN];
+	char *token, *context = NULL;
+	int group_identity, random_interval, measurement_duration;
+	int num_of_repetitions, measurement_request_mode, ret;
+	char *pos, *cmd_end;
+	int ret_dialog_token;
+	rsize_t len;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REQ_STA_STATISTICS ") - 1;
+
+	struct rrm_trig_rep_counters trig_rep_sta_counters;
+	struct rrm_trig_rep_counters *trig_rep_sta_counters_p = NULL;
+	struct rrm_trig_rep_counters trig_rep_qos_sta_counters;
+	struct rrm_trig_rep_counters *trig_rep_qos_sta_counters_p = NULL;
+	struct rrm_trig_rep_counters trig_rep_rsna_counters;
+	struct rrm_trig_rep_counters *trig_rep_rsna_counters_p = NULL;
+
+	os_memset(&trig_rep_sta_counters, 0, sizeof(trig_rep_sta_counters));
+	os_memset(&trig_rep_qos_sta_counters, 0, sizeof(trig_rep_qos_sta_counters));
+	os_memset(&trig_rep_rsna_counters, 0, sizeof(trig_rep_rsna_counters));
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_STA_STATISTICS - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_STA_STATISTICS - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - number of repetitions is missing");
+		return -1;
+	}
+	num_of_repetitions = atoi(token);
+	if (!IS_VALID_U16_RANGE(num_of_repetitions)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - number of repetitions is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - measurement request mode is missing");
+		return -1;
+	}
+	measurement_request_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_request_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - measurement request mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, peer_addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_STA_STATISTICS - Bad peer address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - random interval is missing");
+		return -1;
+	}
+	random_interval = atoi(token);
+	if (!IS_VALID_U16_RANGE(random_interval)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - random interval out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REQ_STA_STATISTICS - measurement duration out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_STA_STATISTICS - channel is missing");
+		return -1;
+	}
+	group_identity = atoi(token);
+	if (!IS_VALID_U8_RANGE(group_identity)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_STA_STATISTICS - group_identity value is out of range");
+		return -1;
+	}
+
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_STA_STATISTICS - wrong len");
+		return -1;
+	}
+	/* optional tokens */
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	ret = mxl_parse_trigger_reporting_counters(token, pos, "trig_rep_sta_counters=",
+				&trig_rep_sta_counters);
+	if (ret == -1)
+		return ret;
+	else if (ret == 1)
+		trig_rep_sta_counters_p = &trig_rep_sta_counters;
+
+	ret = mxl_parse_trigger_reporting_counters(token, pos, "trig_rep_qos_sta_counters=",
+			&trig_rep_qos_sta_counters);
+	if (ret == -1)
+		return ret;
+	else if (ret == 1)
+		trig_rep_qos_sta_counters_p = &trig_rep_qos_sta_counters;
+
+	ret = mxl_parse_trigger_reporting_counters(token, pos, "trig_rep_rsna_counters=",
+			&trig_rep_rsna_counters);
+	if (ret == -1)
+		return ret;
+	else if (ret == 1)
+		trig_rep_rsna_counters_p = &trig_rep_rsna_counters;
+
+exit:
+	ret_dialog_token =  mxl_hostapd_send_sta_statistics_req(hapd, addr,
+			num_of_repetitions, measurement_request_mode, peer_addr,
+			random_interval, measurement_duration, group_identity,
+			trig_rep_sta_counters_p, trig_rep_qos_sta_counters_p,
+			trig_rep_rsna_counters_p);
+
+	if (ret_dialog_token < 0)
+		return -1;
+	return sprintf_s(buf, buflen, "dialog_token=%d\n", ret_dialog_token);
+}
+
+static int mxl_hostapd_ctrl_iface_report_sta_statistics(struct hostapd_data *hapd,
+		char *cmd)
+{
+	u8 addr[ETH_ALEN];
+	rsize_t len;
+	errno_t err;
+	char *token, *context = NULL;
+	char *pos, *cmd_end, *counter_pos;
+	int group_identity, measurement_duration, i;
+	int dialog_token, measurement_token, measurement_rep_mode;
+	u32 statistics_group_data[RRM_STA_STATISTICS_GROUP_DATA_SIZE] = {};
+	u32 statistics_group_data_len = 0;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REPORT_STA_STATISTICS ") - 1;
+
+	u8 rep_reason = 0, *rep_reason_p = NULL;
+	s64 val;
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_STA_STATISTICS - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_STA_STATISTICS - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - dialog_token is missing");
+		return -1;
+	}
+	dialog_token = atoi(token);
+	if (!IS_VALID_RANGE(dialog_token, WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_DIALOG_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - dialog_token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - measurement_token is missing");
+		return -1;
+	}
+	measurement_token = atoi(token);
+	if (!IS_VALID_RANGE(measurement_token, WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MIN,
+						WLAN_RRM_RADIO_MEASUREMENT_REPORT_TOKEN_VALUE_MAX)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - measurement_token is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - measurement_rep_mode is missing");
+		return -1;
+	}
+	measurement_rep_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_rep_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - measurement_rep_mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REPORT_STA_STATISTICS - measurement duration out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - group_identity is missing");
+		return -1;
+	}
+	group_identity = atoi(token);
+	if (!IS_VALID_U8_RANGE(group_identity)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - group_identity is out of range");
+		return -1;
+	}
+
+	statistics_group_data_len =
+			mxl_hostapd_get_statistics_group_data_len(group_identity);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - statistics_group_data[0] is missing");
+		return -1;
+	}
+
+	val = atoll(token);
+	if (!IS_VALID_U32_RANGE(val)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REPORT_STA_STATISTICS - statistics_group_data[0] is out of range");
+		return -1;
+	}
+	statistics_group_data[0] = (u32)val;
+
+	counter_pos = token;
+	for (i = 1; i < statistics_group_data_len; i++) {
+		counter_pos = os_strchr(counter_pos, ',');
+		if (!counter_pos) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_STA_STATISTICS - statistics_group_data[%d] is missing", i);
+			return -1;
+		}
+		counter_pos++;
+		if (((group_identity == 11) && ((i == 4) || (i == 8)))
+		  ||((group_identity == 12) && ((i == 2) || (i == 6)))) {
+			u64 tmp_counter = strtoull(counter_pos, NULL, 10);
+			err = memcpy_s(&statistics_group_data[i], sizeof(statistics_group_data),
+				&tmp_counter, sizeof(tmp_counter));
+			if (EOK != err) {
+				wpa_printf(MSG_ERROR, "%s: CTRL: REPORT_STA_STATISTICS - memcpy_s error %d", __func__, err);
+				return -1;
+			}
+			i++;
+		} else {
+			val = atoll(counter_pos);
+			if (!IS_VALID_U32_RANGE(val)) {
+				wpa_printf(MSG_ERROR,
+					   "CTRL: REPORT_STA_STATISTICS - statistics_group_data[%d] is out of range", i);
+				return -1;
+			}
+			statistics_group_data[i] = (u32)val;
+		}
+	}
+
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REPORT_STA_STATISTICS - wrong len");
+		return -1;
+	}
+	/* optional tokens */
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	pos = os_strstr(token, "rep_reason=");
+	if (pos) {
+		int value;
+		char *end;
+		pos += 11;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REPORT_STA_STATISTICS - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		value = atoi(pos);
+		if (!IS_VALID_U8_RANGE(value)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REPORT_STA_STATISTICS - rep_reason is invalid");
+			return -1;
+
+		}
+		rep_reason = (u8)value;
+		rep_reason_p = &rep_reason;
+	}
+
+exit:
+	return mxl_hostapd_send_sta_statistics_report(hapd, addr, dialog_token,
+			measurement_token, measurement_rep_mode, measurement_duration,
+			group_identity, statistics_group_data, statistics_group_data_len,
+			rep_reason_p);
+}
+
 int mxl_hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      char *buf, char *reply,
 					      int reply_size,
@@ -672,6 +2709,36 @@ int mxl_hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "GET_ZWDFS_ANT", 13) == 0) {
 		if (mxl_hostapd_ctrl_iface_get_zwdfs_antenna(hapd, reply, reply_size) < 0)
 			*reply_len = -1;
+	} else if (os_strncmp(buf, "REPORT_BEACON ", 14) == 0) {
+		if (mxl_hostapd_ctrl_iface_report_beacon(hapd, buf + 14))
+			*reply_len = -1;
+	} else if (os_strncmp(buf, "REQ_SELF_BEACON ", 16) == 0) {
+		if (mxl_hostapd_ctrl_iface_req_self_beacon(hapd, buf + 16))
+			*reply_len = -1;
+	} else if (os_strncmp(buf, "REQ_LINK_MEASUREMENT ", 21) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_req_link_measurement(hapd, buf + 21,
+				reply, reply_size);
+	} else if (os_strncmp(buf, "LINK_MEASUREMENT_REPORT ", 24) == 0) {
+		if (mxl_hostapd_ctrl_iface_link_measurement_report(hapd, buf + 24))
+			*reply_len = -1;
+	} else if (os_strncmp(buf, "REQ_CHANNEL_LOAD ", 17) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_req_channel_load(hapd, buf + 17,
+				reply, reply_size);
+	} else if (os_strncmp(buf, "REPORT_CHANNEL_LOAD ", 20) == 0) {
+		if (mxl_hostapd_ctrl_iface_report_channel_load(hapd, buf + 20))
+			*reply_len = -1;
+	} else if (os_strncmp(buf, "REQ_NOISE_HISTOGRAM ", 20) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_req_noise_histogram(hapd, buf + 20,
+				reply, reply_size);
+	} else if (os_strncmp(buf, "REPORT_NOISE_HISTOGRAM ", 23) == 0) {
+		if (mxl_hostapd_ctrl_iface_report_noise_histogram(hapd, buf + 23))
+			*reply_len = -1;
+	} else if (os_strncmp(buf, "REQ_STA_STATISTICS ", 19) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_req_sta_statistics(hapd, buf + 19,
+				reply, reply_size);
+	} else if (os_strncmp(buf, "REPORT_STA_STATISTICS ", 22) == 0) {
+		if (mxl_hostapd_ctrl_iface_report_sta_statistics(hapd, buf + 22))
+			*reply_len = -1;
 	} else if (os_strncmp(buf, "ACCEPT_ACL ", sizeof("ACCEPT_ACL ") - 1 ) == 0) {
 		char *buf_start,*mac;
 		int len;
@@ -789,6 +2856,377 @@ int mxl_hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	}
 	return 1;
 }
+
+int mxl_hostapd_ctrl_iface_req_beacon(struct hostapd_data *hapd,
+				 char *cmd, char *reply,
+				 size_t reply_size)
+{
+	u8 addr[ETH_ALEN], bssid[ETH_ALEN];
+	char *token, *context = NULL;
+	char *pos, *cmd_end;
+	int op_class, channel, random_interval, mode, measurement_duration;
+	rsize_t len;
+	struct wpa_ssid_value ssid, *ssid_p = NULL;
+	int num_of_repetitions, measurement_request_mode, last_indication = 0;
+	int ret_dialog_token;
+	char *buffer_end_address = cmd + MAX_BUFF_LEN - sizeof("REQ_BEACON ") - 1;
+
+	u8 rep_cond, rep_cond_threshold;
+	u8* rep_cond_p = NULL, *rep_cond_threshold_p = NULL;
+	u8 rep_detail;
+	u8* rep_detail_p = NULL;
+	u8 ap_ch_rep[255];
+	u8* ap_ch_rep_p = NULL;
+	unsigned int ap_ch_rep_len = 0;
+	u8 req_elem[255];
+	u8* req_elem_p = NULL;
+	unsigned int req_elem_len = 0;
+
+	u8 channel_width, channel_center_frequency0, channel_center_frequency1;
+	u8 *channel_width_p = NULL;
+	u8 *channel_center_frequency0_p = NULL, *channel_center_frequency1_p = NULL;
+
+	len = strnlen_s(cmd, buffer_end_address - cmd);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - cmd - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - wrong len");
+		return -1;
+	}
+	cmd_end = cmd + len;
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - Bad destination address");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REQ_BEACON - number of repetitions is missing");
+		return -1;
+	}
+	num_of_repetitions = atoi(token);
+	if (!IS_VALID_U16_RANGE(num_of_repetitions)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_BEACON - number of repetitions is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_BEACON - measurement request mode is missing");
+		return -1;
+	}
+	measurement_request_mode = atoi(token);
+	if (!IS_VALID_U8_RANGE(measurement_request_mode)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_BEACON - measurement request mode is out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_BEACON - operating class is missing");
+		return -1;
+	}
+
+	op_class = atoi(token);
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - channel is missing");
+		return -1;
+	}
+
+	channel = atoi(token);
+	/* Quote from 80211-2016, Chapter 9.4.2.21.7 Beacon request:
+	  "For operating classes that encompass a primary channel but do not identify the location of the primary
+	  channel, the Channel Number field value is either 0 or 255; otherwise, the Channel Number field value is 0,
+	  255, or the channel number for which the measurement request applies and is defined within an operating
+	  class as shown in Annex E." */
+	if(channel != 0 && channel != 255) {
+		if (ieee80211_chan_to_freq(NULL, op_class, channel) < 0) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - channel/op_class combination invalid");
+			return -1;
+		}
+	} else {
+		if (!IS_VALID_U8_RANGE(op_class)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - operation class is out of range");
+			return -1;
+		}
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_BEACON - random interval is missing");
+		return -1;
+	}
+	random_interval = atoi(token);
+	if (!IS_VALID_U16_RANGE(random_interval)) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_BEACON - random interval out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR,
+			   "CTRL: REQ_BEACON - measurement duration is missing");
+		return -1;
+	}
+	measurement_duration = atoi(token);
+	if (!IS_VALID_U16_RANGE(measurement_duration)) {
+		wpa_printf(MSG_ERROR,
+				"CTRL: REQ_BEACON - measurement duration out of range");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - mode is missing");
+		return -1;
+	}
+	if (!os_strcmp(token, "passive")) {
+		mode = 0;
+	} else if (!os_strcmp(token, "active")) {
+		mode = 1;
+	} else if (!os_strcmp(token, "table")) {
+		mode = 2;
+	} else {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - mode is invalid");
+		return -1;
+	}
+
+	token = str_token(cmd, " ", &context);
+	if (!token || hwaddr_aton(token, bssid)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - bad BSSID address");
+		return -1;
+	}
+
+	len = strnlen_s(token, buffer_end_address - token);
+	if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - token - 1)) {
+		wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - wrong len");
+		return -1;
+	}
+	/* optional tokens */
+	token = token + len + 1;
+	if (token >= cmd_end) {
+		/* we've reached the end of command (no optional arguments) */
+		goto exit;
+	}
+
+	pos = os_strstr(token, "ssid=");
+	if (pos) {
+		pos += 5;
+		if (ssid_parse(pos, &ssid)) {
+			wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - bad SSID");
+			return -1;
+		}
+		ssid_p = &ssid;
+	}
+
+	pos = os_strstr(token, "beacon_rep=");
+	if (pos) {
+		int cond, threshold;
+		char *end, *comma;
+		pos += 11;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos -1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma = os_strchr(pos, ',');
+		if (!comma || comma == pos || comma >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - report condition format is invalid");
+			return -1;
+		}
+		cond = atoi(pos);
+		if (!IS_VALID_RANGE(cond, 0, 10)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - report condition is invalid");
+			return -1;
+		}
+		comma++;
+		threshold = atoi(comma);
+		if (!IS_VALID_U8_RANGE(threshold)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - report condition threshold is invalid");
+			return -1;
+		}
+		rep_cond = (u8) cond;
+		rep_cond_p = &rep_cond;
+		rep_cond_threshold = (u8) threshold;
+		rep_cond_threshold_p = &rep_cond_threshold;
+	}
+
+	pos = os_strstr(token, "rep_detail=");
+	if (pos) {
+		pos += 11;
+		if ((pos[1] != ' ' && pos[1] != '\0') ||
+			(pos[0] != '0' && pos[0] != '1' && pos[0] != '2')) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - report detail value is invalid");
+			return -1;
+		}
+		rep_detail = *pos - '0';
+		rep_detail_p = &rep_detail;
+	}
+
+	pos = os_strstr(token, "ap_ch_report=");
+	if (pos) {
+		int ch;
+		char *end;
+		pos += 13;
+		ap_ch_rep_len = 0;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		while (pos && pos < end) {
+			ch = atoi(pos);
+			ap_ch_rep[ap_ch_rep_len++] = ch;
+			pos = os_strchr(pos, ',');
+			if (pos)
+				pos++;
+		}
+		if (ap_ch_rep_len) {
+			ap_ch_rep_p = ap_ch_rep;
+		} else {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - ap channel report invalid values");
+			return -1;
+		}
+	}
+
+	pos = os_strstr(token, "req_elements=");
+	if (pos) {
+		int elem;
+		char* end;
+		pos += 13;
+		req_elem_len = 0;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		while (pos && pos < end) {
+			elem = atoi(pos);
+			req_elem[req_elem_len++] = elem;
+			pos = os_strchr(pos, ',');
+			if (pos)
+				pos++;
+		}
+		if (req_elem_len) {
+			req_elem_p = req_elem;
+		}
+	}
+
+	pos = os_strstr(token, "wide_band_ch_switch=");
+	if (pos) {
+		int ch_width, ch_center_freq0, ch_center_freq1;
+		char *end, *comma1, *comma2;
+		pos += 20;
+		end = os_strchr(pos, ' ');
+		if (!end) {
+			len = strnlen_s(pos, buffer_end_address - pos);
+			if (!IS_VALID_RANGE(len, AP_MIN_VALID_CHAR, buffer_end_address - pos - 1)) {
+				wpa_printf(MSG_ERROR, "CTRL: REQ_BEACON - wrong len");
+				return -1;
+			}
+			end = pos + len;
+		}
+		comma1 = os_strchr(pos, ',');
+		if (!comma1 || comma1 == pos || comma1 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma1++;
+		comma2 = os_strchr(comma1, ',');
+		if (!comma2 || comma2 == comma1 || comma2 >= end) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - wide_band_ch_switch format is invalid");
+			return -1;
+		}
+		comma2++;
+		ch_width = atoi(pos);
+		/* Quote from IEE80211-2016, Chapter 9.4.2.161 Wide Bandwidth Channel Switch element:
+		   "The subfields New Channel Width, New Channel Center Frequency Segment 0, and New Channel Center
+		   Frequency Segment 1 have the same definition, respectively, as Channel Width, Channel Center Frequency
+		   Segment 0, and Channel Center Frequency Segment 1 in the VHT Operation Information field, described in
+		   Table 9-252." */
+		if (!IS_VALID_RANGE(ch_width, VHT_OPER_CHANWIDTH_20_40MHZ, VHT_OPER_CHANWIDTH_80P80MHZ)) {
+			wpa_printf(MSG_ERROR,
+					"CTRL: REQ_BEACON - channel width is invalid");
+			return -1;
+		}
+
+		ch_center_freq0 = atoi(comma1);
+		/* According to IEE80211-2016, Chapter 21.3.14 Channelization */
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq0) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REQ_BEACON - channel center frequency 0 is invalid");
+		} else {
+			channel_center_frequency0 = (u8) ch_center_freq0;
+			channel_center_frequency0_p = &channel_center_frequency0;
+		}
+
+		ch_center_freq1 = atoi(comma2);
+		if (ieee80211_chan_to_freq(NULL, op_class, ch_center_freq1) < 0) {
+			wpa_printf(MSG_WARNING,
+					"CTRL: REQ_BEACON - channel center frequency 1 is invalid");
+		} else {
+			channel_center_frequency1 = (u8) ch_center_freq1;
+			channel_center_frequency1_p = &channel_center_frequency1;
+		}
+
+		channel_width = (u8) ch_width;
+		channel_width_p = &channel_width;
+	}
+	pos = os_strstr(token, "last_indication=");
+	if (pos) {
+		pos += 16;
+		last_indication = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(last_indication)) {
+			wpa_printf(MSG_ERROR,
+				"CTRL: REQ_BEACON - last_indication invalid values");
+			return -1;
+		}
+	}
+
+exit:
+	ret_dialog_token = mxl_hostapd_send_beacon_req(hapd, addr, num_of_repetitions,
+			measurement_request_mode, op_class, channel, random_interval,
+			measurement_duration, mode, bssid, ssid_p, rep_cond_p,
+			rep_cond_threshold_p,rep_detail_p, ap_ch_rep_p, ap_ch_rep_len,
+			req_elem_p, req_elem_len, channel_width_p,
+			channel_center_frequency0_p, channel_center_frequency1_p,
+			last_indication);
+
+	if (ret_dialog_token < 0)
+		return -1;
+
+	return sprintf_s(reply, reply_size, "dialog_token=%d\n", ret_dialog_token);
+}
 int mxl_hostapd_ctrl_iface_acl_add_mac(struct mac_acl_entry **acl, int *num, const char *cmd)
 { return hostapd_ctrl_iface_acl_add_mac (acl, num, cmd); }
 int mxl_hostapd_ctrl_iface_acl_del_mac(struct mac_acl_entry **acl, int *num, const char *txtaddr)
diff --git a/hostapd/mxl_ctrl_iface.h b/hostapd/mxl_ctrl_iface.h
index 03b537e5c..3be5b9d67 100644
--- a/hostapd/mxl_ctrl_iface.h
+++ b/hostapd/mxl_ctrl_iface.h
@@ -25,5 +25,6 @@ int mxl_hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      int reply_size,
 					      int *reply_len);
 char * mxl_dfs_info(struct hostapd_channel_data *chan);
+int mxl_hostapd_ctrl_iface_req_beacon(struct hostapd_data *hapd, char *cmd, char *reply, size_t reply_size);
 
 #endif /* MXL_CTRL_IFACE_H */
diff --git a/hostapd/mxl_hostapd_cli.c b/hostapd/mxl_hostapd_cli.c
index 6549ba576..595f223fc 100644
--- a/hostapd/mxl_hostapd_cli.c
+++ b/hostapd/mxl_hostapd_cli.c
@@ -224,3 +224,132 @@ int mxl_hostapd_cli_cmd_get_sta_softblock(struct wpa_ctrl *ctrl, int argc, char
 	return mxl_wpa_ctrl_command(ctrl, cmd);
 }
 
+
+int mxl_hostapd_cli_cmd_req_beacon(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc == 2)
+		return mxl_hostapd_cli_cmd(ctrl, "REQ_BEACON", 2, argc, argv);
+
+	if (argc < 9) {
+		printf("Invalid req_beacon command: needs at least 9"
+			" arguments: - dest address, num of repetitions,"
+			" measurement request mode, operating class, channel,"
+			" random interval, measurement duration, mode, bssid,"
+			" + some optianl arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REQ_BEACON", 9, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_report_beacon(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 14) {
+		printf("Invalid report_beacon command: needs at least 14"
+			" arguments: - dest address, dialog_token, measurement"
+			" token, measurement report mode, operating class,"
+			" channel, start time, measurement duration, feame info,"
+			" rcpi, rsni, bssid, ant_id, tsf + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REPORT_BEACON", 14, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_req_self_beacon(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 3) {
+		printf("Invalid req_self_beacon command: needs at least 3 arguments: - random interval, measurement duration, mode\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REQ_SELF_BEACON", 3, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_req_link_measurement(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	char cmd[256];
+	int res;
+
+	if (argc != 1) {
+		printf("Invalid req_link_measurement command - requires destination address\n");
+		return -1;
+	}
+
+	res = sprintf_s(cmd, sizeof(cmd), "REQ_LINK_MEASUREMENT %s", argv[0]);
+	if (res <= 0) {
+		printf("%s: sprintf_s error %d", __func__, res);
+		return -1;
+	}
+	return mxl_wpa_ctrl_command(ctrl, cmd);
+}
+
+int mxl_hostapd_cli_cmd_link_measurement_report(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 7) {
+		printf("Invalid link_measurement_report command: needs at least 7 arguments: - dst address, dialog token, tx power, rx ant id, tx ant id, rcpi, rsni, tpc report + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "LINK_MEASUREMENT_REPORT", 7, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_req_channel_load(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 7) {
+		printf("Invalid req_channel_load command: needs at least 7 arguments: - dest address, number of repetitions, measurement request mode, operating class, channel, random interval, measurement duration, + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REQ_CHANNEL_LOAD", 7, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_report_channel_load(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 9) {
+		printf("Invalid req_channel_load command: needs at least 9 arguments: - dest address, dialog_token, measurement_token, measurement_rep_mode, op_class, channel, start time, duration, channel_load + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REPORT_CHANNEL_LOAD", 9, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_req_noise_histogram(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 7) {
+		printf("Invalid req_noise_histogram command: needs at least 7 arguments: - dest address, number of repetitions, measurement request mode, operating class, channel, random interval, measurement duration, + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REQ_NOISE_HISTOGRAM", 7, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_report_noise_histogram(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 11) {
+		printf("Invalid report_noise_histogram command: needs at least 11 arguments: - dest address, dialog_token, measurement_token, measurement_rep_mode, op_class, channel, start time, duration, ant_id, anpi, ipi + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REPORT_NOISE_HISTOGRAM", 11, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_req_sta_statistics(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 7) {
+		printf("Invalid req_sta_statistics command: needs at least 7 arguments: - dest address, number of repetitions, measurement request mode, peer mac address, random interval, measurement duration, group identity, + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REQ_STA_STATISTICS", 7, argc, argv);
+}
+
+int mxl_hostapd_cli_cmd_report_sta_statistics(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	if (argc < 7) {
+		printf("Invalid req_sta_statistics command: needs at least 7 arguments: - dest address, dialog_token, measurement_token, measurement_rep_mode, duration, group identity, sta statistics + some optional arguments\n");
+		return -1;
+	}
+
+	return mxl_hostapd_cli_cmd(ctrl, "REPORT_STA_STATISTICS", 7, argc, argv);
+}
diff --git a/hostapd/mxl_hostapd_cli.h b/hostapd/mxl_hostapd_cli.h
index 05af65db0..7978adf9e 100644
--- a/hostapd/mxl_hostapd_cli.h
+++ b/hostapd/mxl_hostapd_cli.h
@@ -44,6 +44,29 @@ int mxl_wpa_ctrl_command(struct wpa_ctrl *ctrl, const char *cmd);
 	  "<snrAuthHWM=x> <snrAuthLWM=x>]" },						\
 	{ "get_sta_softblock", mxl_hostapd_cli_cmd_get_sta_softblock, NULL,		\
 	  "<bss> <addr>" },								\
+	{ "req_beacon", mxl_hostapd_cli_cmd_req_beacon, NULL, \
+	  "= send beacon request" }, \
+	{ "report_beacon", mxl_hostapd_cli_cmd_report_beacon, NULL, \
+	  " = report beacon" }, \
+	{ "req_self_beacon", mxl_hostapd_cli_cmd_req_self_beacon, NULL, \
+	  " = request self beacon" }, \
+	{ "req_link_measurement", mxl_hostapd_cli_cmd_req_link_measurement, NULL, \
+	  " = request link measurements"}, \
+	{ "link_measurement_report", mxl_hostapd_cli_cmd_link_measurement_report, NULL, \
+	  " = request link measurements" }, \
+	{ "req_channel_load", mxl_hostapd_cli_cmd_req_channel_load, NULL, \
+	  " = request channel load" }, \
+	{ "report_channel_load", mxl_hostapd_cli_cmd_report_channel_load, NULL, \
+	  " = report channel load"}, \
+	{ "req_noise_histogram", mxl_hostapd_cli_cmd_req_noise_histogram, NULL, \
+	  " = request noise histogram"}, \
+	{ "report_noise_histogram", mxl_hostapd_cli_cmd_report_noise_histogram, NULL, \
+	  " = report noise histogram"}, \
+	{ "req_sta_statistics", mxl_hostapd_cli_cmd_req_sta_statistics, NULL, \
+	  " = request sta statistics"}, \
+	{ "report_sta_statistics", mxl_hostapd_cli_cmd_report_sta_statistics, NULL, \
+	  " = report sta statistics" }, \
+
 
 int mxl_hostapd_cli_cmd_get_hw_features(struct wpa_ctrl *ctrl, int argc, char *argv[]);
 int mxl_hostapd_cli_cmd_set_failsafe_chan(struct wpa_ctrl *ctrl, int argc, char *argv[]);
@@ -53,5 +76,16 @@ int mxl_hostapd_cli_cmd_set_zwdfs_antenna(struct wpa_ctrl *ctrl, int argc, char
 int mxl_hostapd_cli_cmd_get_zwdfs_antenna(struct wpa_ctrl *ctrl, int argc, char *argv[]);
 int mxl_hostapd_cli_cmd_sta_softblock(struct wpa_ctrl *ctrl, int argc, char *argv[]);
 int mxl_hostapd_cli_cmd_get_sta_softblock(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_req_beacon(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_report_beacon(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_req_self_beacon(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_req_link_measurement(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_link_measurement_report(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_req_channel_load(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_report_channel_load(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_req_noise_histogram(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_report_noise_histogram(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_req_sta_statistics(struct wpa_ctrl *ctrl, int argc, char *argv[]);
+int mxl_hostapd_cli_cmd_report_sta_statistics(struct wpa_ctrl *ctrl, int argc, char *argv[]);
 
 #endif /* MXL_HOSTAPD_CLI_H */
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index 8f9cc5b36..cfd00febf 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -430,7 +430,9 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta)
+		    int set,
+		    int ssi_signal,
+		    const u8 *link_addr, bool mld_link_sta)
 {
 	struct hostapd_sta_add_params params;
 
@@ -473,6 +475,7 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 	}
 #endif /* CONFIG_IEEE80211BE */
 
+	params.ssi_signal = ssi_signal;
 	return hapd->driver->sta_add(hapd->drv_priv, &params);
 }
 
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index 331b0eaf4..c43b48ab2 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -47,7 +47,7 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta);
+		    int set, int ssi_signal, const u8 *link_addr, bool mld_link_sta);
 int hostapd_set_privacy(struct hostapd_data *hapd, int enabled);
 int hostapd_set_generic_elem(struct hostapd_data *hapd, const u8 *elem,
 			     size_t elem_len);
@@ -419,6 +419,42 @@ hostapd_drv_set_band(struct hostapd_data *hapd, u32 band_mask)
 	return hapd->driver->set_band(hapd->drv_priv, band_mask);
 }
 
+static inline int hostapd_drv_sta_steer(struct hostapd_data *hapd,
+	struct multi_ap_blacklist* entry, const u8 *bssid)
+{
+	if (hapd->driver == NULL || hapd->driver->sta_steer == NULL)
+		return -ENOTSUP;
+
+	return hapd->driver->sta_steer(hapd->drv_priv, entry, bssid);
+}
+
+static inline int hostapd_drv_sta_allow(struct hostapd_data *hapd,
+	const u8 *stations, int count)
+{
+	if (hapd->driver == NULL || hapd->driver->sta_allow == NULL)
+		return -ENOTSUP;
+
+	return hapd->driver->sta_allow(hapd->drv_priv, stations, count);
+}
+
+static inline int hostapd_drv_unconnected_sta(struct hostapd_data *hapd,
+	struct intel_vendor_unconnected_sta_req_cfg *req)
+{
+	if (hapd->driver == NULL || hapd->driver->unconnected_sta == NULL)
+		return -ENOTSUP;
+
+	return hapd->driver->unconnected_sta(hapd->drv_priv, req);
+}
+
+static inline int hostapd_drv_get_capa(struct hostapd_data *hapd,
+	struct wpa_driver_capa *capa)
+{
+	if (hapd->driver == NULL || hapd->driver->get_capa == NULL)
+		return -ENOTSUP;
+
+	return hapd->driver->get_capa(hapd->drv_priv, capa);
+}
+
 #ifdef ANDROID
 static inline int hostapd_drv_driver_cmd(struct hostapd_data *hapd,
 					 char *cmd, char *buf, size_t buf_len)
diff --git a/src/ap/beacon.c b/src/ap/beacon.c
index 1fe965b93..7a19c4f00 100644
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -2708,6 +2708,16 @@ int ieee802_11_set_beacon(struct hostapd_data *hapd)
 	return 0;
 }
 
+/* only update beacon if started */
+int ieee802_11_update_beacon(struct hostapd_data *hapd)
+{
+	if(hapd->started && hapd->beacon_set_done &&
+	   ieee802_11_set_beacon(hapd) < 0) {
+		return -1;
+	}
+
+	return 0;
+}
 
 int ieee802_11_set_beacons(struct hostapd_iface *iface)
 {
diff --git a/src/ap/beacon.h b/src/ap/beacon.h
index b32b2a7d0..8c8a67dd7 100644
--- a/src/ap/beacon.h
+++ b/src/ap/beacon.h
@@ -18,6 +18,7 @@ void handle_probe_req(struct hostapd_data *hapd,
 void ieee802_11_set_beacon_per_bss_only(struct hostapd_data *hapd);
 int ieee802_11_set_beacon(struct hostapd_data *hapd);
 int ieee802_11_set_beacons(struct hostapd_iface *iface);
+int ieee802_11_update_beacon(struct hostapd_data *hapd);
 int ieee802_11_update_beacons(struct hostapd_iface *iface);
 int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 			       struct wpa_driver_ap_params *params);
diff --git a/src/ap/ctrl_iface_ap.c b/src/ap/ctrl_iface_ap.c
index 20dc2b01f..0403c9e8a 100644
--- a/src/ap/ctrl_iface_ap.c
+++ b/src/ap/ctrl_iface_ap.c
@@ -28,6 +28,10 @@
 #ifdef CONFIG_VENDOR_MXL
 #include "mxl_dfs_common.h"
 #endif /* CONFIG_VENDOR_MXL */
+//#include "../hostapd/ctrl_iface.h"
+//#ifdef CONFIG_VENDOR_MXL
+#include "../hostapd/mxl_ctrl_iface.h"
+//#endif /* CONFIG_VENDOR_MXL */
 
 
 static size_t hostapd_write_ht_mcs_bitmask(char *buf, size_t buflen,
@@ -297,6 +301,12 @@ static int hostapd_ctrl_iface_sta_mib(struct hostapd_data *hapd,
 	if (res >= 0)
 		len += res;
 
+	ret = os_snprintf(buf + len, buflen - len, "SignalStrength=%d\n",
+		(s32)sta->ssi_signal);
+	if (ret < 0 || (size_t) ret >= buflen - len)
+		return len;
+	len += ret;
+
 	len += hostapd_get_sta_info(hapd, sta, buf + len, buflen - len);
 
 #ifdef CONFIG_SAE
@@ -426,9 +436,21 @@ static int hostapd_ctrl_iface_sta_mib(struct hostapd_data *hapd,
 }
 
 
-int hostapd_ctrl_iface_sta_first(struct hostapd_data *hapd,
+int hostapd_ctrl_iface_sta_first(struct hostapd_data *hapd, const char *cmd,
 				 char *buf, size_t buflen)
 {
+	int ret;
+
+	hapd = mxl_get_bss_index(cmd, hapd->iface);
+	if (hapd == NULL) {
+		ret = sprintf_s(buf, buflen, "FAIL: bss index\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
 	return hostapd_ctrl_iface_sta_mib(hapd, hapd->sta_list, buf, buflen);
 }
 
@@ -475,18 +497,42 @@ int hostapd_ctrl_iface_sta(struct hostapd_data *hapd, const char *txtaddr,
 }
 
 
-int hostapd_ctrl_iface_sta_next(struct hostapd_data *hapd, const char *txtaddr,
+int hostapd_ctrl_iface_sta_next(struct hostapd_data *hapd, const char *cmd,
 				char *buf, size_t buflen)
 {
 	u8 addr[ETH_ALEN];
 	struct sta_info *sta;
 	int ret;
 
-	if (hwaddr_aton(txtaddr, addr) ||
+	hapd = mxl_get_bss_index(cmd, hapd->iface);
+	if (hapd == NULL) {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	cmd = os_strchr(cmd, ' ');
+	if (cmd)
+		cmd++;
+	else {
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return 0;
+		}
+		return ret;
+	}
+
+	if (hwaddr_aton(cmd, addr) ||
 	    (sta = ap_get_sta(hapd, addr)) == NULL) {
-		ret = os_snprintf(buf, buflen, "FAIL\n");
-		if (os_snprintf_error(buflen, ret))
+		ret = sprintf_s(buf, buflen, "FAIL\n");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
 			return 0;
+		}
 		return ret;
 	}
 
@@ -558,6 +604,16 @@ int hostapd_ctrl_iface_deauthenticate(struct hostapd_data *hapd,
 	wpa_dbg(hapd->msg_ctx, MSG_DEBUG, "CTRL_IFACE DEAUTHENTICATE %s",
 		txtaddr);
 
+	hapd = mxl_get_bss_index(txtaddr, hapd->iface);
+	if (hapd == NULL)
+		return -1;
+
+	txtaddr = os_strstr(txtaddr, " ");
+	if (txtaddr)
+		txtaddr++;
+	else
+		return -1;
+
 	if (hwaddr_aton(txtaddr, addr))
 		return -1;
 
@@ -620,6 +676,16 @@ int hostapd_ctrl_iface_disassociate(struct hostapd_data *hapd,
 	wpa_dbg(hapd->msg_ctx, MSG_DEBUG, "CTRL_IFACE DISASSOCIATE %s",
 		txtaddr);
 
+	hapd = mxl_get_bss_index(txtaddr, hapd->iface);
+	if (hapd == NULL)
+		return -1;
+
+	txtaddr = os_strstr(txtaddr, " ");
+	if (txtaddr)
+		txtaddr++;
+	else
+		return -1;
+
 	if (hwaddr_aton(txtaddr, addr))
 		return -1;
 
diff --git a/src/ap/ctrl_iface_ap.h b/src/ap/ctrl_iface_ap.h
index 614f0426c..b1c2015cd 100644
--- a/src/ap/ctrl_iface_ap.h
+++ b/src/ap/ctrl_iface_ap.h
@@ -9,11 +9,11 @@
 #ifndef CTRL_IFACE_AP_H
 #define CTRL_IFACE_AP_H
 
-int hostapd_ctrl_iface_sta_first(struct hostapd_data *hapd,
+int hostapd_ctrl_iface_sta_first(struct hostapd_data *hapd, const char *cmd,
 				 char *buf, size_t buflen);
 int hostapd_ctrl_iface_sta(struct hostapd_data *hapd, const char *txtaddr,
 			   char *buf, size_t buflen);
-int hostapd_ctrl_iface_sta_next(struct hostapd_data *hapd, const char *txtaddr,
+int hostapd_ctrl_iface_sta_next(struct hostapd_data *hapd, const char *cmd,
 				char *buf, size_t buflen);
 int hostapd_ctrl_iface_deauthenticate(struct hostapd_data *hapd,
 				      const char *txtaddr);
diff --git a/src/ap/dfs.c b/src/ap/dfs.c
index e5d112e79..716b4c3e4 100644
--- a/src/ap/dfs.c
+++ b/src/ap/dfs.c
@@ -1028,9 +1028,8 @@ static int hostapd_dfs_request_channel_switch(struct hostapd_iface *iface,
 		hostapd_disable_iface(iface);
 		return err;
 	}
-
 #ifdef CONFIG_VENDOR_MXL
-	(void)mxl_hostapd_drv_set_antenna(iface);
+	(void)mxl_hostapd_drv_set_antenna(iface, 0, 0);
 #endif /* CONFIG_VENDOR_MXL */
 	for (i = 0; i < iface->num_bss; i++) {
 		err = hostapd_switch_channel(iface->bss[i], &csa_settings);
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index 04c0ee0e5..479d5ea31 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -2185,6 +2185,37 @@ err:
 }
 #endif /* CONFIG_OWE */
 
+static void hostapd_event_ltq_unconnected_sta_rx(struct hostapd_data *hapd,
+	struct intel_vendor_unconnected_sta *unc_sta)
+{
+	int ret;
+	char buf[30];
+
+	/* Discard event if interface didn't finished initialization.
+	 * This may happen when driver sends irrelevant events due to station mode actions
+	 */
+	if (hapd->iface->state != HAPD_IFACE_ENABLED) {
+		wpa_printf(MSG_DEBUG, "discard driver event (%s) - interface not initialized yet", __FUNCTION__);
+		return;
+	}
+
+	ret = sprintf_s(buf, sizeof(buf), MACSTR, MAC2STR(unc_sta->addr));
+	if (ret <= 0) {
+		wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+		return;
+	}
+	wpa_msg(hapd->msg_ctx, MSG_INFO,
+		UNCONNECTED_STA_RSSI "%s rx_bytes=%llu rx_packets=%u "
+		"rssi=%d %d %d %d SNR=%d %d %d %d rate=%d",
+		buf, unc_sta->rx_bytes, unc_sta->rx_packets,
+		unc_sta->rssi[0], unc_sta->rssi[1], unc_sta->rssi[2], unc_sta->rssi[3],
+		unc_sta->noise[0] ? unc_sta->rssi[0] - unc_sta->noise[0] : 0, /* RSSI and noise to SNR */
+		unc_sta->noise[1] ? unc_sta->rssi[1] - unc_sta->noise[1] : 0, /* RSSI and noise to SNR */
+		unc_sta->noise[2] ? unc_sta->rssi[2] - unc_sta->noise[2] : 0, /* RSSI and noise to SNR */
+		unc_sta->noise[3] ? unc_sta->rssi[3] - unc_sta->noise[3] : 0, /* RSSI and noise to SNR */
+		unc_sta->rate);
+}
+
 void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 			  union wpa_event_data *data)
 {
@@ -2453,7 +2484,15 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 			else
 				hostapd_reconfig_encryption(hapd);
 			hapd->reenable_beacon = 1;
-			ieee802_11_set_beacon(hapd);
+			if (ieee802_11_update_beacon(hapd) < 0) {
+				hapd->iface->set_freq_done = 0;
+				hapd->beacon_set_done = 0;
+				hapd->reenable_beacon = 1;
+				hostapd_setup_interface_complete(hapd->iface, 0);
+			} else {
+				/* Required for FW add VAP bringup sequence */
+				hostapd_tx_queue_params(hapd);
+			}
 #ifdef NEED_AP_MLME
 		} else if (hapd->disabled && hapd->iface->cac_started) {
 			wpa_printf(MSG_DEBUG, "DFS: restarting pending CAC");
@@ -2514,6 +2553,10 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		hostapd_cleanup_cca_params(hapd);
 		break;
 #endif /* CONFIG_IEEE80211AX */
+	case EVENT_LTQ_UNCONNECTED_STA_RX:
+		hostapd_event_ltq_unconnected_sta_rx(hapd,
+			&data->unconnected_sta);
+		break;
 	default:
 		wpa_printf(MSG_DEBUG, "Unknown event %d", event);
 		break;
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 4448af2eb..696e8cf3f 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -648,6 +648,7 @@ void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
 	ap_list_deinit(iface);
 	sta_track_deinit(iface);
 	airtime_policy_update_deinit(iface);
+	iface->set_freq_done = 0;
 }
 
 
@@ -1599,9 +1600,9 @@ static int hostapd_setup_bss(struct hostapd_data *hapd, int first,
 }
 
 
-static void hostapd_tx_queue_params(struct hostapd_iface *iface)
+void hostapd_tx_queue_params(struct hostapd_data *hapd)
 {
-	struct hostapd_data *hapd = iface->bss[0];
+	struct hostapd_iface *iface = hapd->iface;
 	int i;
 	struct hostapd_tx_queue_params *p;
 
@@ -2352,8 +2353,9 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 	struct hostapd_data *hapd = iface->bss[0];
 	size_t j;
 	u8 *prev_addr;
-	int delay_apply_cfg = 0;
 	int res_dfs_offload = 0;
+	struct hostapd_channel_data *channel;
+	struct hostapd_hw_modes *cmode = hapd->iface->current_mode;
 
 	if (err)
 		goto fail;
@@ -2408,12 +2410,15 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 			wpa_printf(MSG_DEBUG,
 				   "%s: Mesh configuration will be applied while joining the mesh network",
 				   iface->bss[0]->conf->iface);
-			delay_apply_cfg = 1;
 		}
 #endif /* CONFIG_MESH */
 
-		if (!delay_apply_cfg &&
-		    hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
+		channel = mxl_hostapd_hw_get_channel_data(iface, iface->freq);
+		if (!channel)
+			goto fail;
+
+		if (!iface->set_freq_done) {
+			if (hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
 				     hapd->iconf->channel,
 				     hapd->iconf->enable_edmg,
 				     hapd->iconf->edmg_channel,
@@ -2427,9 +2432,68 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 					     hapd->iconf),
 				     hostapd_get_oper_centr_freq_seg1_idx(
 					     hapd->iconf))) {
-			wpa_printf(MSG_ERROR, "Could not set channel for "
-				   "kernel driver");
-			goto fail;
+				wpa_printf(MSG_ERROR, "Could not set channel for "
+					   "kernel driver");
+				goto fail;
+			}
+			iface->set_freq_done = 1;
+		} else {
+			struct csa_settings settings;
+			memset(&settings, 0, sizeof(settings));
+			if (hostapd_set_freq_params(&settings.freq_params,
+					hapd->iconf->hw_mode, iface->freq, hapd->iconf->channel,
+					hapd->iconf->enable_edmg,
+					hapd->iconf->edmg_channel,
+					hapd->iconf->ieee80211n, hapd->iconf->ieee80211ac, hapd->iconf->ieee80211ax,
+					hapd->iconf->ieee80211be,
+					hapd->iconf->secondary_channel,
+					hostapd_get_oper_chwidth(hapd->iconf),
+					hostapd_get_oper_centr_freq_seg0_idx(hapd->iconf),
+					hostapd_get_oper_centr_freq_seg1_idx(hapd->iconf),
+					cmode ? hapd->iface->current_mode->vht_capab : 0,
+					cmode ? &cmode->he_capab[IEEE80211_MODE_AP] : NULL,
+					cmode ? &cmode->eht_capab[IEEE80211_MODE_AP] : NULL)) {
+				wpa_printf(MSG_ERROR,
+						"hostapd_set_freq_params failed: mode=%i, freq=%i, "
+								"channel=%i, ht_enabled=%i, vht_enabled=%i, "
+								"sec_channel_offset=%i, vht_open_cwidth=%i, "
+								"center_segment0=%i, center_segment1=%i",
+						hapd->iconf->hw_mode, iface->freq, hapd->iconf->channel,
+						hapd->iconf->ieee80211n, hapd->iconf->ieee80211ac,
+						hapd->iconf->secondary_channel,
+						hostapd_get_oper_chwidth(hapd->iconf),
+						hostapd_get_oper_centr_freq_seg0_idx(hapd->iconf),
+						hostapd_get_oper_centr_freq_seg1_idx(hapd->iconf));
+
+				goto fail;
+			}
+
+			settings.cs_count = mxl_hostapd_get_cs_count(iface);
+
+			for (j = 0; j < iface->num_bss; j++) {
+				hapd = iface->bss[j];
+				res = hostapd_switch_channel(hapd, &settings);
+				if (res) {
+					wpa_printf(MSG_ERROR, "hostapd_switch_channel failed: freq=%i, "
+							"ht_enabled=%i, vht_enabled=%i, "
+							"sec_channel_offset=%i, vht_open_cwidth=%i, "
+							"center_freq1=%i, center_freq2=%i",
+							settings.freq_params.freq,
+							settings.freq_params.ht_enabled,
+							settings.freq_params.vht_enabled,
+							settings.freq_params.sec_channel_offset,
+							settings.freq_params.bandwidth,
+							settings.freq_params.center_freq1,
+							settings.freq_params.center_freq2);
+					goto fail;
+				}
+			}
+			hostapd_set_state(iface, HAPD_IFACE_ENABLED);
+			/* After calling hostapd_switch_channel
+			 * hostapd_setup_bss/ieee802_11_set_beacon will fail with:
+			 * "Cannot set beacons during CSA period", because hostapd_switch_channel
+			 * starts CSA, therefore we need to exit here. */
+			return 0;
 		}
 	}
 
@@ -2500,7 +2564,7 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 
 	hapd = iface->bss[0];
 
-	hostapd_tx_queue_params(iface);
+	hostapd_tx_queue_params(hapd);
 
 	ap_list_init(iface);
 
@@ -2571,8 +2635,11 @@ dfs_offload:
 	if (iface->interfaces && iface->interfaces->terminate_on_error > 0)
 		iface->interfaces->terminate_on_error--;
 
-	for (j = 0; j < iface->num_bss; j++)
+	for (j = 0; j < iface->num_bss; j++) {
 		hostapd_neighbor_set_own_report(iface->bss[j]);
+		hostapd_flush_old_stations(iface->bss[j], WLAN_REASON_PREV_AUTH_NOT_VALID);
+		hostapd_drv_sta_allow(hapd, NULL, 0);
+	}
 
 	if (iface->interfaces && iface->interfaces->count > 1)
 		ieee802_11_set_beacons(iface);
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index dc0d74883..e6a61e5f0 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -683,7 +683,8 @@ struct hostapd_iface {
 #ifdef CONFIG_VENDOR_MXL
 	struct mxl_hostapd_iface mxl_iface;
 #endif /* CONFIG_VENDOR_MXL */
-
+	int set_freq_done;
+	int block_tx; /* Is TX block on or off */
 };
 
 /* hostapd.c */
@@ -746,6 +747,9 @@ int hostapd_register_probereq_cb(struct hostapd_data *hapd,
 				 void *ctx);
 void hostapd_prune_associations(struct hostapd_data *hapd, const u8 *addr,
 				int mld_assoc_link_id);
+int hostapd_get_list(const char *s, char **e, struct hostapd_iface *iface,
+	int (*number_cb)(struct hostapd_iface*, int),
+	int (*range_cb)(struct hostapd_iface*, int, int));
 
 /* drv_callbacks.c (TODO: move to somewhere else?) */
 void hostapd_notify_assoc_fils_finish(struct hostapd_data *hapd,
@@ -810,4 +814,5 @@ int hostapd_link_remove(struct hostapd_data *hapd, u32 count);
 	if (false)
 #endif /* CONFIG_IEEE80211BE */
 
+void hostapd_tx_queue_params(struct hostapd_data *hapd);
 #endif /* HOSTAPD_H */
diff --git a/src/ap/hw_features.c b/src/ap/hw_features.c
index b08e74cc6..17c8ff1fa 100644
--- a/src/ap/hw_features.c
+++ b/src/ap/hw_features.c
@@ -1409,3 +1409,54 @@ int hostapd_hw_skip_mode(struct hostapd_iface *iface,
 	}
 	return 0;
 }
+
+#ifdef CONFIG_VENDOR_MXL
+/* wrappers to access static functions from MXL code */
+enum hostapd_chan_status mxl_hostapd_check_chans(struct hostapd_iface *iface) { return hostapd_check_chans(iface); }
+void mxl_hostapd_notify_bad_chans(struct hostapd_iface *iface) { hostapd_notify_bad_chans(iface); }
+#endif /* CONFIG_VENDOR_MXL */
+
+struct hostapd_channel_data* hostapd_hw_get_channel_data_from_ch(struct hostapd_iface *iface, int chan)
+{
+	int i;
+	struct hostapd_channel_data *ch;
+
+	if (!iface->current_mode)
+		return NULL;
+
+	for (i = 0; i < iface->current_mode->num_channels; i++) {
+		ch = &iface->current_mode->channels[i];
+		if (ch->chan == chan)
+			return ch;
+	}
+
+	return NULL;
+}
+
+/* Returns mask with lowest num_antennas bits of full_mask set */
+static u32 _hostapd_hw_get_antenna_mask (u32 full_mask, u32 num_antennas)
+{
+	u32 cur_bit, cur_mask, result = 0;
+
+	for (cur_bit = 0, cur_mask = 1; num_antennas && (cur_bit < (sizeof(result) << 3));
+		cur_bit++, cur_mask <<= 1) {
+		result |= full_mask & cur_mask;
+		if (full_mask & cur_mask)
+			num_antennas--;
+	}
+	return result;
+}
+
+int hostapd_hw_get_antenna_mask(struct hostapd_data *hapd, int tx_ant,
+	int rx_ant, u32 *tx_ant_mask, u32 *rx_ant_mask)
+{
+	int ret;
+	struct wpa_driver_capa capa;
+
+	ret = hostapd_drv_get_capa(hapd, &capa);
+	if (ret != 0)
+		return ret;
+	*tx_ant_mask = _hostapd_hw_get_antenna_mask(capa.available_antennas_tx, tx_ant);
+	*rx_ant_mask = _hostapd_hw_get_antenna_mask(capa.available_antennas_rx, rx_ant);
+	return 0;
+}
diff --git a/src/ap/hw_features.h b/src/ap/hw_features.h
index c682c6d20..0abc213c6 100644
--- a/src/ap/hw_features.h
+++ b/src/ap/hw_features.h
@@ -30,6 +30,9 @@ void hostapd_stop_setup_timers(struct hostapd_iface *iface);
 int hostapd_hw_skip_mode(struct hostapd_iface *iface,
 			 struct hostapd_hw_modes *mode);
 int hostapd_determine_mode(struct hostapd_iface *iface);
+struct hostapd_channel_data* hostapd_hw_get_channel_data_from_ch(struct hostapd_iface *iface, int chan);
+int hostapd_hw_get_antenna_mask(struct hostapd_data *hapd, int tx_ant,
+	int rx_ant, u32 *tx_ant_mask, u32 *rx_ant_mask);
 #else /* NEED_AP_MLME */
 static inline void
 hostapd_free_hw_features(struct hostapd_hw_modes *hw_features,
@@ -103,6 +106,16 @@ static inline int hostapd_determine_mode(struct hostapd_iface *iface)
 	return 0;
 }
 
+static inline struct hostapd_channel_data* hostapd_hw_get_channel_data_from_ch(struct hostapd_iface *iface, int chan)
+{
+	return NULL;
+}
+static inline int hostapd_hw_get_antenna_mask(struct hostapd_data *hapd, int tx_ant,
+	int rx_ant, u32 *tx_ant_mask, u32 *rx_ant_mask)
+{
+	return 0;
+}
+
 #endif /* NEED_AP_MLME */
 
 #endif /* HW_FEATURES_H */
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index 39f08fcbf..b77da4d6a 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -4742,7 +4742,9 @@ static int add_associated_sta(struct hostapd_data *hapd,
 			    sta->he_6ghz_capab,
 			    sta->flags | WLAN_STA_ASSOC, sta->qosinfo,
 			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
-			    set, mld_link_addr, mld_link_sta)) {
+			    set,
+			    sta->ssi_signal,
+			    mld_link_addr, mld_link_sta)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211, HOSTAPD_LEVEL_NOTICE,
 			       "Could not %s STA to kernel driver",
@@ -5531,6 +5533,7 @@ static void handle_assoc(struct hostapd_data *hapd,
 	}
 
 	sta->listen_interval = listen_interval;
+	sta->ssi_signal = rssi;
 
 	if (hapd->iface->current_mode &&
 	    hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211G)
@@ -6286,6 +6289,8 @@ int ieee802_11_mgmt(struct hostapd_data *hapd, const u8 *buf, size_t len,
 		return 0;
 	}
 
+	wpa_printf(MSG_EXCESSIVE, "mgmt::%s (%d), ssi_signal:%d", fc2str(fc), stype, ssi_signal);
+
 	if (hapd->iconf->track_sta_max_num)
 		sta_track_add(hapd->iface, mgmt->sa, ssi_signal);
 
@@ -6319,6 +6324,9 @@ int ieee802_11_mgmt(struct hostapd_data *hapd, const u8 *buf, size_t len,
 		ret = 1;
 		break;
 	case WLAN_FC_STYPE_ACTION:
+#ifdef CONFIG_VENDOR_MXL
+		mxl_hostapd_action_ssi_set(hapd, ssi_signal);
+#endif /* CONFIG_VENDOR_MXL */
 		wpa_printf(MSG_DEBUG, "mgmt::action");
 		ret = handle_action(hapd, mgmt, len, freq);
 		break;
diff --git a/src/ap/ieee802_11_auth.h b/src/ap/ieee802_11_auth.h
index 22ae1a9d3..7d1aa9341 100644
--- a/src/ap/ieee802_11_auth.h
+++ b/src/ap/ieee802_11_auth.h
@@ -40,4 +40,7 @@ void hostapd_acl_req_radius_psk(struct hostapd_data *hapd, const u8 *addr,
 				int key_mgmt, const u8 *anonce,
 				const u8 *eapol, size_t eapol_len);
 
+int mxl_ieee802_11_multi_ap_set_deny_mac(struct hostapd_data *hapd,
+	struct multi_ap_blacklist* entry, const u8 remove);
+
 #endif /* IEEE802_11_AUTH_H */
diff --git a/src/ap/mxl_dfs_common.c b/src/ap/mxl_dfs_common.c
index 708c81839..9efee7227 100644
--- a/src/ap/mxl_dfs_common.c
+++ b/src/ap/mxl_dfs_common.c
@@ -42,7 +42,7 @@ int mxl_hostapd_set_chan_dfs_state(struct hostapd_iface *iface, enum nl80211_dfs
 	return mxl_nl80211_set_channel_dfs_state(hapd->drv_priv, dfs_state, freq, dfs_time, dfs_debug);
 }
 
-int mxl_hostapd_drv_set_antenna(struct hostapd_iface *iface)
+int mxl_hostapd_drv_set_antenna(struct hostapd_iface *iface, u32 tx, u32 rx)
 {
 	int ret;
 	u32 rx_ant = iface->mxl_iface.failsafe.rx_ant;
diff --git a/src/ap/mxl_dfs_common.h b/src/ap/mxl_dfs_common.h
index c4e5a5fa7..25bc2bb20 100644
--- a/src/ap/mxl_dfs_common.h
+++ b/src/ap/mxl_dfs_common.h
@@ -23,7 +23,7 @@ enum mxl_hostapd_cac_finished_stat {
 	HOSTAPD_CAC_STAT_PAUSED  = 2
 };
 
-int mxl_hostapd_drv_set_antenna(struct hostapd_iface *iface);
+int mxl_hostapd_drv_set_antenna(struct hostapd_iface *iface, u32 tx, u32 rx);
 void mxl_hostapd_event_dfs_cac_paused(struct hostapd_data *hapd, struct dfs_event *radar);
 struct hostapd_channel_data *
 mxl_dfs_get_valid_channel_failsafe(struct hostapd_iface *iface,
diff --git a/src/ap/mxl_hostapd.c b/src/ap/mxl_hostapd.c
index 61657fa08..cb714ca73 100644
--- a/src/ap/mxl_hostapd.c
+++ b/src/ap/mxl_hostapd.c
@@ -513,3 +513,13 @@ void mxl_hostapd_alloc_bss_data(struct hostapd_data *hapd)
 {
 	dl_list_init(&hapd->mxl_data.multi_ap_blacklist);
 }
+
+void mxl_hostapd_action_ssi_set(struct hostapd_data *hapd, int action_ssi)
+{
+	hapd->mxl_data.action_ssi_signal = action_ssi;
+}
+
+int mxl_hostapd_action_ssi_get(struct hostapd_data *hapd)
+{
+	return hapd->mxl_data.action_ssi_signal;
+}
diff --git a/src/ap/mxl_hostapd.h b/src/ap/mxl_hostapd.h
index 10a2ed54b..8570b4232 100644
--- a/src/ap/mxl_hostapd.h
+++ b/src/ap/mxl_hostapd.h
@@ -74,6 +74,8 @@ struct mxl_hostapd_iface {
 	u64 drv_flags;
 	u8 require_omn; /* Variable to keep track whether OMN IE should be added or not */
 	int snr_db_current_frame; /* SNR value for the currently processed frame */
+	unsigned int self_beacon_req:1;
+	struct beacon_request last_beacon_req;
 };
 
 #define MAX_EVENT_MSG_LEN			512
@@ -102,6 +104,12 @@ struct mxl_hostapd_data {
 
 	/* Multi-AP blacklist */
 	struct dl_list multi_ap_blacklist;
+
+	int action_ssi_signal;
+	u8 link_measurement_token;
+	u8 channel_load_token;
+	u8 noise_histogram_token;
+	u8 sta_statistics_token;
 };
 
 int mxl_hostapd_drv_get_vendor_data(struct hostapd_data *hapd,
@@ -146,5 +154,7 @@ void mxl_hostapd_update_coc(struct hostapd_iface *iface, const u8 *data, size_t
 u8 * mxl_hostapd_eid_opmodenotif(struct hostapd_data *hapd, u8 *eid);
 void mxl_hostapd_interface_deinit(struct hostapd_iface *iface);
 void mxl_hostapd_alloc_bss_data(struct hostapd_data *hapd);
+void mxl_hostapd_action_ssi_set(struct hostapd_data *hapd, int action_ssi);
+int mxl_hostapd_action_ssi_get(struct hostapd_data *hapd);
 
 #endif /* MXL_HOSTAPD_H */
diff --git a/src/ap/mxl_rrm.c b/src/ap/mxl_rrm.c
new file mode 100644
index 000000000..43f14b1f4
--- /dev/null
+++ b/src/ap/mxl_rrm.c
@@ -0,0 +1,2113 @@
+/******************************************************************************
+
+         Copyright (c) 2020 - 2025, MaxLinear, Inc.
+         Copyright 2016 - 2020 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "common/mxl_wpa_ctrl.h"
+#include "hostapd.h"
+#include "ap_drv_ops.h"
+#include "sta_info.h"
+#include "mxl_rrm.h"
+
+/**
+ * "wide_band_ch_switch=%d,%d,%d" string length between 27 and 33 bytes
+ * WIDE_BAND_CH_SWICTH_DEBUG_STR_LEN = max-length + 1 (33 + 1);
+ */
+#define WIDE_BAND_CH_SWICTH_DEBUG_STR_LEN 34
+
+static void mxl_hostapd_build_beacon_report_resp(struct wpabuf *buf,
+		u8 measurement_token, u8 measurement_rep_mode, u8 op_class, u8 channel,
+		u64 start_time, u16 measurement_duration, u8 frame_info, u8 rcpi,
+		u8 rsni, const u8 *bssid, u8 antenna_id, u32 parent_tsf, u8 *ch_width,
+		u8 *ch_center_freq0, u8 *ch_center_freq1, u8 *rep_frame_body,
+		u8 *rep_frame_body_length);
+
+static void mxl_hostapd_memory_as_hex(char *buf, size_t buf_size, const u8 *address, int len)
+{
+	int curr_byte_index, ret;
+
+	for (curr_byte_index = 0; curr_byte_index < len; curr_byte_index++) {
+		ret = sprintf_s(&buf[curr_byte_index * 3], buf_size - curr_byte_index * 3, "%02x ",
+			  address[curr_byte_index]);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+}
+
+static void mxl_hostapd_send_general_rrm_report(struct hostapd_data *hapd,
+		const u8 *sta_addr,u8 dialog_token, u8 measurement_token,
+		u8 measurement_rep_mode, enum measure_type measure_type)
+{
+	struct wpabuf *buf;
+
+	/* Measurement report (3) + Measurement element(5) */
+	buf = wpabuf_alloc(3 + 5);
+	if (!buf) {
+		wpa_printf(MSG_ERROR, "send general rrm report - can't allocate buffer");
+		return;
+	}
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.3 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REPORT);
+	wpabuf_put_u8(buf, dialog_token);
+
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REPORT);
+	wpabuf_put_u8(buf, 3); /* Length */
+
+	wpabuf_put_u8(buf, measurement_token);
+	wpabuf_put_u8(buf, measurement_rep_mode);
+	wpabuf_put_u8(buf, measure_type);
+
+	hostapd_drv_send_action(hapd, hapd->iface->freq, 0, sta_addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+}
+
+static int mxl_hostapd_send_beacon_report_with_header(struct hostapd_data *hapd,
+		const u8 *addr, const u8* data, int len, u8 dialog_token)
+{
+	struct wpabuf *report;
+	struct sta_info *sta = NULL;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "beacon report response: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "beacon report response: Destination address is not connected");
+		return -1;
+	}
+
+	report = wpabuf_alloc(3 + len);
+	if (!report)
+		return -1;
+
+	wpabuf_put_u8(report, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(report, WLAN_RRM_RADIO_MEASUREMENT_REPORT);
+	wpabuf_put_u8(report, dialog_token);
+
+	if (len)
+		wpabuf_put_data(report, data, len);
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+					wpabuf_head(report), wpabuf_len(report));
+
+	wpabuf_free(report);
+	return ret;
+}
+
+static void mxl_hostapd_handle_sta_beacon_report_scan_results(struct hostapd_iface *iface)
+{
+	struct wpa_scan_results *scan_res = NULL;
+	struct wpabuf *buf;
+	const u8 *pos;
+	int i, len;
+	int ht = iface->bss[0]->iconf->ieee80211n
+			&& !iface->bss[0]->conf->disable_11n;
+	int vht = iface->bss[0]->iconf->ieee80211ac
+			&& !iface->bss[0]->conf->disable_11ac;
+	u8 op_class, channel, phy_type;
+	const u8 bssid[ETH_ALEN] = {};
+	int rrm_manipulate_measurement = iface->bss[0]->conf->mxl_bss_conf.rrm_manipulate_measurement;
+
+	phy_type = ieee80211_get_phy_type(iface->freq, ht, vht);
+	ieee80211_freq_to_channel_ext(iface->freq,
+			iface->bss[0]->iconf->secondary_channel,
+			hostapd_get_oper_chwidth(iface->bss[0]->iconf),
+			&op_class, &channel);
+
+	buf = wpabuf_alloc(3 + IEEE80211_MAX_MMPDU_SIZE);
+	if (!buf) {
+		wpa_printf(MSG_ERROR, "buffer allocation failed");
+		return;
+	}
+
+	scan_res = hostapd_driver_get_scan_results(iface->bss[0]);
+	if (!scan_res) {
+		wpa_printf(MSG_ERROR, "failed to get scan results");
+		wpabuf_free(buf);
+		return;
+	}
+
+	for (i = 0; i < scan_res->num; i++) {
+		struct wpa_scan_res *bss = scan_res->res[i];
+		if (bss->freq == iface->freq) {
+			u8 rcpi = rssi_to_rcpi(bss->level);
+			if (!rrm_manipulate_measurement) {
+				mxl_hostapd_build_beacon_report_resp(buf,
+						iface->mxl_iface.last_beacon_req.measurement_token, 0,
+						op_class, channel, bss->tsf, 0, phy_type, rcpi, 255,
+						bss->bssid, 0, 0, NULL, NULL, NULL, NULL, NULL);
+			} else {
+				wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO,
+						RRM_EVENT_BEACON_REQUEST_RXED MACSTR
+						" dialog_token=%d measurement_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d",
+						MAC2STR(iface->mxl_iface.last_beacon_req.src_addr),
+						iface->mxl_iface.last_beacon_req.dialog_token,
+						iface->mxl_iface.last_beacon_req.measurement_token,
+						0, op_class, channel, bss->tsf,
+						0, phy_type, rcpi, 255, MAC2STR(bss->bssid), 0, 0);
+			}
+		}
+	}
+
+	if (!rrm_manipulate_measurement) {
+		len = wpabuf_len(buf);
+		pos = wpabuf_head_u8(buf);
+		mxl_hostapd_send_beacon_report_with_header(iface->bss[0],
+				iface->mxl_iface.last_beacon_req.src_addr, pos, len,
+				iface->mxl_iface.last_beacon_req.dialog_token);
+	} else if (scan_res->num == 0) {
+		/* no results notifications */
+		wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO,
+				RRM_EVENT_BEACON_REQUEST_RXED MACSTR
+				" dialog_token=%d measurement_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%d duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d",
+				MAC2STR(iface->mxl_iface.last_beacon_req.src_addr),
+				iface->mxl_iface.last_beacon_req.dialog_token,
+				iface->mxl_iface.last_beacon_req.measurement_token,
+				0, op_class, channel, 0, 0, phy_type,
+				0, 0, MAC2STR(bssid), 0, 0);
+	}
+
+	wpa_scan_results_free(scan_res);
+	wpabuf_free(buf);
+}
+
+static int mxl_hostapd_handle_self_beacon_report_scan_results(struct hostapd_data *hapd)
+{
+	struct wpa_scan_results *scan_res = NULL;
+	int i, found_result = 0;
+	int ht = hapd->iconf->ieee80211n && !hapd->conf->disable_11n;
+	int vht = hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac;
+	u8 op_class, channel, phy_type;
+	const u8 bssid[ETH_ALEN] = {};
+
+	phy_type = ieee80211_get_phy_type(hapd->iface->freq, ht, vht);
+	ieee80211_freq_to_channel_ext(hapd->iface->freq,
+			hapd->iconf->secondary_channel, hostapd_get_oper_chwidth(hapd->iconf),
+			&op_class, &channel);
+
+	scan_res = hostapd_driver_get_scan_results(hapd);
+	if (!scan_res) {
+		wpa_printf(MSG_ERROR, "failed to get scan results");
+		return -1;
+	}
+
+	if (scan_res->num == 0) {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_SELF_BEACON_REP_RXED MACSTR
+					" measurement_rep_mode=%d op_class=%d channel=%d start_time=%d duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d",
+					MAC2STR(hapd->own_addr), 0, op_class, channel,
+					0, 0, phy_type, 0, 0, MAC2STR(bssid), 0, 0);
+		wpa_scan_results_free(scan_res);
+		return 0;
+	}
+
+	for (i = 0; i < scan_res->num; i++) {
+		struct wpa_scan_res *bss = scan_res->res[i];
+		if (bss->freq == hapd->iface->freq) {
+			u8 rcpi = rssi_to_rcpi(bss->level);
+			found_result = 1;
+			wpa_msg(hapd->msg_ctx, MSG_INFO,
+					RRM_EVENT_SELF_BEACON_REP_RXED MACSTR
+					" measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d",
+					MAC2STR(hapd->own_addr), 0, op_class, channel, bss->tsf, 0,
+					phy_type, rcpi, 255, MAC2STR(bss->bssid), 0, 0);
+		}
+	}
+
+	if (!found_result)
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_SELF_BEACON_REP_RXED MACSTR
+					" measurement_rep_mode=%d op_class=%d channel=%d start_time=%d duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d",
+					MAC2STR(hapd->own_addr), 0, op_class, channel,
+					0, 0, phy_type, 0, 0, MAC2STR(bssid), 0, 0);
+
+	wpa_scan_results_free(scan_res);
+	return 0;
+}
+
+static void mxl_hostapd_build_beacon_report_resp(struct wpabuf *buf,
+		u8 measurement_token, u8 measurement_rep_mode, u8 op_class, u8 channel,
+		u64 start_time, u16 measurement_duration, u8 frame_info, u8 rcpi,
+		u8 rsni, const u8 *bssid, u8 antenna_id, u32 parent_tsf, u8 *ch_width,
+		u8 *ch_center_freq0, u8 *ch_center_freq1, u8 *rep_frame_body,
+		u8 *rep_frame_body_length)
+{
+	u8 *len;
+
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REPORT);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+	wpabuf_put_u8(buf, measurement_token);
+	wpabuf_put_u8(buf, measurement_rep_mode); /* report mode */
+	wpabuf_put_u8(buf, MEASURE_TYPE_BEACON); /* report type */
+
+	wpabuf_put_u8(buf, op_class); /* op class */
+	wpabuf_put_u8(buf, channel); /* channel number */
+	wpabuf_put_data(buf, &start_time, 8); /* start time */
+	wpabuf_put_le16(buf, measurement_duration); /* duration */
+	wpabuf_put_u8(buf, frame_info); /* frame info */
+	wpabuf_put_u8(buf, rcpi); /* rcpi */
+	wpabuf_put_u8(buf, rsni); /* rsni */
+	wpabuf_put_data(buf, bssid, ETH_ALEN); /* bssid */
+	wpabuf_put_u8(buf, antenna_id); /* antenna id */
+	wpabuf_put_be32(buf, parent_tsf); /* parent TSF */
+
+	if (ch_width && ch_center_freq0 && ch_center_freq1) {
+		wpabuf_put_u8(buf, 163); /* wide bandwidth channel switch sub element id */
+		wpabuf_put_u8(buf, 5);   /* sub element length */
+		wpabuf_put_u8(buf, 194); /* wide bandwidth channel switch element id */
+		wpabuf_put_u8(buf, 3); 	 /* element length */
+		wpabuf_put_u8(buf, *ch_width);
+		wpabuf_put_u8(buf, *ch_center_freq0);
+		wpabuf_put_u8(buf, *ch_center_freq1);
+	}
+
+	if (rep_frame_body && rep_frame_body_length) {
+		wpabuf_put_u8(buf, 1); /* reported frame body subelemnt id */
+		wpabuf_put_u8(buf, *rep_frame_body_length);
+		wpabuf_put_data(buf, rep_frame_body, *rep_frame_body_length);
+	}
+
+	/* Action + measurement type + token + EID + len = 5 */
+	*len = wpabuf_len(buf) - 5;
+}
+
+
+int mxl_hostapd_send_beacon_report_resp(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u8 op_class, u8 channel, u64 start_time, u16 measurement_duration,
+		u8 frame_info, u8 rcpi, u8 rsni, const u8 *bssid, u8 antenna_id,
+		u32 parent_tsf, u8 *ch_width, u8 *ch_center_freq0, u8 *ch_center_freq1,
+		u8 *rep_frame_body, u8 *rep_frame_body_length)
+{
+	struct wpabuf *buf;
+	int ret;
+	int len;
+	const u8 *pos;
+
+	buf = wpabuf_alloc(3 + IEEE80211_MAX_MMPDU_SIZE);
+	if (!buf)
+		return -1;
+
+	mxl_hostapd_build_beacon_report_resp(buf, measurement_token,
+			measurement_rep_mode, op_class, channel, start_time,
+			measurement_duration, frame_info, rcpi, rsni, bssid, antenna_id,
+			parent_tsf, ch_width, ch_center_freq0, ch_center_freq1,
+			rep_frame_body, rep_frame_body_length);
+
+	len = wpabuf_len(buf);
+	pos = wpabuf_head_u8(buf);
+
+	ret = mxl_hostapd_send_beacon_report_with_header(hapd, addr, pos, len,
+			dialog_token);
+
+	wpabuf_free(buf);
+	return ret;
+}
+
+int mxl_hostapd_send_beacon_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode,
+		u8 oper_class, u8 channel, u16 random_interval,
+		u16 measurement_duration, u8 mode, const u8* bssid,
+		struct wpa_ssid_value* ssid, u8* rep_cond, u8* rep_cond_threshold,
+		u8* rep_detail,	const u8* ap_ch_rep, unsigned int ap_ch_rep_len,
+		const u8* req_elem, unsigned int req_elem_len, u8 *ch_width,
+		u8 *ch_center_freq0, u8 *ch_center_freq1, u8 last_indication)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	u8 *len;
+	int ret, i;
+	const u8 wildcard_bssid[ETH_ALEN] = {
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+	};
+
+	wpa_printf(MSG_DEBUG, "Request beacon: dest addr: " MACSTR ", mode: %d",
+			MAC2STR(addr), mode);
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "Request beacon: Destination address is not connected");
+		return -1;
+	}
+
+	if ((mode == BEACON_REPORT_MODE_PASSIVE &&
+		!(sta->rrm_enabled_capa[0] & WLAN_RRM_CAPS_BEACON_REPORT_PASSIVE))
+		|| (mode == BEACON_REPORT_MODE_ACTIVE &&
+		!(sta->rrm_enabled_capa[0] & WLAN_RRM_CAPS_BEACON_REPORT_ACTIVE))
+		|| (mode == BEACON_REPORT_MODE_TABLE &&
+		!(sta->rrm_enabled_capa[0] & WLAN_RRM_CAPS_BEACON_REPORT_TABLE)))
+	{
+		wpa_printf(MSG_ERROR,
+			   "Request beacon: Destination station does not support BEACON report (mode %d) in RRM",
+			   mode);
+		return -1;
+	}
+
+	if (channel == 255 && !ap_ch_rep) {
+		wpa_printf(MSG_ERROR,
+			   "Request beacon: channel set to 255, but no ap channel report data provided");
+		return -1;
+	}
+
+	/* Measurement request (5) + Measurement element with beacon (18) + optional sub-elements (255)*/
+	buf = wpabuf_alloc(5 + 18 + 255);
+	if (!buf)
+		return -1;
+
+	hapd->beacon_req_token++;
+	if (!hapd->beacon_req_token) /* For wraparounds */
+		hapd->beacon_req_token++;
+
+	/* IEEE P802.11-REVmc/D5.0, 9.6.7.2 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REQUEST);
+	wpabuf_put_u8(buf, hapd->beacon_req_token);
+	wpabuf_put_le16(buf, num_of_repetitions);
+
+	/* IEEE P802.11-REVmc/D5.0, 9.4.2.21 */
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REQUEST);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+
+	wpabuf_put_u8(buf, hapd->beacon_req_token); /* Measurement Token */
+	wpabuf_put_u8(buf, measurement_request_mode);
+	wpabuf_put_u8(buf, MEASURE_TYPE_BEACON);
+
+	/* IEEE P802.11-REVmc/D4.0, 8.4.2.20.7 */
+	wpabuf_put_u8(buf, oper_class);
+	wpabuf_put_u8(buf, channel);
+	wpabuf_put_le16(buf, random_interval);
+	wpabuf_put_le16(buf, measurement_duration);
+	wpabuf_put_u8(buf, mode); /* Measurement Mode */
+	if (!bssid) {
+		/* use wildcard BSSID instead of a specific BSSID */
+		bssid = wildcard_bssid;
+	}
+	wpabuf_put_data(buf, bssid, ETH_ALEN);
+
+	/* optional sub-elements should go here */
+
+	if (ssid) {
+		wpabuf_put_u8(buf, WLAN_BEACON_REQUEST_SUBELEM_SSID);
+		wpabuf_put_u8(buf, ssid->ssid_len);
+		wpabuf_put_data(buf, ssid->ssid, ssid->ssid_len);
+	}
+
+	/*
+	 * Note:
+	 * The Beacon Reporting subelement indicates the condition for issuing a
+	 * Beacon report. The Beacon Reporting subelement is optionally present in
+	 * a Beacon request for repeated measurements; otherwise it is not present.
+	 * Mandatory for MBO test plan, redundant according to specifications.
+	 */
+	if (rep_cond && *rep_cond <= 10 && rep_cond_threshold) {
+		wpabuf_put_u8(buf, WLAN_BEACON_REQUEST_SUBELEM_INFO);
+		wpabuf_put_u8(buf, 2);
+		wpabuf_put_u8(buf, *rep_cond);
+		wpabuf_put_u8(buf, *rep_cond_threshold);
+	}
+
+	if (rep_detail && (*rep_detail == 0 || *rep_detail == 1 || *rep_detail == 2)) {
+		wpabuf_put_u8(buf, WLAN_BEACON_REQUEST_SUBELEM_DETAIL);
+		wpabuf_put_u8(buf, 1);
+		wpabuf_put_u8(buf, *rep_detail);
+	}
+
+	if (req_elem && req_elem_len) {
+		wpabuf_put_u8(buf, WLAN_BEACON_REQUEST_SUBELEM_REQUEST);
+		wpabuf_put_u8(buf, req_elem_len); /* size */
+		wpabuf_put_data(buf, req_elem, req_elem_len); /* data */
+	}
+
+	/* in case channel is not 255, this IE is omitted */
+	if (ap_ch_rep && ap_ch_rep_len && channel == 255) {
+		wpabuf_put_u8(buf, WLAN_BEACON_REQUEST_SUBELEM_AP_CHANNEL);
+		wpabuf_put_u8(buf, ap_ch_rep_len + 1);
+		wpabuf_put_u8(buf, oper_class);
+		wpabuf_put_data(buf, ap_ch_rep, ap_ch_rep_len);
+	}
+
+	if (ch_width && ch_center_freq0 && ch_center_freq1) {
+		wpabuf_put_u8(buf, WLAN_BEACON_REQUEST_SUBELEM_WIDE_BW_CS); /* wide bandwidth channel switch sub element id */
+		wpabuf_put_u8(buf, 5);   /* sub element length */
+		wpabuf_put_u8(buf, WLAN_EID_WIDE_BW_CHSWITCH); /* wide bandwidth channel switch element id */
+		wpabuf_put_u8(buf, 3); 	 /* element length */
+		wpabuf_put_u8(buf, *ch_width);
+		wpabuf_put_u8(buf, *ch_center_freq0);
+		wpabuf_put_u8(buf, *ch_center_freq1);
+	}
+
+	if (last_indication) {
+		wpabuf_put_u8(buf, WLAN_BEACON_REQUEST_SUBELEM_LAST_INDICATION);
+		wpabuf_put_u8(buf, 1); /* size */
+		wpabuf_put_u8(buf, last_indication);
+	}
+
+	/* Action + measurement type + token + reps + EID + len = 7 */
+	*len = wpabuf_len(buf) - 7;
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	if (ret)
+		return -1;
+
+	return hapd->beacon_req_token;
+}
+
+static void mxl_rrm_reset_scan_callback(struct hostapd_iface *iface)
+{
+#ifdef CONFIG_ACS
+	iface->scan_cb = NULL;
+#else
+	iface->scan_cb = NULL;
+#endif
+}
+
+static void mxl_rrm_current_channel_scan_complete(struct hostapd_iface *iface)
+{
+	if (iface->mxl_iface.self_beacon_req) {
+		mxl_hostapd_handle_self_beacon_report_scan_results(iface->bss[0]);
+	} else {
+		mxl_hostapd_handle_sta_beacon_report_scan_results(iface);
+	}
+	mxl_rrm_reset_scan_callback(iface);
+}
+
+static int mxl_rrm_current_channel_request_scan(struct hostapd_iface *iface)
+{
+	struct wpa_driver_scan_params params;
+
+	os_memset(&params, 0, sizeof(params));
+	params.freqs = os_calloc(1 + 1, sizeof(params.freqs[0]));
+	if (params.freqs == NULL)
+		return -1;
+
+	params.freqs[0] = iface->freq;
+	iface->scan_cb = mxl_rrm_current_channel_scan_complete;
+
+	if (hostapd_driver_scan(iface->bss[0], &params) < 0) {
+		wpa_printf(MSG_ERROR, "RRM: Failed to request scan");
+		os_free(params.freqs);
+		return -1;
+	}
+
+	os_free(params.freqs);
+	return 0;
+}
+
+static void mxl_hostapd_handle_beacon_report_request(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr,
+		u16 num_of_repetition)
+{
+	u8 channel, measurement_token, beacon_measurement_mode;
+	int ret;
+	errno_t err;
+
+	measurement_token = pos[0];
+	channel = pos[4];
+	beacon_measurement_mode = pos[9];
+
+	if ((beacon_measurement_mode == BEACON_REPORT_MODE_PASSIVE &&
+		!(hapd->conf->radio_measurements[0] & WLAN_RRM_CAPS_BEACON_REPORT_PASSIVE))
+		|| (beacon_measurement_mode == BEACON_REPORT_MODE_TABLE &&
+		!(hapd->conf->radio_measurements[0] & WLAN_RRM_CAPS_BEACON_REPORT_TABLE))
+		|| (beacon_measurement_mode == BEACON_REPORT_MODE_ACTIVE))
+	{
+		wpa_printf(MSG_ERROR, "beacon report in RRM is not supported");
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE,
+				MEASURE_TYPE_BEACON);
+		return;
+	}
+
+	if ((channel != hapd->iface->conf->channel)
+			&& (channel != 0) && (channel != 255)) {
+		wpa_printf(MSG_DEBUG, "requested channel (%d) is not supported, only the current AP channel (%d) is supported",
+				channel, hapd->iface->conf->channel);
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_REFUSED,
+				MEASURE_TYPE_BEACON);
+		return;
+	}
+
+	err = memcpy_s(hapd->iface->mxl_iface.last_beacon_req.src_addr,
+		 sizeof(hapd->iface->mxl_iface.last_beacon_req.src_addr),
+		 sta_addr, ETH_ALEN);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+	hapd->iface->mxl_iface.last_beacon_req.dialog_token = token;
+	hapd->iface->mxl_iface.last_beacon_req.measurement_token = measurement_token;
+
+	if (beacon_measurement_mode == BEACON_REPORT_MODE_TABLE) {
+		mxl_hostapd_handle_sta_beacon_report_scan_results(hapd->iface);
+	} else if (beacon_measurement_mode == BEACON_REPORT_MODE_PASSIVE) {
+		hapd->iface->mxl_iface.self_beacon_req = 0;
+		ret = mxl_rrm_current_channel_request_scan(hapd->iface);
+		if (ret)
+			wpa_printf(MSG_ERROR, "Failed to request scan");
+	}
+}
+
+void mxl_hostapd_handle_beacon_report_response(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr)
+{
+	int ret;
+	const u8 *end, *attr;
+	errno_t err;
+	u8 op_class, channel, frame_info, rcpi, rsni, ant_id;
+	u8 measurement_rep_mode = 0;
+	u16 measurement_duration;
+	u32 parent_tsf;
+	unsigned long long start_time;
+	u8 bssid[ETH_ALEN] = {0};
+
+	int report_id = -1, fragment_id = -1, more_fragment_bit = 0;
+	int first_sub_elem_idx;
+
+	struct beacon_body frame_body;
+	char o_ssid[128] = "";
+	char o_rm_capa[128] = "";
+	char o_vendor_specific[255 * 3 + 1] = "";
+	char o_rsni[255 * 3 + 1] = "";
+
+	char frame_body_fragment_id[64] = "";
+	char last_beacon_rep[32] = "";
+
+	os_memset(&frame_body, 0, sizeof(frame_body));
+
+	wpa_printf(MSG_DEBUG, "Beacon report token %u len %zu",	token, len);
+
+	measurement_rep_mode = pos[1];
+	if (measurement_rep_mode != 0 || (len < 29)) {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_BEACON_REP_RXED MACSTR
+				" dialog_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%d duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d more_fragments=0",
+				MAC2STR(sta_addr), token, measurement_rep_mode, 0, 0, 0, 0, 0,
+				0, 0, MAC2STR(bssid), 0, 0);
+		return;
+	}
+
+	end = pos + len;
+
+	op_class = pos[3];
+	channel = pos[4];
+	start_time = WPA_GET_LE64(&pos[5]);
+	measurement_duration = WPA_GET_LE16(&pos[13]);
+	frame_info = pos[15];
+	rcpi = pos[16];
+	rsni = pos[17];
+	err = memcpy_s(bssid, sizeof(bssid), &pos[18], ETH_ALEN);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+	ant_id = pos[24];
+	parent_tsf = WPA_GET_LE32(&pos[25]);
+
+	if ((pos[29] != WLAN_BEACON_REPORT_SUBELEM_FRAME_BODY)) { /* No sub-elements */
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_BEACON_REP_RXED MACSTR
+				" dialog_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d more_fragments=0",
+				MAC2STR(sta_addr), token, measurement_rep_mode, op_class,
+				channel, start_time, measurement_duration, frame_info, rcpi,
+				rsni, MAC2STR(bssid), ant_id, parent_tsf);
+		return;
+	}
+
+	if (len < 30 || (&pos[30]) + pos[30] >= end) {
+		wpa_printf(MSG_ERROR, "%s: beacon report frame is corrupted", __func__);
+		return;
+	}
+	frame_body.length = pos[30];
+
+	attr = get_ie(&pos[29], len - 29, WLAN_BEACON_REPORT_SUBELEM_FRAME_BODY_FRAGMENT_ID);
+	if (attr && attr + 1 < end && attr[1] == 2 && attr + 1 + attr[1] < end) {
+		report_id = attr[2];
+		fragment_id = attr[3] & 0x7f; /* Bits 0 - 6 */
+		more_fragment_bit = attr[3] >> 7; /* Bit 7 */
+		ret = sprintf_s(frame_body_fragment_id, 64,
+			  "report_id=%d fragment_id=%d more_fragment_bit=%d",
+			  report_id, fragment_id, more_fragment_bit);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+
+	/* initial fragment include additional 12 bytes */
+	if (fragment_id == 0 || fragment_id == -1) {
+		if (frame_body.length < 12) {
+			wpa_printf(MSG_ERROR, "%s: beacon report frame is corrupted, frame_body.length=%d",
+				   __func__, frame_body.length);
+			return;
+		}
+		frame_body.length -= 12;
+		frame_body.timestamp = WPA_GET_LE64(&pos[31]);
+		frame_body.beacon_int = WPA_GET_LE16(&pos[39]);
+		frame_body.capab_info = WPA_GET_LE16(&pos[41]);
+		first_sub_elem_idx = 43;
+	} else {
+		first_sub_elem_idx = 31;
+	}
+
+	attr = get_ie(&pos[first_sub_elem_idx], frame_body.length, WLAN_EID_SSID);
+	if (attr && attr + 1 < end && attr[1] > 0 && attr[1] <= 32 && attr + 1 + attr[1] < end)
+		mxl_hostapd_memory_as_hex(o_ssid, sizeof(o_ssid), &attr[2], attr[1]);
+	attr = get_ie(&pos[first_sub_elem_idx], frame_body.length, WLAN_EID_RRM_ENABLED_CAPABILITIES);
+	if (attr && attr + 1 < end && attr[1] == 5 && attr + 1 + attr[1] < end)
+		mxl_hostapd_memory_as_hex(o_rm_capa, sizeof(o_rm_capa), &attr[2], attr[1]);
+	attr = get_ie(&pos[first_sub_elem_idx], frame_body.length, WLAN_EID_RSN);
+	if (attr && attr + 1 < end && attr[1] >= 2 && attr + 1 + attr[1] < end)
+		mxl_hostapd_memory_as_hex(o_rsni, sizeof(o_rsni), &attr[2], attr[1]);
+	attr = get_ie(&pos[first_sub_elem_idx], frame_body.length, WLAN_EID_VENDOR_SPECIFIC);
+	if (attr && attr + 1 < end && attr[1] > 0 && attr + 1 + attr[1] < end)
+		mxl_hostapd_memory_as_hex(o_vendor_specific, sizeof(o_vendor_specific), &attr[2], attr[1]);
+
+	attr = get_ie(&pos[29], len - 29, WLAN_BEACON_REPORT_SUBELEM_LAST_INDICATION);
+	if (attr && attr + 1 < end && attr[1] == 1 && attr + 1 + attr[1] < end) {
+		ret = sprintf_s(last_beacon_rep, 32, "last_beacon_rep=%d", attr[2]);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+
+	wpa_printf(MSG_DEBUG, "%s %s", frame_body_fragment_id, last_beacon_rep);
+
+	wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_BEACON_REP_RXED MACSTR
+			" dialog_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d timestamp=%llu beacon_int=%d capab_info=%02x ssid=%s rm_capa=%s vendor_specific=%s rsn_info=%s more_fragments=%d",
+			MAC2STR(sta_addr), token, measurement_rep_mode, op_class, channel,
+			start_time, measurement_duration, frame_info, rcpi, rsni,
+			MAC2STR(bssid), ant_id, parent_tsf, frame_body.timestamp,
+			frame_body.beacon_int, frame_body.capab_info,
+			o_ssid, o_rm_capa, o_vendor_specific, o_rsni, more_fragment_bit);
+}
+
+int mxl_hostapd_handle_self_beacon_req(struct hostapd_data *hapd,
+		u16 random_interval, u16 measurement_duration, u8 mode)
+{
+	int ret = 0;
+	const u8 bssid[ETH_ALEN] = {};
+
+	if ((mode == BEACON_REPORT_MODE_PASSIVE &&
+		!(hapd->conf->radio_measurements[0] & WLAN_RRM_CAPS_BEACON_REPORT_PASSIVE))
+		|| (mode == BEACON_REPORT_MODE_TABLE &&
+		!(hapd->conf->radio_measurements[0] & WLAN_RRM_CAPS_BEACON_REPORT_TABLE))
+		|| (mode == BEACON_REPORT_MODE_ACTIVE))
+	{
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_SELF_BEACON_REP_RXED MACSTR
+				" measurement_rep_mode=%d op_class=%d channel=%d start_time=%d duration=%d frame_info=%d rcpi=%d rsni=%d bssid=" MACSTR " antenna_id=%d parent_tsf=%d",
+				MAC2STR(hapd->own_addr),
+				MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE, 0, 0, 0, 0, 0, 0, 0,
+				MAC2STR(bssid), 0, 0);
+		return -1;
+	}
+
+	if (mode == BEACON_REPORT_MODE_TABLE) {
+		ret = mxl_hostapd_handle_self_beacon_report_scan_results(hapd);
+	} else if (mode == BEACON_REPORT_MODE_PASSIVE) {
+		hapd->iface->mxl_iface.self_beacon_req = 1;
+		ret = mxl_rrm_current_channel_request_scan(hapd->iface);
+	}
+
+	return ret;
+}
+
+static void mxl_hostapd_handle_channel_load_request(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr,
+		u16 num_of_repetition)
+{
+	const u8 *ie, *end;
+	u8 op_class, channel, measurement_token;
+	u8 ch_load_rep_cond = 0, ch_load_ref_val = 0;
+	u8 channel_load = 0;
+	u16 measurement_duration_report = 0;
+	u64 start_time = 0;
+	struct intel_vendor_radio_info radio_info;
+
+	end = pos + len;
+	measurement_token = pos[0];
+	op_class = pos[3];
+	channel = pos[4];
+
+	if (!(hapd->conf->radio_measurements[1] & WLAN_RRM_CAPS_CHANNEL_LOAD)) {
+		wpa_printf(MSG_ERROR, "channel load in RRM is not supported");
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE,
+				MEASURE_TYPE_CHANNEL_LOAD);
+		return;
+	}
+
+	if (channel != hapd->iface->conf->channel) {
+		wpa_printf(MSG_DEBUG, "requested channel (%d) is not supported, only the current AP channel (%d) is supported",
+				channel, hapd->iface->conf->channel);
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_REFUSED,
+				MEASURE_TYPE_CHANNEL_LOAD);
+		return;
+	}
+
+	if (MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_RADIO_INFO, NULL, 0, &radio_info, sizeof(radio_info))) {
+		wpa_printf(MSG_ERROR, "failed to get radio measurements");
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE,
+				MEASURE_TYPE_CHANNEL_LOAD);
+		return;
+	}
+
+	if ((ie = get_ie(&pos[9], end - &pos[9], 1)) && (ie[1] == 2)) {
+		ch_load_rep_cond = ie[2];
+		ch_load_ref_val = ie[3];
+	}
+
+	measurement_duration_report = 255;
+	start_time = radio_info.tsf_start_time;
+	channel_load = radio_info.load;
+
+	if ((ch_load_rep_cond == 1) && (ch_load_ref_val > channel_load)) {
+		wpa_printf(MSG_DEBUG, "ch_load is less than ch_load ref val");
+		return;
+	}
+
+	if ((ch_load_rep_cond == 2) && (ch_load_ref_val < channel_load)) {
+		wpa_printf(MSG_DEBUG, "ch_load is greater than ch_load ref val");
+		return;
+	}
+
+	if (!hapd->conf->mxl_bss_conf.rrm_manipulate_measurement) {
+		mxl_hostapd_send_channel_load_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_ACCEPT, op_class,
+				channel, start_time, measurement_duration_report, channel_load,
+				NULL, NULL, NULL);
+	} else {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_CHANNEL_LOAD_REQUEST_RXED MACSTR
+			" dialog_token=%d measurement_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d channel_load=%d",
+			MAC2STR(sta_addr), token, measurement_token,
+			MEASUREMENT_REPORT_MODE_ACCEPT, op_class, channel, start_time,
+			measurement_duration_report, channel_load);
+	}
+}
+
+void mxl_hostapd_handle_channel_load_report(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr)
+{
+	int ret;
+	u8 op_class, channel, channel_load, measurement_rep_mode;
+	u16 measurement_duration;
+	u64 start_time;
+	char wide_band_ch_switch[WIDE_BAND_CH_SWICTH_DEBUG_STR_LEN];
+
+	wpa_printf(MSG_DEBUG, "channel load token %u len %zu",	token, len);
+
+	measurement_rep_mode = pos[1];
+	if (measurement_rep_mode != 0) {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_CHANNEL_LOAD_RXED MACSTR
+				" dialog_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%d duration=%d channel_load=%d",
+				MAC2STR(sta_addr), token, measurement_rep_mode, 0, 0, 0, 0, 0);
+		return;
+	}
+
+	op_class = pos[3];
+	channel = pos[4];
+	start_time = WPA_GET_LE64(&pos[5]);
+	measurement_duration = WPA_GET_LE16(&pos[13]);
+	channel_load = pos[15];
+
+	wide_band_ch_switch[0] = '\0';
+	if (pos[16] == 163 && pos[17] == 5 && pos[18] == 194 && pos[19] == 3) {
+		ret = sprintf_s(wide_band_ch_switch, WIDE_BAND_CH_SWICTH_DEBUG_STR_LEN,
+			" wide_band_ch_switch=%d,%d,%d", pos[20], pos[21], pos[22]);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+
+	wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_CHANNEL_LOAD_RXED MACSTR
+			" dialog_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d channel_load=%d%s",
+			MAC2STR(sta_addr), token, measurement_rep_mode, op_class, channel,
+			start_time, measurement_duration, channel_load,
+			wide_band_ch_switch);
+}
+
+static void mxl_hostapd_handle_noise_histogram_request(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr,
+		u16 num_of_repetition)
+{
+	const u8 *ie, *end;
+	u8 op_class, channel, measurement_token, ant_id = 0, anpi = 0;
+	u8 noise_histogram_rep_cond = 0, noise_histogram_ref_val = 0;
+	u8 ipi_density[RRM_NOISE_HISTO_IPI_DENSITY_SIZE] = {};
+	u16 measurement_duration_report = 0;
+	u64 start_time = 0;
+	char ipi_density_str[64], *cur, *end_str;
+	int ret, i;
+	struct intel_vendor_radio_info radio_info;
+
+	end = pos + len;
+	measurement_token = pos[0];
+	op_class = pos[3];
+	channel = pos[4];
+
+	if (!(hapd->conf->radio_measurements[1] & WLAN_RRM_CAPS_NOISE_HISTOGRAM)) {
+		wpa_printf(MSG_ERROR, "noise histogram in RRM is not supported");
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE,
+				MEASURE_TYPE_NOISE_HIST);
+		return;
+	}
+
+	if (channel != hapd->iface->conf->channel) {
+		wpa_printf(MSG_DEBUG, "requested channel (%d) is not supported, only the current AP channel (%d) is supported",
+				channel, hapd->iface->conf->channel);
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_REFUSED,
+				MEASURE_TYPE_NOISE_HIST);
+		return;
+	}
+
+	if (MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_RADIO_INFO, NULL, 0, &radio_info, sizeof(radio_info))) {
+		wpa_printf(MSG_ERROR, "failed to get radio measurements");
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE,
+				MEASURE_TYPE_NOISE_HIST);
+		return;
+	}
+
+	if ((ie = get_ie(&pos[9], end - &pos[9], 1)) && (ie[1] == 2)) {
+		noise_histogram_rep_cond = ie[2];
+		noise_histogram_ref_val = ie[3];
+	}
+
+	anpi = radio_info.Noise;
+	start_time = radio_info.tsf_start_time;
+
+	/* the rx antenna id is 1 in case of 1 antenna exist
+	 * or unique configuration of multiple antennas */
+	ant_id = radio_info.num_rx_antennas;
+
+	if ((noise_histogram_rep_cond == 1) && (noise_histogram_ref_val > anpi)) {
+		wpa_printf(MSG_DEBUG, "anpi is less than anpi ref val");
+		return;
+	}
+
+	if ((noise_histogram_rep_cond == 2) && (noise_histogram_ref_val < anpi)) {
+		wpa_printf(MSG_DEBUG, "anpi is greater than anpi ref val");
+		return;
+	}
+
+	cur = ipi_density_str;
+	end_str = ipi_density_str + 64;
+	ret = sprintf_s(cur, end_str - cur, " ipi=");
+	if (ret <= 0) {
+		wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+		return;
+	}
+	cur += ret;
+
+	for (i = 0; i < RRM_NOISE_HISTO_IPI_DENSITY_SIZE; i++) {
+		ret = sprintf_s(cur, end_str - cur, "%d%s", ipi_density[i],
+				i + 1 < RRM_NOISE_HISTO_IPI_DENSITY_SIZE ? "," : " ");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+		cur += ret;
+	}
+
+	if (!hapd->conf->mxl_bss_conf.rrm_manipulate_measurement) {
+		mxl_hostapd_send_noise_histogram_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_ACCEPT, op_class,
+				channel, start_time, measurement_duration_report, ant_id, anpi,
+				ipi_density, NULL, NULL, NULL);
+	} else {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_NOISE_HISTOGRAM_REQUEST_RXED MACSTR
+			" dialog_token=%d measurement_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d antenna_id=%d anpi=%d%s",
+			MAC2STR(sta_addr), token, measurement_token,
+			MEASUREMENT_REPORT_MODE_ACCEPT, op_class, channel, start_time,
+			measurement_duration_report, ant_id, anpi, ipi_density_str);
+	}
+}
+
+void mxl_hostapd_handle_noise_histogram_report(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr)
+{
+	u8 op_class, channel, measurement_rep_mode, ant_id, anpi, i;
+	u16 measurement_duration;
+	u64 start_time;
+	char ipi_density[64] = {};
+	char *cur, *end;
+	char wide_band_ch_switch[WIDE_BAND_CH_SWICTH_DEBUG_STR_LEN];
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "noise histogram token %u len %zu", token, len);
+
+	measurement_rep_mode = pos[1];
+	if (measurement_rep_mode != 0) {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_NOISE_HISTOGRAM_RXED MACSTR
+				" dialog_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%d duration=%d antenna_id=%d anpi=%d ipi=0,0,0,0,0,0,0,0,0,0,0",
+				MAC2STR(sta_addr), token, measurement_rep_mode,
+				0, 0, 0, 0, 0, 0);
+		return;
+	}
+
+	op_class = pos[3];
+	channel = pos[4];
+	start_time = WPA_GET_LE64(&pos[5]);
+	measurement_duration = WPA_GET_LE16(&pos[13]);
+	ant_id = pos[15];
+	anpi = pos[16];
+
+	cur = ipi_density;
+	end = ipi_density + 64;
+	ret = sprintf_s(cur, end - cur, " ipi=");
+	if (ret <= 0) {
+		wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+		return;
+	}
+	cur += ret;
+
+	for (i = 0; i < RRM_NOISE_HISTO_IPI_DENSITY_SIZE; i++) {
+		ret = sprintf_s(cur, end - cur, "%d%s", pos[17 + i],
+				i + 1 < RRM_NOISE_HISTO_IPI_DENSITY_SIZE ? "," : " ");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+		cur += ret;
+	}
+
+	wide_band_ch_switch[0] = '\0';
+	if (pos[28] == 163 && pos[29] == 5 && pos[30] == 194 && pos[31] == 3) {
+		ret = sprintf_s(wide_band_ch_switch, WIDE_BAND_CH_SWICTH_DEBUG_STR_LEN,
+			" wide_band_ch_switch=%d,%d,%d", pos[32], pos[33], pos[34]);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+
+	wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_NOISE_HISTOGRAM_RXED MACSTR
+			" dialog_token=%d measurement_rep_mode=%d op_class=%d channel=%d start_time=%llu duration=%d antenna_id=%d anpi=%d%s%s",
+			MAC2STR(sta_addr), token, measurement_rep_mode, op_class, channel,
+			start_time, measurement_duration, ant_id, anpi, ipi_density,
+			wide_band_ch_switch);
+}
+
+static void mxl_build_statistics_group_str(char *statistics_group_data_str,
+		u32 *statistics_group_data, int statistics_group_data_len)
+{
+	char *cur, *end;
+	int ret, i;
+	cur = statistics_group_data_str;
+	end = statistics_group_data_str + 128;
+	ret = sprintf_s(cur, end - cur, " statistics_group_data=");
+	if (ret <= 0) {
+		wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+		return;
+	}
+	cur += ret;
+
+	for (i = 0; i < statistics_group_data_len; i++) {
+		ret = sprintf_s(cur, end - cur, "%d%s", statistics_group_data[i],
+				i + 1 < statistics_group_data_len ? "," : " ");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+		cur += ret;
+	}
+}
+
+static void mxl_hostapd_handle_sta_statistics_request(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr,
+		u16 num_of_repetition)
+{
+	errno_t err;
+	u8 peer_addr[ETH_ALEN];
+	u8 measurement_token, group_identity;
+	u16 measurement_duration_report = 0;
+	u32 statistics_group_data[RRM_STA_STATISTICS_GROUP_DATA_SIZE] = {};
+	u32 statistics_group_data_len = 0;
+	char statistics_group_data_str[128] = {};
+	struct intel_vendor_vap_info vap_info;
+
+	measurement_token = pos[0];
+	err = memcpy_s(peer_addr, sizeof(peer_addr), &pos[3], ETH_ALEN);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+	group_identity = pos[12];
+
+	if (!(hapd->conf->radio_measurements[1] & WLAN_RRM_CAPS_STATISTICS_MEASUREMENT)) {
+		wpa_printf(MSG_ERROR, "sta statistics in RRM is not supported");
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE,
+				MEASURE_TYPE_STA_STATISTICS);
+		return;
+	}
+
+	if (MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_VAP_MEASUREMENTS, NULL, 0, &vap_info, sizeof(vap_info))) {
+		wpa_printf(MSG_ERROR, "failed to get vap measurements");
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE,
+				MEASURE_TYPE_STA_STATISTICS);
+		return;
+	}
+
+	statistics_group_data_len =
+			mxl_hostapd_get_statistics_group_data_len(group_identity);
+	if (group_identity == 1) {
+		statistics_group_data[0] = vap_info.RetryCount;
+		statistics_group_data[1] = vap_info.MultipleRetryCount;
+		statistics_group_data[2] = vap_info.FrameDuplicateCount;
+		statistics_group_data[3] = vap_info.RTSSuccessCount;
+		statistics_group_data[4] = vap_info.RTSFailureCount;
+		statistics_group_data[5] = vap_info.ACKFailureCount;
+		mxl_build_statistics_group_str(statistics_group_data_str,
+				statistics_group_data, statistics_group_data_len);
+	} else if (group_identity == 11) {
+		statistics_group_data[0] = vap_info.TransmittedAMSDUCount;
+		statistics_group_data[1] = vap_info.FailedAMSDUCount;
+		statistics_group_data[2] = vap_info.RetryCount;
+		statistics_group_data[3] = vap_info.MultipleRetryCount;
+		err = memcpy_s(&statistics_group_data[4],
+			 (sizeof(statistics_group_data) - (4 * sizeof(statistics_group_data[0]))),
+			 &vap_info.TransmittedOctetsInAMSDUCount,
+			 sizeof(vap_info.TransmittedOctetsInAMSDUCount));
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			return;
+		}
+		statistics_group_data[6] = vap_info.AMSDUAckFailureCount;
+		statistics_group_data[7] = vap_info.ReceivedAMSDUCount;
+		err = memcpy_s(&statistics_group_data[8],
+			 (sizeof(statistics_group_data) - (8 * sizeof(statistics_group_data[0]))),
+			 &vap_info.ReceivedOctetsInAMSDUCount,
+			 sizeof(vap_info.ReceivedOctetsInAMSDUCount));
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			return;
+		}
+		mxl_build_statistics_group_str(statistics_group_data_str,
+						statistics_group_data, statistics_group_data_len);
+	} else if (group_identity == 12) {
+		statistics_group_data[0] = vap_info.TransmittedAMPDUCount;
+		statistics_group_data[1] = vap_info.TransmittedMPDUsInAMPDUCount;
+		err = memcpy_s(&statistics_group_data[2],
+			 (sizeof(statistics_group_data) - (2 * sizeof(statistics_group_data[0]))),
+			 &vap_info.TransmittedOctetsInAMPDUCount,
+			 sizeof(vap_info.TransmittedOctetsInAMPDUCount));
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			return;
+		}
+		statistics_group_data[4] = vap_info.AMPDUReceivedCount;
+		statistics_group_data[5] = vap_info.MPDUInReceivedAMPDUCount;
+		err = memcpy_s(&statistics_group_data[6],
+			 (sizeof(statistics_group_data) - (6 * sizeof(statistics_group_data[0]))),
+			 &vap_info.ReceivedOctetsInAMPDUCount,
+			 sizeof(vap_info.ReceivedOctetsInAMPDUCount));
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			return;
+		}
+		statistics_group_data[8] = 0; /* AMPDUDelimiterCRCErrorCount unknown */
+		mxl_build_statistics_group_str(statistics_group_data_str,
+						statistics_group_data, statistics_group_data_len);
+	} else if (group_identity == 13) {
+		statistics_group_data[0] = vap_info.ImplicitBARFailureCount;
+		statistics_group_data[1] = vap_info.ExplicitBARFailureCount;
+		statistics_group_data[2] = vap_info.SwitchChannel20To40
+								 + vap_info.SwitchChannel40To20;
+		statistics_group_data[3] = vap_info.TwentyMHzFrameTransmittedCount;
+		statistics_group_data[4] = vap_info.FortyMHzFrameTransmittedCount;
+		statistics_group_data[5] = 0; /* TwentyMHzFrameReceivedCount unknown */
+		statistics_group_data[6] = 0; /* FortyMHzFrameReceivedCount unknown */
+		statistics_group_data[7] = 0; /* PSMPUTTGrantDuration unknown */
+		statistics_group_data[8] = 0; /* PSMPUTTUsedDuration unknown */
+		mxl_build_statistics_group_str(statistics_group_data_str,
+						statistics_group_data, statistics_group_data_len);
+	} else {
+		wpa_printf(MSG_ERROR, "group_identity number %d is not supported",
+				group_identity);
+		mxl_hostapd_send_general_rrm_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_REJECT_REFUSED,
+				MEASURE_TYPE_STA_STATISTICS);
+		return;
+	}
+
+	if (!hapd->conf->mxl_bss_conf.rrm_manipulate_measurement) {
+		mxl_hostapd_send_sta_statistics_report(hapd, sta_addr, token,
+				measurement_token, MEASUREMENT_REPORT_MODE_ACCEPT,
+				measurement_duration_report, group_identity,
+				statistics_group_data, statistics_group_data_len, NULL);
+	} else {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_STA_STATISTICS_REQUEST_RXED MACSTR
+			" dialog_token=%d measurement_token=%d measurement_rep_mode=%d duration=%d group_identity=%d%s",
+			MAC2STR(sta_addr), token, measurement_token,
+			MEASUREMENT_REPORT_MODE_ACCEPT, measurement_duration_report,
+			group_identity, statistics_group_data_str);
+	}
+}
+
+void mxl_hostapd_handle_sta_statistics_report(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr)
+{
+	u8 group_identity, measurement_rep_mode;
+	u16 measurement_duration;
+	char statistics_group_data[128], rep_reason[30];
+	char *cur, *end;
+	int i, ret, statistics_group_data_len;
+
+	wpa_printf(MSG_DEBUG, "sta statistics token %u len %zu", token, len);
+
+	measurement_rep_mode = pos[1];
+	if (measurement_rep_mode != 0) {
+		wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_STA_STATISTICS_RXED MACSTR
+				" dialog_token=%d measurement_rep_mode=%d duration=%d group_identity=%d statistics_group_data=0,0,0,0,0,0,0",
+				MAC2STR(sta_addr), token, measurement_rep_mode, 0, 0);
+		return;
+	}
+
+	measurement_duration = WPA_GET_LE16(&pos[3]);
+	group_identity = pos[5];
+
+	statistics_group_data_len =
+			mxl_hostapd_get_statistics_group_data_len(group_identity);
+
+	cur = statistics_group_data;
+	end = statistics_group_data + 128;
+	ret = sprintf_s(cur, end - cur, " statistics_group_data=");
+	if (ret <= 0) {
+		wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+		return;
+	}
+	cur += ret;
+
+	for (i = 0; i < statistics_group_data_len; i++) {
+		ret = sprintf_s(cur, end - cur, "%d%s", pos[6 + i],
+				i + 1 < statistics_group_data_len ? "," : " ");
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+		cur += ret;
+	}
+
+	rep_reason[0] = '\0';
+	if ((pos[6 + statistics_group_data_len] == 1)
+			&& (pos[7 + statistics_group_data_len] == 1)) {
+		ret = sprintf_s(rep_reason, sizeof(rep_reason),
+			  " rep_reason=%d", pos[8 + statistics_group_data_len]);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+
+	wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_STA_STATISTICS_RXED MACSTR
+			" dialog_token=%d measurement_rep_mode=%d duration=%d group_identity=%d%s%s",
+			MAC2STR(sta_addr), token, measurement_rep_mode,
+			measurement_duration, group_identity, statistics_group_data,
+			rep_reason);
+}
+void mxl_hostapd_handle_radio_msmt_request(struct hostapd_data *hapd,
+					     const u8 *buf, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
+	const u8 *pos, *ie, *end;
+	u8 token;
+	u16 num_of_repetition;
+
+	end = buf + len;
+	token = mgmt->u.action.u.rrm.dialog_token;
+	num_of_repetition = WPA_GET_LE16(mgmt->u.action.u.rrm.variable);
+	pos = mgmt->u.action.u.rrm.variable;
+
+	while ((ie = get_ie(pos, end - pos, WLAN_EID_MEASURE_REQUEST))) {
+		if (ie[1] < 3) {
+			wpa_printf(MSG_DEBUG, "Bad Measurement Request element");
+			break;
+		}
+
+		wpa_printf(MSG_DEBUG, "Measurement request type %u", ie[4]);
+
+		switch (ie[4]) {
+		case MEASURE_TYPE_CHANNEL_LOAD:
+			mxl_hostapd_handle_channel_load_request(hapd, token, ie + 2, ie[1],
+					mgmt->sa, num_of_repetition);
+			break;
+		case MEASURE_TYPE_NOISE_HIST:
+			mxl_hostapd_handle_noise_histogram_request(hapd, token, ie + 2, ie[1],
+					mgmt->sa, num_of_repetition);
+			break;
+		case MEASURE_TYPE_BEACON:
+			mxl_hostapd_handle_beacon_report_request(hapd, token, ie + 2, ie[1],
+					mgmt->sa, num_of_repetition);
+			break;
+		case MEASURE_TYPE_STA_STATISTICS:
+			mxl_hostapd_handle_sta_statistics_request(hapd, token, ie + 2, ie[1],
+					mgmt->sa, num_of_repetition);
+			break;
+		default:
+			wpa_printf(MSG_DEBUG,
+				   "Measurement request type %u is not supported", ie[4]);
+			break;
+		}
+
+		pos = ie + ie[1] + 2;
+	}
+}
+
+
+void mxl_hostapd_handle_link_msmt_report(struct hostapd_data *hapd,
+					     const u8 *buf, size_t len)
+{
+	errno_t err;
+	int ret;
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
+	const u8 *pos, *ie, *end;
+	u8 token;
+	struct rrm_link_measurement_report link_msmt_report;
+	struct dmg_link_margin dmg_margin;
+	struct dmg_link_adaptation_ack dmg_adapt;
+	char dmg_margin_str[50], dmg_adapt_str[50];
+
+	end = buf + len;
+	token = mgmt->u.action.u.rrm.dialog_token;
+	pos = mgmt->u.action.u.rrm.variable;
+
+	wpa_printf(MSG_DEBUG, "link measurement report token %u len %zu",
+			token, len);
+
+	err = memcpy_s(&link_msmt_report.tpc, sizeof(link_msmt_report.tpc), pos, 4);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+	link_msmt_report.rx_ant_id = pos[4];
+	link_msmt_report.tx_ant_id = pos[5];
+	link_msmt_report.rcpi = pos[6];
+	link_msmt_report.rsni = pos[7];
+
+	dmg_margin_str[0] = '\0';
+	if ((ie = get_ie(pos, end - pos, WLAN_EID_DMG_LINK_MARGIN))
+			&& (ie[1] == 8)) {
+		err = memcpy_s(&dmg_margin, sizeof(dmg_margin), ie, 10);
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			return;
+		}
+		ret = sprintf_s(dmg_margin_str, sizeof(dmg_margin_str),
+			  " dmg_link_margin=%d,%d,%d,%d,%d", dmg_margin.activity,
+			  dmg_margin.mcs, dmg_margin.link_margin, dmg_margin.snr,
+			  dmg_margin.ref_timestamp);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+
+	dmg_adapt_str[0] = '\0';
+	if ((ie = get_ie(pos, end - pos, WLAN_EID_DMG_LINK_ADAPTATION_ACK))
+			&& (ie[1] == 5)) {
+		err = memcpy_s(&dmg_adapt, sizeof(dmg_adapt), ie, 7);
+		if (EOK != err) {
+			wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+			return;
+		}
+		ret = sprintf_s(dmg_adapt_str, sizeof(dmg_adapt_str),
+			  " dmg_link_adapt_ack=%d,%d", dmg_adapt.activity,
+			  dmg_adapt.ref_timestamp);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			return;
+		}
+	}
+
+	wpa_msg(hapd->msg_ctx, MSG_INFO, RRM_EVENT_LINK_MEASUREMENT_RXED MACSTR
+			" dialog_token=%d tpc_report=%d,%d rx_ant_id=%d tx_ant_id=%d rcpi=%d rsni=%d%s%s",
+			MAC2STR(mgmt->sa), token, link_msmt_report.tpc.tx_power,
+			link_msmt_report.tpc.link_margin, link_msmt_report.rx_ant_id,
+			link_msmt_report.tx_ant_id, link_msmt_report.rcpi,
+			link_msmt_report.rsni, dmg_margin_str, dmg_adapt_str);
+}
+
+void mxl_hostapd_handle_link_msmt_request(struct hostapd_data *hapd,
+					  const u8 *buf, size_t len)
+{
+	struct hostapd_iface *iface = hapd->iface;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
+	int i, ssi_signal = mxl_hostapd_action_ssi_get(hapd);
+	u8 token;
+
+	struct rrm_link_measurement_report link_msmt_report;
+	struct intel_vendor_radio_info radio_info;
+
+	os_memset(&link_msmt_report, 0, sizeof(link_msmt_report));
+
+	token = mgmt->u.action.u.rrm.dialog_token;
+
+	if (!(hapd->conf->radio_measurements[0] & WLAN_RRM_CAPS_LINK_MEASUREMENT)) {
+		wpa_printf(MSG_DEBUG, "AP not support link measurement, token %u",
+			   token);
+		return;
+	}
+
+	if (!(hapd->iface->drv_flags & WPA_DRIVER_FLAGS_TX_POWER_INSERTION)) {
+		wpa_printf(MSG_DEBUG, "TX power insertion not supported, token %u",
+			   token);
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG, "link measurement request token %u len %zu",
+			token, len);
+
+	link_msmt_report.dialog_token = token;
+	link_msmt_report.tpc.eid = WLAN_EID_TPC_REPORT;
+	link_msmt_report.tpc.len = 2;
+	link_msmt_report.tpc.link_margin = 0; /* unknown */
+
+	for (i = 0; i < mode->num_channels; i++) {
+		if (mode->channels[i].chan == iface->conf->channel) {
+			link_msmt_report.tpc.tx_power = mode->channels[i].max_tx_power;
+			break;
+		}
+	}
+
+	if (MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_RADIO_INFO, NULL, 0, &radio_info, sizeof(radio_info))) {
+		wpa_printf(MSG_ERROR, "failed to get radio measurements");
+		return;
+	}
+
+	if (radio_info.num_tx_antennas == 1)
+		link_msmt_report.tx_ant_id = 1;
+	else if (radio_info.num_tx_antennas > 1)
+		link_msmt_report.tx_ant_id = 255; /* multiple antennas */
+	/* the rx antenna id is 1 in case of 1 antenna exist
+	 * or unique configuration of multiple antennas */
+	link_msmt_report.rx_ant_id = radio_info.num_rx_antennas;
+
+	link_msmt_report.rcpi = rssi_to_rcpi(ssi_signal);
+	link_msmt_report.rsni = 255; /* 255 indicates that RSNI is not available */
+
+	if (!hapd->conf->mxl_bss_conf.rrm_manipulate_measurement) {
+		mxl_hostapd_send_link_measurement_report(hapd, mgmt->sa, link_msmt_report,
+				NULL, NULL);
+	} else {
+		wpa_msg(hapd->msg_ctx, MSG_INFO,
+				RRM_EVENT_LINK_MEASUREMENT_REQUEST_RXED MACSTR
+				" dialog_token=%d rx_ant_id=%d tx_ant_id=%d rcpi=%d rsni=%d tpc_report=%d,%d",
+				MAC2STR(mgmt->sa), link_msmt_report.dialog_token,
+				link_msmt_report.rx_ant_id, link_msmt_report.tx_ant_id,
+				link_msmt_report.rcpi, link_msmt_report.rsni,
+				link_msmt_report.tpc.tx_power,
+				link_msmt_report.tpc.link_margin);
+	}
+}
+
+int mxl_hostapd_send_link_measurement_req(struct hostapd_data *hapd, const u8 *addr)
+{
+	struct hostapd_iface *iface = hapd->iface;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	int ret, i;
+	s8 max_tx_power = 0, tx_power_used = 0;
+	struct intel_vendor_sta_info sta_info;
+
+	wpa_printf(MSG_DEBUG, "request link measurement: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "request link measurement: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[0] & WLAN_RRM_CAPS_LINK_MEASUREMENT)) {
+		wpa_printf(MSG_ERROR,
+			   "request link measurement: Destination station does not support link measurement in RRM");
+		return -1;
+	}
+
+	if (MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_STA_MEASUREMENTS, addr, ETH_ALEN, &sta_info, sizeof(sta_info))) {
+		wpa_printf(MSG_ERROR, "request link measurement: get tx power used failed");
+		return -1;
+	}
+
+	for (i = 0; i < mode->num_channels; i++) {
+		if (mode->channels[i].chan == iface->conf->channel) {
+			max_tx_power = mode->channels[i].max_tx_power;
+			break;
+		}
+	}
+	tx_power_used = (s8)(sta_info.TxMgmtPwr / 100);
+
+	/* Link Measurement request (5)*/
+	buf = wpabuf_alloc(5);
+	if (!buf)
+		return -1;
+
+	hapd->mxl_data.link_measurement_token++;
+	if (!hapd->mxl_data.link_measurement_token) /* For wraparounds */
+		hapd->mxl_data.link_measurement_token++;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.4 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_LINK_MEASUREMENT_REQUEST);
+	wpabuf_put_u8(buf, hapd->mxl_data.link_measurement_token); /* Dialog Token */
+	wpabuf_put_u8(buf, tx_power_used); /* tx power used */
+	wpabuf_put_u8(buf, max_tx_power); /* tx max power */
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	if (ret)
+		return -1;
+	return hapd->mxl_data.link_measurement_token;
+}
+
+int mxl_hostapd_send_link_measurement_report(struct hostapd_data *hapd,
+		const u8 *addr, struct rrm_link_measurement_report link_msmt_report,
+		struct dmg_link_margin *dmg_margin,
+		struct dmg_link_adaptation_ack *dmg_ack)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "link measurement report: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "link measurement report: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[0] & WLAN_RRM_CAPS_LINK_MEASUREMENT)) {
+		wpa_printf(MSG_ERROR,
+			   "link measurement report: Destination station does not support link measurement in RRM");
+		return -1;
+	}
+
+	/* Link Measurement response (11)
+	 * + optional dmg link margin(10)
+	 * + optional dmg link adaptation ack(7)*/
+	buf = wpabuf_alloc(11 + 10 + 7);
+	if (!buf)
+		return -1;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.5 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_LINK_MEASUREMENT_REPORT);
+	wpabuf_put_u8(buf, link_msmt_report.dialog_token);
+	wpabuf_put_data(buf, (const void *) &link_msmt_report.tpc, 4);
+	wpabuf_put_u8(buf, link_msmt_report.rx_ant_id);
+	wpabuf_put_u8(buf, link_msmt_report.tx_ant_id);
+	wpabuf_put_u8(buf, link_msmt_report.rcpi);
+	wpabuf_put_u8(buf, link_msmt_report.rsni);
+
+	if (dmg_margin)
+		wpabuf_put_data(buf, (const void *) dmg_margin, 10);
+
+	if (dmg_ack)
+		wpabuf_put_data(buf, (const void *) dmg_ack, 7);
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+
+	return ret;
+}
+
+int mxl_hostapd_send_channel_load_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode, u8 oper_class,
+		u8 channel, u16 random_interval, u16 measurement_duration, u8 *rep_cond,
+		u8 *ch_load_ref_val, u8 *ch_width, u8 *ch_center_freq0,
+		u8 *ch_center_freq1)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	u8 *len;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "request channel load: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "request channel load: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[1] & WLAN_RRM_CAPS_CHANNEL_LOAD)) {
+		wpa_printf(MSG_ERROR,
+			   "request channel load: Destination station does not support channel load in RRM");
+		return -1;
+	}
+
+	/* Measurement request (5) + Measurement element with channel load (11) + optional sub-elements (255)*/
+	buf = wpabuf_alloc(5 + 11 + 255);
+	if (!buf)
+		return -1;
+
+	hapd->mxl_data.channel_load_token++;
+	if (!hapd->mxl_data.channel_load_token) /* For wraparounds */
+		hapd->mxl_data.channel_load_token++;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.2 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REQUEST);
+	wpabuf_put_u8(buf, hapd->mxl_data.channel_load_token); /* Dialog Token */
+	wpabuf_put_le16(buf, num_of_repetitions); /* Number of Repetitions */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.21 */
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REQUEST);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+
+	wpabuf_put_u8(buf, hapd->mxl_data.channel_load_token); /* Measurement Token */
+	wpabuf_put_u8(buf, measurement_request_mode); /* Measurement Request Mode */
+	wpabuf_put_u8(buf, MEASURE_TYPE_CHANNEL_LOAD); /* Measurement Type */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.21.5 */
+	wpabuf_put_u8(buf, oper_class); /* Operating class */
+	wpabuf_put_u8(buf, channel); /* Channel Number */
+	wpabuf_put_le16(buf, random_interval); /* Randomization Interval */
+	wpabuf_put_le16(buf, measurement_duration); /* Measurement Duration */
+
+	/* optional sub-elements should go here */
+	if (rep_cond && ch_load_ref_val) {
+		wpabuf_put_u8(buf, 1); /* channel load reporting sub element id */
+		wpabuf_put_u8(buf, 2);
+		wpabuf_put_u8(buf, *rep_cond);
+		wpabuf_put_u8(buf, *ch_load_ref_val);
+	}
+
+	if (ch_width && ch_center_freq0 && ch_center_freq1) {
+		wpabuf_put_u8(buf, 163); /* wide bandwidth channel switch sub element id */
+		wpabuf_put_u8(buf, 5);   /* sub element length */
+		wpabuf_put_u8(buf, 194); /* wide bandwidth channel switch element id */
+		wpabuf_put_u8(buf, 3); 	 /* element length */
+		wpabuf_put_u8(buf, *ch_width);
+		wpabuf_put_u8(buf, *ch_center_freq0);
+		wpabuf_put_u8(buf, *ch_center_freq1);
+	}
+
+	/* category + Action + measurement type + token + reps + EID + len = 7 */
+	*len = wpabuf_len(buf) - 7;
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	if (ret)
+		return -1;
+	return hapd->mxl_data.channel_load_token;
+}
+
+int mxl_hostapd_send_channel_load_report(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u8 op_class, u8 channel, u64 start_time, u16 measurement_duration,
+		u8 channel_load, u8 *ch_width, u8 *ch_center_freq0, u8 *ch_center_freq1)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	u8 *len;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "channel load report: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "channel load report: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[1] & WLAN_RRM_CAPS_CHANNEL_LOAD)) {
+		wpa_printf(MSG_ERROR,
+			   "channel load report: Destination station does not support channel load in RRM");
+		return -1;
+	}
+
+	/* Measurement report (3) + Measurement element with channel load (18) + optional sub-elements (255)*/
+	buf = wpabuf_alloc(3 + 18 + 255);
+	if (!buf)
+		return -1;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.3 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REPORT);
+	wpabuf_put_u8(buf, dialog_token); /* Dialog Token */
+
+	/* IEEE P802.11-REVmc/D5.0, 9.4.2.22 */
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REPORT);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+
+	wpabuf_put_u8(buf, measurement_token); /* Measurement Token */
+	wpabuf_put_u8(buf, measurement_rep_mode); /* Measurement Report Mode */
+	wpabuf_put_u8(buf, MEASURE_TYPE_CHANNEL_LOAD); /* Measurement Type */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.22.5 */
+	wpabuf_put_u8(buf, op_class); /* Operating class */
+	wpabuf_put_u8(buf, channel); /* Channel Number */
+	wpabuf_put_data(buf, (const void *) &start_time, 8); /* actual measurement start time */
+	wpabuf_put_le16(buf, measurement_duration); /* Measurement Duration */
+	wpabuf_put_u8(buf, channel_load); /* channel_load */
+
+	if (ch_width && ch_center_freq0 && ch_center_freq1) {
+		wpabuf_put_u8(buf, 163); /* wide bandwidth channel switch sub element id */
+		wpabuf_put_u8(buf, 5);   /* sub element length */
+		wpabuf_put_u8(buf, 194); /* wide bandwidth channel switch element id */
+		wpabuf_put_u8(buf, 3); 	 /* element length */
+		wpabuf_put_u8(buf, *ch_width);
+		wpabuf_put_u8(buf, *ch_center_freq0);
+		wpabuf_put_u8(buf, *ch_center_freq1);
+	}
+
+	/* Action + measurement type + token + EID + len = 5 */
+	*len = wpabuf_len(buf) - 5;
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	return ret;
+}
+
+int mxl_hostapd_send_noise_histogram_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode, u8 oper_class,
+		u8 channel, u16 random_interval, u16 measurement_duration, u8 *rep_cond,
+		u8 *anpi_ref_val, u8 *ch_width, u8 *ch_center_freq0,
+		u8 *ch_center_freq1)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	u8 *len;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "request noise histogram: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "request noise histogram: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[1] & WLAN_RRM_CAPS_NOISE_HISTOGRAM)) {
+		wpa_printf(MSG_ERROR,
+			   "request noise histogram: Destination station does not support noise histogram in RRM");
+		return -1;
+	}
+
+	/* Measurement request (5) + Measurement element with noise histogram (11) + optional sub-elements (255)*/
+	buf = wpabuf_alloc(5 + 11 + 255);
+	if (!buf)
+		return -1;
+
+	hapd->mxl_data.noise_histogram_token++;
+	if (!hapd->mxl_data.noise_histogram_token) /* For wraparounds */
+		hapd->mxl_data.noise_histogram_token++;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.2 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REQUEST);
+	wpabuf_put_u8(buf, hapd->mxl_data.noise_histogram_token); /* Dialog Token */
+	wpabuf_put_le16(buf, num_of_repetitions); /* Number of Repetitions */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.21 */
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REQUEST);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+
+	wpabuf_put_u8(buf, hapd->mxl_data.noise_histogram_token); /* Measurement Token */
+	wpabuf_put_u8(buf, measurement_request_mode); /* Measurement Request Mode */
+	wpabuf_put_u8(buf, MEASURE_TYPE_NOISE_HIST); /* Measurement Type */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.21.6 */
+	wpabuf_put_u8(buf, oper_class); /* Operating class */
+	wpabuf_put_u8(buf, channel); /* Channel Number */
+	wpabuf_put_le16(buf, random_interval); /* Randomization Interval */
+	wpabuf_put_le16(buf, measurement_duration); /* Measurement Duration */
+
+	/* optional sub-elements should go here */
+	if (rep_cond && anpi_ref_val) {
+		wpabuf_put_u8(buf, 1); /* channel load reporting sub element id */
+		wpabuf_put_u8(buf, 2);
+		wpabuf_put_u8(buf, *rep_cond);
+		wpabuf_put_u8(buf, *anpi_ref_val);
+	}
+
+	if (ch_width && ch_center_freq0 && ch_center_freq1) {
+		wpabuf_put_u8(buf, 163); /* wide bandwidth channel switch sub element id */
+		wpabuf_put_u8(buf, 5);   /* sub element length */
+		wpabuf_put_u8(buf, 194); /* wide bandwidth channel switch element id */
+		wpabuf_put_u8(buf, 3); 	 /* element length */
+		wpabuf_put_u8(buf, *ch_width);
+		wpabuf_put_u8(buf, *ch_center_freq0);
+		wpabuf_put_u8(buf, *ch_center_freq1);
+	}
+
+	/* category + Action + measurement type + token + reps + EID + len = 7 */
+	*len = wpabuf_len(buf) - 7;
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	if (ret)
+		return -1;
+	return hapd->mxl_data.noise_histogram_token;
+}
+
+int mxl_hostapd_send_noise_histogram_report(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u8 op_class, u8 channel, u64 start_time, u16 measurement_duration,
+		u8 ant_id, u8 anpi, u8 *ipi_density, u8 *ch_width, u8 *ch_center_freq0,
+		u8 *ch_center_freq1)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	u8 *len;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "noise histogram report: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "noise histogram report: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[1] & WLAN_RRM_CAPS_NOISE_HISTOGRAM)) {
+		wpa_printf(MSG_ERROR,
+			   "noise histogram report: Destination station does not support noise histogram in RRM");
+		return -1;
+	}
+
+	/* Measurement report (3) + Measurement element with noise histogram (25) + optional sub-elements (255)*/
+	buf = wpabuf_alloc(3 + 25 + 255);
+	if (!buf)
+		return -1;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.3 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REPORT);
+	wpabuf_put_u8(buf, dialog_token); /* Dialog Token */
+
+	/* IEEE P802.11-REVmc/D5.0, 9.4.2.22 */
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REPORT);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+
+	wpabuf_put_u8(buf, measurement_token); /* Measurement Token */
+	wpabuf_put_u8(buf, measurement_rep_mode); /* Measurement Report Mode */
+	wpabuf_put_u8(buf, MEASURE_TYPE_NOISE_HIST); /* Measurement Type */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.22.6 */
+	wpabuf_put_u8(buf, op_class); /* Operating class */
+	wpabuf_put_u8(buf, channel); /* Channel Number */
+	wpabuf_put_data(buf, (const void *) &start_time, 8); /* actual measurement start time */
+	wpabuf_put_le16(buf, measurement_duration); /* Measurement Duration */
+	wpabuf_put_u8(buf, ant_id); /* antenna id */
+	wpabuf_put_u8(buf, anpi); /* anpi */
+
+	for (i = 0; i < 11; i++)
+		wpabuf_put_u8(buf, ipi_density[i]);
+
+	if (ch_width && ch_center_freq0 && ch_center_freq1) {
+		wpabuf_put_u8(buf, 163); /* wide bandwidth channel switch sub element id */
+		wpabuf_put_u8(buf, 5);   /* sub element length */
+		wpabuf_put_u8(buf, 194); /* wide bandwidth channel switch element id */
+		wpabuf_put_u8(buf, 3); 	 /* element length */
+		wpabuf_put_u8(buf, *ch_width);
+		wpabuf_put_u8(buf, *ch_center_freq0);
+		wpabuf_put_u8(buf, *ch_center_freq1);
+	}
+
+	/* Action + measurement type + token + EID + len = 5 */
+	*len = wpabuf_len(buf) - 5;
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	return ret;
+}
+
+int mxl_hostapd_get_statistics_group_data_len(u8 group_identity)
+{
+	int statistics_group_data_len = 0;
+
+	if ((group_identity == 0) || (group_identity == 16))
+		statistics_group_data_len = 7;
+	else if (group_identity == 1)
+		statistics_group_data_len = 6;
+	else if ((group_identity >= 2) && (group_identity <= 9))
+		statistics_group_data_len = 13;
+	else if (group_identity == 10)
+		statistics_group_data_len = 2;
+	else if (group_identity == 11)
+		statistics_group_data_len = 10;
+	else if ((group_identity >= 12) && (group_identity <= 14))
+		statistics_group_data_len = 9;
+	else if (group_identity == 15)
+		statistics_group_data_len = 5;
+
+	return statistics_group_data_len;
+}
+
+static void fill_trig_rep_counters(struct wpabuf *buf,
+		struct rrm_trig_rep_counters *trig_rep_counters)
+{
+	int i;
+	if (trig_rep_counters) {
+		wpabuf_put_u8(buf, 1);
+		wpabuf_put_u8(buf, 8 + (4 * (*trig_rep_counters).num_of_counters));
+		wpabuf_put_be32(buf, (*trig_rep_counters).measurement_count);
+		wpabuf_put_le16(buf, (*trig_rep_counters).trigger_timeout);
+		wpabuf_put_le16(buf, (*trig_rep_counters).counters_trigger_condition);
+		for (i = 0; i < 7; i++)
+			if ((*trig_rep_counters).counters[i] != 0)
+				wpabuf_put_be32(buf, (*trig_rep_counters).counters[i]);
+	}
+}
+
+int mxl_hostapd_send_sta_statistics_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode,
+		const u8 *peer_addr, u16 random_interval, u16 measurement_duration,
+		u8 group_identity, struct rrm_trig_rep_counters *trig_rep_sta_counters,
+		struct rrm_trig_rep_counters *trig_rep_qos_sta_counters,
+		struct rrm_trig_rep_counters *trig_rep_rsna_counters)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	u8 *len;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "request sta statistics: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "request sta statistics: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[1] & WLAN_RRM_CAPS_STATISTICS_MEASUREMENT)) {
+		wpa_printf(MSG_ERROR,
+			   "request sta statistics: Destination station does not support sta statistics in RRM");
+		return -1;
+	}
+
+	/* Measurement request (5) + Measurement element with sta statistics (16) + optional sub-elements (255)*/
+	buf = wpabuf_alloc(5 + 16 + 255);
+	if (!buf)
+		return -1;
+
+	hapd->mxl_data.sta_statistics_token++;
+	if (!hapd->mxl_data.sta_statistics_token) /* For wraparounds */
+		hapd->mxl_data.sta_statistics_token++;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.2 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REQUEST);
+	wpabuf_put_u8(buf, hapd->mxl_data.sta_statistics_token); /* Dialog Token */
+	wpabuf_put_le16(buf, num_of_repetitions); /* Number of Repetitions */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.21 */
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REQUEST);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+
+	wpabuf_put_u8(buf, hapd->mxl_data.sta_statistics_token); /* Measurement Token */
+	wpabuf_put_u8(buf, measurement_request_mode); /* Measurement Request Mode */
+	wpabuf_put_u8(buf, MEASURE_TYPE_STA_STATISTICS); /* Measurement Type */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.21.9 */
+	wpabuf_put_data(buf, (const void *) peer_addr, ETH_ALEN); /* peer mac addr */
+	wpabuf_put_le16(buf, random_interval); /* Randomization Interval */
+	wpabuf_put_le16(buf, measurement_duration); /* Measurement Duration */
+	wpabuf_put_u8(buf, group_identity); /* group identity */
+
+	fill_trig_rep_counters(buf, trig_rep_sta_counters);
+	fill_trig_rep_counters(buf, trig_rep_qos_sta_counters);
+	fill_trig_rep_counters(buf, trig_rep_rsna_counters);
+
+	/* category + Action + measurement type + token + reps + EID + len = 7 */
+	*len = wpabuf_len(buf) - 7;
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	if (ret)
+		return -1;
+	return hapd->mxl_data.sta_statistics_token;
+}
+
+int mxl_hostapd_send_sta_statistics_report(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u16 measurement_duration, u8 group_identity,
+		const u32 *statistics_group_data, u8 statistics_group_data_len,
+		u8 *rep_reason)
+{
+	struct wpabuf *buf;
+	struct sta_info *sta = NULL;
+	u8 *len;
+	int ret, i;
+
+	wpa_printf(MSG_DEBUG, "sta statistics report: dest addr: " MACSTR
+			,MAC2STR(addr));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		sta = ap_get_sta(hapd->iface->bss[i], addr);
+		if (sta) {
+			hapd = hapd->iface->bss[i];
+			break;
+		}
+	}
+
+	if (!sta || !(sta->flags & WLAN_STA_AUTHORIZED)) {
+		wpa_printf(MSG_ERROR,
+			   "sta statistics report: Destination address is not connected");
+		return -1;
+	}
+
+	if (!(sta->rrm_enabled_capa[1] & WLAN_RRM_CAPS_STATISTICS_MEASUREMENT)) {
+		wpa_printf(MSG_ERROR,
+			   "sta statistics report: Destination station does not support sta statistics in RRM");
+		return -1;
+	}
+
+	/* Measurement report (3) + Measurement element with sta statistics (18) + optional sub-elements (255)*/
+	buf = wpabuf_alloc(3 + 60 + 255);
+	if (!buf)
+		return -1;
+
+	/* IEEE P802.11-REVmc/D6.0, 9.6.7.3 */
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_RADIO_MEASUREMENT_REPORT);
+	wpabuf_put_u8(buf, dialog_token); /* Dialog Token */
+
+	/* IEEE P802.11-REVmc/D5.0, 9.4.2.22 */
+	wpabuf_put_u8(buf, WLAN_EID_MEASURE_REPORT);
+	len = wpabuf_put(buf, 1); /* Length will be set later */
+
+	wpabuf_put_u8(buf, measurement_token); /* Measurement Token */
+	wpabuf_put_u8(buf, measurement_rep_mode); /* Measurement Report Mode */
+	wpabuf_put_u8(buf, MEASURE_TYPE_STA_STATISTICS); /* Measurement Type */
+
+	/* IEEE P802.11-REVmc/D6.0, 9.4.2.22.9 */
+	wpabuf_put_le16(buf, measurement_duration); /* Measurement Duration */
+	wpabuf_put_u8(buf, group_identity); /* group_identity */
+	for (i = 0; i < statistics_group_data_len; i++)
+		if (((group_identity == 11) && ((i == 4) || (i == 8)))
+		  ||((group_identity == 12) && ((i == 2) || (i == 6)))) {
+			wpabuf_put_data(buf, &statistics_group_data[i], 8);
+			i++;
+		} else {
+			wpabuf_put_be32(buf, statistics_group_data[i]);
+		}
+
+	if (rep_reason) {
+		wpabuf_put_u8(buf, 1); /* reporting reason sub element id */
+		wpabuf_put_u8(buf, 1);   /* sub element length */
+		wpabuf_put_u8(buf, *rep_reason);
+	}
+
+	/* Action + measurement type + token + EID + len = 5 */
+	*len = wpabuf_len(buf) - 5;
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+	wpabuf_free(buf);
+	return ret;
+}
+
diff --git a/src/ap/mxl_rrm.h b/src/ap/mxl_rrm.h
new file mode 100644
index 000000000..7c00b70fa
--- /dev/null
+++ b/src/ap/mxl_rrm.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+
+         Copyright (c) 2020 - 2025, MaxLinear, Inc.
+         Copyright 2016 - 2020 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#ifndef MXL_RRM_H
+#define MXL_RRM_H
+
+#define RRM_NOISE_HISTO_IPI_DENSITY_SIZE   11
+#define RRM_STA_STATISTICS_GROUP_DATA_SIZE 13
+
+int mxl_hostapd_send_beacon_report_resp(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u8 op_class, u8 channel, u64 start_time, u16 measurement_duration,
+		u8 frame_info, u8 rcpi, u8 rsni, const u8 *bssid, u8 antenna_id,
+		u32 parent_tsf, u8 *ch_width, u8 *ch_center_freq0, u8 *ch_center_freq1,
+		u8 *rep_frame_body, u8 *rep_frame_body_length);
+int mxl_hostapd_send_beacon_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode,
+		u8 oper_class, u8 channel, u16 random_interval,
+		u16 measurement_duration, u8 mode, const u8* bssid,
+		struct wpa_ssid_value* ssid, u8* rep_cond, u8* rep_cond_threshold,
+		u8* rep_detail,	const u8* ap_ch_rep, unsigned int ap_ch_rep_len,
+		const u8* req_elem, unsigned int req_elem_len, u8 *ch_width,
+		u8 *ch_center_freq0, u8 *ch_center_freq1, u8 last_indication);
+int mxl_hostapd_handle_self_beacon_req(struct hostapd_data *hapd,
+		u16 random_interval, u16 measurement_duration, u8 mode);
+void mxl_hostapd_handle_beacon_report_response(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr);
+void mxl_hostapd_handle_sta_statistics_report(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr);
+void mxl_hostapd_handle_channel_load_report(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr);
+void mxl_hostapd_handle_noise_histogram_report(struct hostapd_data *hapd,
+		u8 token, const u8 *pos, size_t len, const u8 *sta_addr);
+void mxl_hostapd_handle_radio_msmt_request(struct hostapd_data *hapd,
+					   const u8 *buf, size_t len);
+void mxl_hostapd_handle_link_msmt_report(struct hostapd_data *hapd,
+					 const u8 *buf, size_t len);
+void mxl_hostapd_handle_link_msmt_request(struct hostapd_data *hapd,
+					  const u8 *buf, size_t len);
+int mxl_hostapd_send_link_measurement_req(struct hostapd_data *hapd,
+		const u8 *addr);
+int mxl_hostapd_send_link_measurement_report(struct hostapd_data *hapd,
+		const u8 *addr, struct rrm_link_measurement_report link_msmt_report,
+		struct dmg_link_margin *dmg_margin,
+		struct dmg_link_adaptation_ack *dmg_ack);
+int mxl_hostapd_send_channel_load_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode, u8 oper_class,
+		u8 channel, u16 random_interval, u16 measurement_duration, u8 *rep_cond,
+		u8 *ch_load_ref_val, u8 *ch_width, u8 *ch_center_freq0,
+		u8 *ch_center_freq1);
+int mxl_hostapd_send_channel_load_report(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u8 op_class, u8 channel, u64 start_time, u16 measurement_duration,
+		u8 channel_load, u8 *ch_width, u8 *ch_center_freq0,
+		u8 *ch_center_freq1);
+int mxl_hostapd_send_noise_histogram_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode, u8 oper_class,
+		u8 channel, u16 random_interval, u16 measurement_duration, u8 *rep_cond,
+		u8 *anpi_ref_val, u8 *ch_width, u8 *ch_center_freq0,
+		u8 *ch_center_freq1);
+int mxl_hostapd_send_noise_histogram_report(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u8 op_class, u8 channel, u64 start_time, u16 measurement_duration,
+		u8 ant_id, u8 anpi, u8 *ipi_density, u8 *ch_width, u8 *ch_center_freq0,
+		u8 *ch_center_freq1);
+int mxl_hostapd_get_statistics_group_data_len(u8 group_identity);
+int mxl_hostapd_send_sta_statistics_req(struct hostapd_data *hapd, const u8 *addr,
+		u16 num_of_repetitions, u8 measurement_request_mode,
+		const u8 *peer_addr, u16 random_interval, u16 measurement_duration,
+		u8 group_identity, struct rrm_trig_rep_counters *trig_rep_sta_counters,
+		struct rrm_trig_rep_counters *trig_rep_qos_sta_counters,
+		struct rrm_trig_rep_counters *trig_rep_rsna_counters);
+
+int mxl_hostapd_send_sta_statistics_report(struct hostapd_data *hapd, const u8 *addr,
+		u8 dialog_token, u8 measurement_token, u8 measurement_rep_mode,
+		u16 measurement_duration, u8 group_identity,
+		const u32 *statistics_group_data, u8 statistics_group_data_len,
+		u8 *rep_reason);
+
+#endif /* MXL_RRM_H */
diff --git a/src/ap/rrm.c b/src/ap/rrm.c
index f2d5cd16e..b30c57583 100644
--- a/src/ap/rrm.c
+++ b/src/ap/rrm.c
@@ -18,6 +18,9 @@
 #include "eloop.h"
 #include "neighbor_db.h"
 #include "rrm.h"
+#ifdef CONFIG_VENDOR_MXL
+#include "mxl_rrm.h"
+#endif /* CONFIG_VENDOR_MXL */
 
 #define HOSTAPD_RRM_REQUEST_TIMEOUT 5
 
@@ -71,6 +74,7 @@ static void hostapd_handle_range_report(struct hostapd_data *hapd, u8 token,
 }
 
 
+#ifndef CONFIG_VENDOR_MXL
 static void hostapd_handle_beacon_report(struct hostapd_data *hapd,
 					 const u8 *addr, u8 token, u8 rep_mode,
 					 const u8 *pos, size_t len)
@@ -90,6 +94,7 @@ static void hostapd_handle_beacon_report(struct hostapd_data *hapd,
 	wpa_msg(hapd->msg_ctx, MSG_INFO, BEACON_RESP_RX MACSTR " %u %02x %s",
 		MAC2STR(addr), token, rep_mode, report);
 }
+#endif /* CONFIG_VENDOR_MXL */
 
 
 static void hostapd_handle_radio_msmt_report(struct hostapd_data *hapd,
@@ -120,10 +125,29 @@ static void hostapd_handle_radio_msmt_report(struct hostapd_data *hapd,
 		case MEASURE_TYPE_FTM_RANGE:
 			hostapd_handle_range_report(hapd, token, ie + 2, ie[1]);
 			break;
+#ifndef CONFIG_VENDOR_MXL
 		case MEASURE_TYPE_BEACON:
 			hostapd_handle_beacon_report(hapd, mgmt->sa, token,
 						     rep_mode, ie + 2, ie[1]);
 			break;
+#else /* CONFIG_VENDOR_MXL */
+		case MEASURE_TYPE_BEACON:
+			mxl_hostapd_handle_beacon_report_response(hapd, token, ie + 2, ie[1],
+					mgmt->sa);
+			break;
+		case MEASURE_TYPE_STA_STATISTICS:
+			mxl_hostapd_handle_sta_statistics_report(hapd, token, ie + 2, ie[1],
+					mgmt->sa);
+			break;
+		case MEASURE_TYPE_CHANNEL_LOAD:
+			mxl_hostapd_handle_channel_load_report(hapd, token, ie + 2, ie[1],
+					mgmt->sa);
+			break;
+		case MEASURE_TYPE_NOISE_HIST:
+			mxl_hostapd_handle_noise_histogram_report(hapd, token, ie + 2, ie[1],
+					mgmt->sa);
+			break;
+#endif /* CONFIG_VENDOR_MXL */
 		default:
 			wpa_printf(MSG_DEBUG,
 				   "Measurement report type %u is not supported",
@@ -356,6 +380,17 @@ void hostapd_handle_radio_measurement(struct hostapd_data *hapd,
 	case WLAN_RRM_NEIGHBOR_REPORT_REQUEST:
 		hostapd_handle_nei_report_req(hapd, buf, len);
 		break;
+#ifdef CONFIG_VENDOR_MXL
+	case WLAN_RRM_RADIO_MEASUREMENT_REQUEST:
+		mxl_hostapd_handle_radio_msmt_request(hapd, buf, len);
+		break;
+	case WLAN_RRM_LINK_MEASUREMENT_REPORT:
+		mxl_hostapd_handle_link_msmt_report(hapd, buf, len);
+		break;
+	case WLAN_RRM_LINK_MEASUREMENT_REQUEST:
+		mxl_hostapd_handle_link_msmt_request(hapd, buf, len);
+		break;
+#endif /* CONFIG_VENDOR_MXL */
 	default:
 		wpa_printf(MSG_DEBUG, "RRM action %u is not supported",
 			   mgmt->u.action.u.rrm.action);
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index 8b28a5285..e2fb39b56 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -1301,6 +1301,7 @@ const char * ap_sta_wpa_get_keyid(struct hostapd_data *hapd,
 	return psk->keyid;
 }
 
+#define STA_EVENT_MAX_BUF_LEN	1024
 
 const u8 * ap_sta_wpa_get_dpp_pkhash(struct hostapd_data *hapd,
 				     struct sta_info *sta)
@@ -1313,7 +1314,9 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 			   int authorized)
 {
 	const u8 *dev_addr = NULL;
-	char buf[100];
+	char *buf, *pos, *end;
+	int buflen = STA_EVENT_MAX_BUF_LEN;
+	int i, ret = 0, len = 0;
 #ifdef CONFIG_P2P
 	u8 addr[ETH_ALEN];
 	u8 ip_addr_buf[4];
@@ -1322,6 +1325,12 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 	if (!!authorized == !!(sta->flags & WLAN_STA_AUTHORIZED))
 		return;
 
+	buf = os_malloc(buflen);
+	if (!buf)
+		return;
+	pos = buf;
+	end = buf + buflen;
+
 	if (authorized) {
 		int mld_assoc_link_id = -1;
 
@@ -1350,11 +1359,21 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 		dev_addr = p2p_group_get_dev_addr(hapd->p2p_group, sta->addr);
 
 	if (dev_addr)
-		os_snprintf(buf, sizeof(buf), MACSTR " p2p_dev_addr=" MACSTR,
+		ret = os_snprintf(buf, sizeof(buf), MACSTR " p2p_dev_addr=" MACSTR,
 			    MAC2STR(sta->addr), MAC2STR(dev_addr));
+		if (os_snprintf_error(end - pos, ret))
+			goto free_alloc;
+		pos += ret;
 	else
 #endif /* CONFIG_P2P */
-		os_snprintf(buf, sizeof(buf), MACSTR, MAC2STR(sta->addr));
+	{
+		ret = sprintf_s(pos, end - pos, MACSTR, MAC2STR(sta->addr));
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			goto free_alloc;
+		}
+		pos += ret;
+	}
 
 	if (hapd->sta_authorized_cb)
 		hapd->sta_authorized_cb(hapd->sta_authorized_cb_ctx,
@@ -1366,10 +1385,30 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 		char dpp_pkhash_buf[100];
 		char keyid_buf[100];
 		char ip_addr[100];
+		char signal_strength[30];
+		char *rates, *capabilities;
+		int ret;
 
 		dpp_pkhash_buf[0] = '\0';
 		keyid_buf[0] = '\0';
 		ip_addr[0] = '\0';
+
+		/* 4 symbols per rate */
+		rates = os_malloc(WLAN_SUPP_RATES_MAX * 4);
+		if (rates == NULL) {
+			wpa_printf(MSG_ERROR, "malloc failed");
+			goto free_alloc;
+		}
+		rates[0] = '\0';
+
+		capabilities = os_malloc(120);
+		if (capabilities == NULL) {
+			wpa_printf(MSG_ERROR, "malloc failed");
+			os_free(rates);
+			goto free_alloc;
+		}
+		capabilities[0] = '\0';
+
 #ifdef CONFIG_P2P
 		if (wpa_auth_get_ip_addr(sta->wpa_sm, ip_addr_buf) == 0) {
 			os_snprintf(ip_addr, sizeof(ip_addr),
@@ -1397,15 +1436,96 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 					 dpp_pkhash, SHA256_MAC_LEN);
 		}
 
-		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_CONNECTED "%s%s%s%s",
-			buf, ip_addr, keyid_buf, dpp_pkhash_buf);
+		ret = sprintf_s(signal_strength, sizeof(signal_strength),
+			  " SignalStrength=%d", (s32)sta->ssi_signal);
+		if (ret <= 0) {
+			wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+			os_free(rates);
+			os_free(capabilities);
+			goto free_alloc;
+		}
+
+		len = 0;
+		for (i = 0; i < sta->supported_rates_len; i++) {
+			if (i > 0)
+				ret = sprintf_s(rates + len, WLAN_SUPP_RATES_MAX * 4 - len,
+						" %d", sta->supported_rates[i]);
+			 else
+				ret = sprintf_s(rates + len, WLAN_SUPP_RATES_MAX * 4 - len,
+						" SupportedRates=%d", sta->supported_rates[i]);
+			if (ret <= 0) {
+				wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+				os_free(rates);
+				os_free(capabilities);
+				goto free_alloc;
+			}
+			len += ret;
+		}
+
+		len = 0;
+		if (sta->ht_capabilities) {
+			ret = sprintf_s(capabilities + len, 120 - len, " HT_CAP=%04X",
+					le_to_host16(sta->ht_capabilities->ht_capabilities_info));
+			if (ret <= 0) {
+				wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+				os_free(rates);
+				os_free(capabilities);
+				goto free_alloc;
+			}
+		len += ret;
+			for (i = 0; i < sizeof(sta->ht_capabilities->supported_mcs_set) /
+				sizeof(sta->ht_capabilities->supported_mcs_set[0]); i++) {
+				if (i > 0)
+					ret = sprintf_s(capabilities + len, 120 - len, " %02X",
+							sta->ht_capabilities->supported_mcs_set[i]);
+				else
+					ret = sprintf_s(capabilities + len, 120 - len, " HT_MCS=%02X",
+							sta->ht_capabilities->supported_mcs_set[i]);
+
+				if (ret <= 0) {
+					wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+					os_free(rates);
+					os_free(capabilities);
+					goto free_alloc;
+				}
+				len += ret;
+			}
+		}
+		if (sta->vht_capabilities) {
+			ret = sprintf_s(capabilities + len, 120 - len, " VHT_CAP=%08X",
+					le_to_host32(sta->vht_capabilities->vht_capabilities_info));
+			if (ret <= 0) {
+				wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+				os_free(rates);
+				os_free(capabilities);
+				goto free_alloc;
+			}
+			len += ret;
+			ret = sprintf_s(capabilities + len, 120 - len, " VHT_MCS=%04X %04X %04X %04X",
+					le_to_host16(sta->vht_capabilities->vht_supported_mcs_set.rx_map),
+					le_to_host16(sta->vht_capabilities->vht_supported_mcs_set.rx_highest),
+					le_to_host16(sta->vht_capabilities->vht_supported_mcs_set.tx_map),
+					le_to_host16(sta->vht_capabilities->vht_supported_mcs_set.tx_highest));
+			if (ret <= 0) {
+				wpa_printf(MSG_ERROR, "%s: sprintf_s error %d", __func__, ret);
+				os_free(rates);
+				os_free(capabilities);
+				goto free_alloc;
+			}
+			len += ret;
+		}
+
+		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_CONNECTED "%s%s%s%s%s%s%s",
+			buf, ip_addr, signal_strength, rates, capabilities, keyid_buf, dpp_pkhash_buf);
 
 		if (hapd->msg_ctx_parent &&
 		    hapd->msg_ctx_parent != hapd->msg_ctx)
 			wpa_msg_no_global(hapd->msg_ctx_parent, MSG_INFO,
-					  AP_STA_CONNECTED "%s%s%s%s",
-					  buf, ip_addr, keyid_buf,
+					  AP_STA_CONNECTED "%s%s%s%s%s%s%s",
+					  buf, ip_addr, signal_strength, rates, capabilities, keyid_buf,
 					  dpp_pkhash_buf);
+		os_free(rates);
+		os_free(capabilities);
 	} else {
 		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_DISCONNECTED "%s", buf);
 
@@ -1424,6 +1544,9 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 						     sta->addr);
 	}
 #endif /* CONFIG_FST */
+
+free_alloc:
+	os_free(buf);
 }
 
 
@@ -1649,6 +1772,7 @@ int ap_sta_re_add(struct hostapd_data *hapd, struct sta_info *sta)
 			    sta->supported_rates_len,
 			    0, NULL, NULL, NULL, 0, NULL, 0, NULL,
 			    sta->flags, 0, 0, 0, 0,
+			    sta->ssi_signal,
 			    mld_link_addr, mld_link_sta)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211,
diff --git a/src/ap/sta_info.h b/src/ap/sta_info.h
index e2b9dde87..116e9930a 100644
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -333,6 +333,8 @@ struct sta_info {
 	struct mld_info mld_info;
 	u8 mld_assoc_link_id;
 #endif /* CONFIG_IEEE80211BE */
+
+	u32 ssi_signal; /* dBm */
 };
 
 
diff --git a/src/ap/utils.c b/src/ap/utils.c
index e93e53171..3ba746775 100644
--- a/src/ap/utils.c
+++ b/src/ap/utils.c
@@ -110,3 +110,89 @@ void hostapd_prune_associations(struct hostapd_data *hapd, const u8 *addr,
 		hapd->iface->interfaces->for_each_interface(
 			hapd->iface->interfaces, prune_associations, &data);
 }
+
+#define hostapd_skip_space	while(isspace(*s)) s++
+#define get_number(x, s, e)	(x = strtol(s, e, 10), *e != s)
+
+static int get_rnge(const char *s, char **e, struct hostapd_iface *iface,
+	int (*range_cb)(struct hostapd_iface*, int, int))
+{
+	int x, y, ret;
+	char *ee;
+
+	if (!get_number(x, s, &ee))
+		return 0;
+	s = ee;
+
+	if (*s != '-') {
+		*(const char **)e = s;
+		return 0;
+	}
+
+	s++;
+
+	if (!get_number(y, s, e))
+		return 0;
+	if (y <= x)
+		return 0;
+	if (range_cb) {
+		ret = range_cb(iface, x, y);
+		if (ret)
+			return ret;
+	}
+
+	return 1;
+}
+
+/**
+ * hostapd_get_list - parses a list of numbers, in the form of "1 6 11-13".
+ * Range may start with one or several spaces.
+ * @s: String of numbers
+ * @e: Upon exit contains pointer to place in s that caused parsing failure
+ * @number_cb: function than will be called when number is found in s. Should
+ *             return 0 on success
+ * @range_cb: function than will be called when range is found in s. Should
+ *            return 0 on success
+ *
+ * Returns 0 - success; -1 - failure
+ */
+int hostapd_get_list(const char *s, char **e, struct hostapd_iface *iface,
+	int (*number_cb)(struct hostapd_iface*, int),
+	int (*range_cb)(struct hostapd_iface*, int, int))
+{
+	int x, ret;
+	int range, number = 0;
+
+	hostapd_skip_space;
+
+	/* empty string - OK */
+	if ((*s) == '\0')
+		return 0;
+
+	while (1) {
+		range = get_rnge(s, e, iface, range_cb);
+		/* returns -1 on error */
+		if (range == -1)
+			break;
+		/* returns 0 if range not found */
+		if (!range) {
+			number = get_number(x, s, e);
+			if (number && number_cb) {
+				ret = number_cb(iface, x);
+				if (ret)
+					break;
+			}
+		}
+		if (!range && !number)
+			break;
+		s = *e;
+
+		if ((*s) == '\0')
+			return 0;
+		if ((*s) == ' ') { s++; continue; }
+			break;
+	}
+
+	*(const char **)e = s;
+	return -1;
+}
diff --git a/src/common/cli.h b/src/common/cli.h
index 41ef32969..9f9cd686a 100644
--- a/src/common/cli.h
+++ b/src/common/cli.h
@@ -41,7 +41,11 @@ int get_cmd_arg_num(const char *str, int pos);
 int write_cmd(char *buf, size_t buflen, const char *cmd, int argc,
 	      char *argv[]);
 
+#ifdef CONFIG_VENDOR_MXL
+#define max_args 15
+#else
 #define max_args 10
+#endif /* CONFIG_VENDOR_MXL */
 int tokenize_cmd(char *cmd, char *argv[]);
 
 #endif /* CLI_H */
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index f27a901cc..58f5073cb 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -2123,6 +2123,7 @@ enum beacon_report_mode {
 #define WLAN_BEACON_REQUEST_SUBELEM_DETAIL	2 /* Reporting Detail */
 #define WLAN_BEACON_REQUEST_SUBELEM_REQUEST	10
 #define WLAN_BEACON_REQUEST_SUBELEM_AP_CHANNEL	51 /* AP Channel Report */
+#define WLAN_BEACON_REQUEST_SUBELEM_WIDE_BW_CS	163
 #define WLAN_BEACON_REQUEST_SUBELEM_LAST_INDICATION	164
 #define WLAN_BEACON_REQUEST_SUBELEM_VENDOR	221
 
diff --git a/src/common/mxl_ieee802_11_defs.h b/src/common/mxl_ieee802_11_defs.h
index e235fa9fe..482a90ce2 100644
--- a/src/common/mxl_ieee802_11_defs.h
+++ b/src/common/mxl_ieee802_11_defs.h
@@ -44,13 +44,13 @@
 #define RNR_TBTT_PARAMS_COLOC_AP			0x40
 
 /* RNR scanned freq flag */
-#define RNR_AOCS_SCAN_PASSIVE_CHANNEL	0x01
-#define RNR_AOCS_SCAN_ACTIVE_CHANNEL	0x02
-#define RNR_AOCS_SCAN_SSID				0x04
-#define RNR_AOCS_SCAN_SHORT_SSID		0x08
-#define RNR_AOCS_SCAN_BSSID				0x10
+#define RNR_AOCS_SCAN_PASSIVE_CHANNEL   0x01
+#define RNR_AOCS_SCAN_ACTIVE_CHANNEL    0x02
+#define RNR_AOCS_SCAN_SSID                              0x04
+#define RNR_AOCS_SCAN_SHORT_SSID                0x08
+#define RNR_AOCS_SCAN_BSSID                             0x10
 
-#define RNR_SHORT_SSID_LEN	4
+#define RNR_SHORT_SSID_LEN      4
 
 struct rnr_neighbor_ap_info {
 	u8 tbtt_info_hdr;
@@ -61,10 +61,10 @@ struct rnr_neighbor_ap_info {
 
 /* According to IEEE80211-2016 "The subfields of the
  * VHT Operation Information field are defined in Table 9-252.*/
-#define VHT_OPER_CHANWIDTH_20_40MHZ			0
-#define VHT_OPER_CHANWIDTH_80_160_80P80MHZ	1
-#define VHT_OPER_CHANWIDTH_160MHZ			2
-#define VHT_OPER_CHANWIDTH_80P80MHZ			3
+#define VHT_OPER_CHANWIDTH_20_40MHZ                     0
+#define VHT_OPER_CHANWIDTH_80_160_80P80MHZ      1
+#define VHT_OPER_CHANWIDTH_160MHZ                       2
+#define VHT_OPER_CHANWIDTH_80P80MHZ                     3
 
 struct multi_ap_blacklist {
 	struct dl_list list;
@@ -76,5 +76,52 @@ struct multi_ap_blacklist {
 	u8 snrAuthLWM;
 };
 
+/* Beacon Measurements */
+struct tlv {
+	u8 type;
+	u8 length;
+	u8 value[];
+};
+
+struct beacon_body {
+	u8 length;
+	u64 timestamp;
+	le16 beacon_int;
+	le16 capab_info;
+};
+
+struct beacon_request {
+	u8 src_addr[ETH_ALEN];
+	u8 dialog_token;
+	u8 measurement_token;
+} STRUCT_PACKED;
+
+struct rrm_trig_rep_counters {
+	u32 measurement_count;
+	u16 trigger_timeout;
+	u16 counters_trigger_condition;
+	u8 num_of_counters;
+	u32 counters[7];
+} STRUCT_PACKED;
+
+/* IEEE Std 802.11-2012, 9.4.2.142.1 - DMG link margin element frame format */
+struct dmg_link_margin {
+	u8 eid;
+	u8 len;
+	u8 activity;
+	u8 mcs;
+	s8 link_margin;
+	u8 snr;
+	le32 ref_timestamp;
+} STRUCT_PACKED;
+
+/* IEEE Std 802.11-2012, 9.4.2.143 - DMG link margin element frame format */
+struct dmg_link_adaptation_ack {
+	u8 eid;
+	u8 len;
+	u8 activity;
+	le32 ref_timestamp;
+} STRUCT_PACKED;
+
 #endif /* MXL_IEEE802_11_DEFS_H */
 
diff --git a/src/common/mxl_wpa_ctrl.h b/src/common/mxl_wpa_ctrl.h
index 8d807cd35..1e4b57fb7 100644
--- a/src/common/mxl_wpa_ctrl.h
+++ b/src/common/mxl_wpa_ctrl.h
@@ -26,4 +26,20 @@
 /* Event to indicate Sogtblock drop */
 #define LTQ_SOFTBLOCK_DROP "LTQ-SOFTBLOCK-DROP"
 
+#define RRM_EVENT_BEACON_REP_RXED "RRM-BEACON-REP-RECEIVED "
+#define RRM_EVENT_BEACON_REQUEST_RXED "RRM-BEACON-REP-REQUEST-RECEIVED "
+#define RRM_EVENT_SELF_BEACON_REP_RXED "RRM-SELF-BEACON-REP-RECEIVED "
+#define RRM_EVENT_NEIGHBOR_REP_MBSSID_RXED "RRM-NEIGHBOR-REP-MBSSID-RECEIVED "
+#define RRM_EVENT_CHANNEL_LOAD_RXED "RRM-CHANNEL-LOAD-RECEIVED "
+#define RRM_EVENT_CHANNEL_LOAD_REQUEST_RXED "RRM-CHANNEL-LOAD-REQUEST-RECEIVED "
+#define RRM_EVENT_NOISE_HISTOGRAM_RXED "RRM-NOISE-HISTOGRAM-RECEIVED "
+#define RRM_EVENT_NOISE_HISTOGRAM_REQUEST_RXED \
+	"RRM-NOISE-HISTOGRAM-REQUEST-RECEIVED "
+#define RRM_EVENT_LINK_MEASUREMENT_RXED "RRM-LINK-MEASUREMENT-RECEIVED "
+#define RRM_EVENT_LINK_MEASUREMENT_REQUEST_RXED \
+	"RRM-LINK-MEASUREMENT-REQUEST-RECEIVED "
+#define RRM_EVENT_STA_STATISTICS_RXED "RRM-STA-STATISTICS-RECEIVED "
+#define RRM_EVENT_STA_STATISTICS_REQUEST_RXED \
+	"RRM-STA-STATISTICS-REQUEST-RECEIVED "
+
 #endif /* MXL_WPA_CTRL_H */
diff --git a/src/common/vendor_cmds_copy.h b/src/common/vendor_cmds_copy.h
index 80f3b835e..b43f93536 100644
--- a/src/common/vendor_cmds_copy.h
+++ b/src/common/vendor_cmds_copy.h
@@ -446,6 +446,9 @@ struct mxl_ml_sta_info {
   u16 aid;
 } __attribute__ ((packed));
 
+/* Maximum possible number of antennas for statistics in driver */
+#define WAVE_STAT_MAX_ANTENNAS                5
+
 /* SoftBlock Timer ACL configuration */
 struct intel_vendor_sb_timer_acl_cfg {
   int timer_acl_on;
@@ -460,6 +463,117 @@ struct intel_vendor_blacklist_cfg {
   u8 snrProbeLWM;
 } __attribute__ ((packed));
 
+struct intel_vendor_sta_info { /* corresponds to vendor_sta_info in Driver */
+  u32 StationId;
+  u32 NetModesSupported;
+  u64 BytesSent;        /* Peer traffic */
+  u64 BytesReceived;
+  u64 PacketsSent;
+  u64 PacketsReceived;
+  u32 RetransCount;
+  u32 FailedRetransCount;
+  u32 RetryCount;
+  u32 LastDataUplinkRate;   /* Kbps */
+  u32 LastDataDownlinkRate; /* Kbps */
+  u32 MaxRate;              /* Kbps */
+  u32 ErrorsSent;
+  u32 RateInfoFlag; /* Is rate info valid */
+  u32 RatePhyMode;  /* Network (Phy) Mode */
+  u32 RateCbwMHz;   /* BW [MHz] */
+  u32 RateMcs;      /* MCS index */
+  u32 RateNss;      /* NSS */
+  s8  snr[WAVE_STAT_MAX_ANTENNAS];
+  s8  ShortTermRSSIAverage[WAVE_STAT_MAX_ANTENNAS];
+  s32 SignalStrength;
+  u32 TxMgmtPwr;
+  u32 TxStbcMode;
+} __attribute__ ((packed));
+
+struct intel_vendor_traffic_stats {
+  u64 BytesSent;
+  u64 BytesReceived;
+  u64 PacketsSent;
+  u64 PacketsReceived;
+  u32 UnicastPacketsSent;
+  u32 UnicastPacketsReceived;
+  u32 MulticastPacketsSent;
+  u32 MulticastPacketsReceived;
+  u32 BroadcastPacketsSent;
+  u32 BroadcastPacketsReceived;
+} __attribute__ ((packed));
+
+struct intel_vendor_error_stats {
+  u32 ErrorsSent;
+  u32 ErrorsReceived;
+  u32 DiscardPacketsSent;
+  u32 DiscardPacketsReceived;
+} __attribute__ ((packed));
+
+struct intel_vendor_vap_info {
+  struct intel_vendor_traffic_stats traffic_stats;
+  struct intel_vendor_error_stats   error_stats;
+  u32 RetransCount;
+  u32 FailedRetransCount;
+  u32 RetryCount;
+  u32 MultipleRetryCount;
+  u32 ACKFailureCount;
+  u32 AggregatedPacketCount;
+  u32 UnknownProtoPacketsReceived;
+  u64 TransmittedOctetsInAMSDUCount;
+  u64 ReceivedOctetsInAMSDUCount;
+  u64 TransmittedOctetsInAMPDUCount;
+  u64 ReceivedOctetsInAMPDUCount;
+  u32 RTSSuccessCount;
+  u32 RTSFailureCount;
+  u32 TransmittedAMSDUCount;
+  u32 FailedAMSDUCount;
+  u32 AMSDUAckFailureCount;
+  u32 ReceivedAMSDUCount;
+  u32 TransmittedAMPDUCount;
+  u32 TransmittedMPDUsInAMPDUCount;
+  u32 AMPDUReceivedCount;
+  u32 MPDUInReceivedAMPDUCount;
+  u32 ImplicitBARFailureCount;
+  u32 ExplicitBARFailureCount;
+  u32 TwentyMHzFrameTransmittedCount;
+  u32 FortyMHzFrameTransmittedCount;
+  u32 SwitchChannel20To40;
+  u32 SwitchChannel40To20;
+  u32 FrameDuplicateCount;
+} __attribute__ ((packed));
+
+struct intel_vendor_radio_info {
+  struct intel_vendor_traffic_stats traffic_stats;
+  struct intel_vendor_error_stats error_stats;
+  u8 Enable;
+  u8 Channel;
+  u32 FCSErrorCount;
+  s32 Noise;
+  u64 tsf_start_time;
+  u8 load;
+  u32 tx_pwr_cfg;
+  u8 num_tx_antennas;
+  u8 num_rx_antennas;
+  u32 primary_center_freq; /* center frequency in MHz */
+  u32 center_freq1;
+  u32 center_freq2;
+  u32 width; /* 20,40,80,... */
+} __attribute__ ((packed));
+
+struct intel_vendor_unconnected_sta_req_cfg {
+  u32 bandwidth;
+  u32 freq;
+  u32 center_freq1;
+  u32 center_freq2;
+  DEF_IEEE_ADDR(addr);
+} __attribute__ ((packed));
+
+struct intel_vendor_steer_cfg {
+  DEF_IEEE_ADDR(addr);
+  DEF_IEEE_ADDR(bssid);
+  u16 status;
+} __attribute__ ((packed));
+
 /*******************************************************************************
 *                           Event structures                                   *
 *******************************************************************************/
@@ -491,4 +605,14 @@ struct intel_vendor_event_msg_drop {
   u8 reason;                    /**< Ignore for Probe Req       */
 } __attribute__ ((packed));
 
+/* Data for EVENT_LTQ_UNCONNECTED_STA_RX events */
+struct intel_vendor_unconnected_sta {
+  u64 rx_bytes;
+  u32 rx_packets;
+  s8 rssi[WAVE_STAT_MAX_ANTENNAS];
+  DEF_IEEE_ADDR(addr);
+  s8 noise[WAVE_STAT_MAX_ANTENNAS];
+  u16 rate;
+} __attribute__ ((packed));
+
 #endif /* _VENDOR_CMDS_H_ */
diff --git a/src/common/wpa_ctrl.h b/src/common/wpa_ctrl.h
index 416e0d6a8..d0650f8a0 100644
--- a/src/common/wpa_ctrl.h
+++ b/src/common/wpa_ctrl.h
@@ -436,6 +436,9 @@ extern "C" {
 /* Event triggered for received management frame */
 #define AP_MGMT_FRAME_RECEIVED "AP-MGMT-FRAME-RECEIVED "
 
+#define HOSTAPD_DISCONNECTED "HOSTAPD-DISCONNECTED"
+#define UNCONNECTED_STA_RSSI "UNCONNECTED-STA-RSSI "
+
 #ifndef BIT
 #define BIT(x) (1U << (x))
 #endif
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 86abc8cda..9d092eb43 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -29,6 +29,7 @@
 #include "utils/list.h"
 #ifdef CONFIG_VENDOR_MXL
 #include "mxl_driver.h"
+#include "mxl_common.h"
 #endif /* CONFIG_VENDOR_MXL */
 
 #define HOSTAPD_CHAN_DISABLED 0x00000001
@@ -2442,6 +2443,10 @@ struct wpa_driver_capa {
 	unsigned int mbssid_max_interfaces;
 	/* Maximum profile periodicity for enhanced MBSSID advertisement */
 	unsigned int ema_max_periodicity;
+
+	/* Bitmap of antennas which are available to be configured as TX/RX antennas.
+	 */
+	unsigned int available_antennas_tx, available_antennas_rx;
 };
 
 
@@ -2548,6 +2553,7 @@ struct hostapd_sta_add_params {
 	bool mld_link_sta;
 	s8 mld_link_id;
 	const u8 *mld_link_addr;
+	int ssi_signal;
 };
 
 struct mac_address {
@@ -5179,6 +5185,33 @@ struct wpa_driver_ops {
 	 */
 	int (*link_add)(void *priv, u8 link_id, const u8 *addr);
 
+	/**
+	 * sta_steer - Steer station to required VAP
+	 * @priv: Private driver interface data
+	 * @entry: pointer to multi_ap_blacklist structure
+	 * @bssid: VAP to steer to
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*sta_steer)(void *priv, const struct multi_ap_blacklist *entry,
+		const u8 *bssid);
+
+	/**
+	 * sta_allow - Add station(s) to whitelist
+	 * @priv: Private driver interface data
+	 * @stations: Array of station MAC addresses
+	 * @count: Number of stations
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*sta_allow)(void *priv, const u8 *stations, int count);
+
+	/**
+	 * unconnected_sta - Trigger unconnected station statistics
+	 * @priv: Private driver interface data
+	 * @req: Input parameters
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*unconnected_sta)(void *priv, struct intel_vendor_unconnected_sta_req_cfg *req);
+
 #ifdef CONFIG_TESTING_OPTIONS
 	int (*register_frame)(void *priv, u16 type,
 			      const u8 *match, size_t match_len,
@@ -5812,6 +5845,7 @@ enum wpa_event_type {
 	 */
 	EVENT_LINK_RECONFIG,
 
+	EVENT_LTQ_UNCONNECTED_STA_RX,
 };
 
 
@@ -6773,6 +6807,8 @@ union wpa_event_data {
 		u8 valid_links;
 		struct t2lm_mapping t2lmap[MAX_NUM_MLD_LINKS];
 	} t2l_map_info;
+
+	struct intel_vendor_unconnected_sta unconnected_sta;
 };
 
 /**
@@ -6860,6 +6896,25 @@ static inline void drv_event_eapol_rx2(void *ctx, const u8 *src, const u8 *data,
 	wpa_supplicant_event(ctx, EVENT_EAPOL_RX, &event);
 }
 
+static inline void drv_event_ltq_unconnected_sta(void *ctx, const u8 *data, size_t data_len)
+{
+	errno_t err;
+	union wpa_event_data event;
+	os_memset(&event, 0, sizeof(event));
+
+	if (!data || (data_len != sizeof(event.unconnected_sta))) {
+		wpa_printf(MSG_ERROR, "Received LTQ vendor Unconnected STA wrong data size");
+		return;
+	}
+
+	err = memcpy_s(&event.unconnected_sta, sizeof(event.unconnected_sta), data, data_len);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+	wpa_supplicant_event(ctx, EVENT_LTQ_UNCONNECTED_STA_RX, &event);
+}
+
 /* driver_common.c */
 void wpa_scan_results_free(struct wpa_scan_results *res);
 
diff --git a/src/drivers/driver_common.c b/src/drivers/driver_common.c
index 9bc5a731d..afd5ff637 100644
--- a/src/drivers/driver_common.c
+++ b/src/drivers/driver_common.c
@@ -100,6 +100,7 @@ const char * event_to_string(enum wpa_event_type event)
 	E2S(LINK_CH_SWITCH_STARTED);
 	E2S(TID_LINK_MAP);
 	E2S(LINK_RECONFIG);
+	E2S(LTQ_UNCONNECTED_STA_RX);
 	}
 
 	return "UNKNOWN";
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 31ad8fb28..4bc9314e8 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -5725,6 +5725,9 @@ static int wpa_driver_nl80211_sta_add(void *priv,
 			goto fail;
 	}
 	if (!params->set) {
+		/* RSSI */
+		wpa_printf(MSG_DEBUG, "  * ssi_signal=%d", params->ssi_signal);
+		nla_put_u32(msg, NL80211_ATTR_STA_RSSI, (u32)params->ssi_signal);
 		if (params->aid) {
 			wpa_printf(MSG_DEBUG, "  * aid=%u", params->aid);
 			if (nla_put_u16(msg, NL80211_ATTR_STA_AID, params->aid))
@@ -13951,7 +13954,7 @@ int nl80211_get_aid_vendor_mxl(void *priv, u16 *aid, const u8 *addr)
 		wpa_printf(MSG_DEBUG, "Received a new AID %hu", *aid);
 	}
 
-	rsp_aid = wpabuf_alloc(aid_size);
+	wpabuf_free(rsp_aid);
 	return res;
 }
 
@@ -13990,6 +13993,89 @@ static int nl80211_send_sync_done_vendor_mxl(void *priv)
 }
 #endif /* CONFIG_DRIVER_NL80211_MXL */
 
+static int nl80211_sta_steer(void *priv, const struct multi_ap_blacklist* entry, const u8 *bssid)
+{
+	int ret;
+	errno_t err;
+	struct intel_vendor_steer_cfg steer;
+
+	os_memset(&steer, 0, sizeof(steer));
+	err = memcpy_s(steer.addr, sizeof(steer.addr), entry->addr, ETH_ALEN);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return -ENOBUFS;
+	}
+	err = memcpy_s(steer.bssid, sizeof(steer.bssid), bssid, ETH_ALEN);
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return -ENOBUFS;
+	}
+	steer.status = entry->status;
+	ret = nl80211_vendor_cmd(priv, OUI_LTQ,
+		LTQ_NL80211_VENDOR_SUBCMD_STA_STEER, (u8*) &steer, sizeof(steer), NESTED_ATTR_NOT_USED, NULL);
+
+	if (ret < 0)
+		wpa_printf(MSG_ERROR, "nl80211: sending STA_STEER failed: %i (%s)",
+			ret, strerror(-ret));
+	else
+		wpa_printf(MSG_DEBUG, MACSTR " steered to " MACSTR, MAC2STR(steer.addr), MAC2STR(bssid));
+
+  return ret;
+}
+
+static int nl80211_sta_allow(void *priv, const u8 *stations, int count)
+{
+	errno_t err;
+	int i, ret, final_ret = 0;
+	struct intel_vendor_blacklist_cfg blacklist;
+
+	os_memset(&blacklist, 0, sizeof(blacklist));
+	/* remove STA from blacklist */
+	blacklist.remove = 1;
+	if (count > 0) {
+		for (i = 0; i < count; i++) {
+			err = memcpy_s(blacklist.addr, sizeof(blacklist.addr), stations + i * ETH_ALEN, ETH_ALEN);
+			if (EOK != err) {
+				wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+				return -ENOBUFS;
+			}
+			ret = nl80211_vendor_cmd(priv, OUI_LTQ,
+				LTQ_NL80211_VENDOR_SUBCMD_SET_DENY_MAC, (u8*) &blacklist,
+				sizeof(blacklist), NESTED_ATTR_NOT_USED, NULL);
+
+			if (ret < 0) {
+				wpa_printf(MSG_ERROR, "nl80211: failed to remove station " MACSTR
+					" from the blacklist: %i (%s)",
+					MAC2STR(stations + i * ETH_ALEN), ret, strerror(-ret));
+				final_ret = ret;
+			} else
+				wpa_printf(MSG_DEBUG, MACSTR " removed from blacklist",
+					MAC2STR(stations + i * ETH_ALEN));
+		}
+  } else
+		/* with all 0's STA MAC will allow all STAs */
+		final_ret = nl80211_vendor_cmd(priv, OUI_LTQ,
+			LTQ_NL80211_VENDOR_SUBCMD_SET_DENY_MAC, (u8*) &blacklist,
+			sizeof(blacklist), NESTED_ATTR_NOT_USED, NULL);
+
+	return final_ret;
+}
+
+static int nl80211_unconnected_sta(void *priv, struct intel_vendor_unconnected_sta_req_cfg *req)
+{
+	int res = 0;
+
+	res = nl80211_vendor_cmd(priv, OUI_LTQ,
+		LTQ_NL80211_VENDOR_SUBCMD_GET_UNCONNECTED_STA, (u8*) req, sizeof(*req),
+		NESTED_ATTR_NOT_USED, NULL);
+	if (res) {
+		wpa_printf(MSG_ERROR, "nl80211: UNCONNECTED_STA failed: %i (%s)", res,
+		strerror(-res));
+	}
+
+	return res;
+}
+
 const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.name = "nl80211",
 	.desc = "Linux nl80211/cfg80211",
@@ -14140,6 +14226,9 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.update_connect_params = nl80211_update_connection_params,
 	.send_external_auth_status = nl80211_send_external_auth_status,
 	.set_4addr_mode = nl80211_set_4addr_mode,
+	.sta_steer = nl80211_sta_steer,
+	.sta_allow = nl80211_sta_allow,
+	.unconnected_sta = nl80211_unconnected_sta,
 #ifdef CONFIG_DPP
 	.dpp_listen = nl80211_dpp_listen,
 #endif /* CONFIG_DPP */
diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index e67027e60..e33a3c464 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -3262,6 +3262,26 @@ static void mxl_nl80211_handle_softblock_drop(struct wpa_driver_nl80211_data *dr
 
 #endif /* CONFIG_DRIVER_NL80211_MXL */
 
+/******************************************************************************/
+/*! \brief      Handle Unconnected STA vendor event from driver
+ *
+ *  \param[in]  drv      pointer to wpa_driver_nl80211_data
+ *  \param[in]  data     pointer to data, must not be NULL
+ *  \param[in]  len      data size, must be sizeof(struct intel_vendor_unconnected_sta)
+ *
+ *  \note       \a drv is not NULL
+ *
+ *  \return     void
+ */
+static void ltq_nl80211_handle_unconnected_sta(struct wpa_driver_nl80211_data *drv,
+			const u8 *data, size_t len)
+{
+	wpa_printf(MSG_INFO, "nl80211: Receive LTQ vendor event:Unconnected station, ctx=%p",
+			drv->ctx);
+
+	drv_event_ltq_unconnected_sta(drv->ctx, data, len);
+}
+
 static void nl80211_vendor_event_mxl(struct wpa_driver_nl80211_data *drv,
 				     u32 subcmd, u8 *data, size_t len)
 {
@@ -3278,6 +3298,9 @@ static void nl80211_vendor_event_mxl(struct wpa_driver_nl80211_data *drv,
 		case LTQ_NL80211_VENDOR_EVENT_COC_BEACON_UPDATE:
 			mxl_nl80211_handle_coc(drv, data, len);
 			break;
+		case LTQ_NL80211_VENDOR_EVENT_UNCONNECTED_STA:
+			ltq_nl80211_handle_unconnected_sta(drv, data, len);
+			break;
 		default:
 			wpa_printf(MSG_DEBUG, "nl80211: Ignore unsupported MXL vendor event %u", subcmd);
 			break;
diff --git a/src/utils/mxl_common.h b/src/utils/mxl_common.h
index 01637eb5c..751d41a62 100644
--- a/src/utils/mxl_common.h
+++ b/src/utils/mxl_common.h
@@ -17,6 +17,10 @@
 /* Validation macros */
 #define IS_VALID_RANGE(val, min, max) ((val >= min) && (val <= max))
 #define IS_VALID_BOOL_RANGE(val) IS_VALID_RANGE(val, false, true)
+#define IS_VALID_S8_RANGE(val) IS_VALID_RANGE(val, INT8_MIN, INT8_MAX)
+#define IS_VALID_U16_RANGE(val) IS_VALID_RANGE(val, 0, UINT16_MAX)
+#define IS_VALID_U32_RANGE(val) IS_VALID_RANGE(val, 0, UINT32_MAX)
+#define MAX_BUFF_LEN 4096
 #define AP_MIN_VALID_CHAR 1
 #if !defined RSIZE_MAX_STR
 #define RSIZE_MAX_STR 4096
diff --git a/wpa_supplicant/ap.c b/wpa_supplicant/ap.c
index b6e666a7d..d5b9fb874 100644
--- a/wpa_supplicant/ap.c
+++ b/wpa_supplicant/ap.c
@@ -1525,7 +1525,7 @@ int ap_ctrl_iface_sta_first(struct wpa_supplicant *wpa_s,
 		hapd = wpa_s->ifmsh->bss[0];
 	else
 		return -1;
-	return hostapd_ctrl_iface_sta_first(hapd, buf, buflen);
+	return hostapd_ctrl_iface_sta_first(hapd, command, buf, buflen);
 }
 
 
-- 
2.43.0

