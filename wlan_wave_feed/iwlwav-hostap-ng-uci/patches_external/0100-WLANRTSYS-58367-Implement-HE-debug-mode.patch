From b708ba95c09a0f68e7f660b1d9c49810f0b11697 Mon Sep 17 00:00:00 2001
From: fromans <fromans@maxlinear.com>
Date: Tue, 10 Oct 2023 13:41:14 +0300
Subject: [PATCH] WLANRTSYS-58367: Implement HE debug mode

    Why debug mode:
    The HW HE capability override should not create any problem for
    our customer release product.
    Our release product always use the HW HE capability.
    The debug code call flow control with hostapd.conf parameter "enable_he_debug_mode",
    to avoid the conflict with release code.
    No need to introduce vendor cmd to override a new HW capability override.
    Maintained the open source method of HE framework in iwlwav-hostapd.
    PFA file(list of overrode HE capability),
    User can override every HE capability (MAC, PHY, MCS_NSS and PPE Threshold) field.

    How it will work:
    Enable "enable_he_debug_mode = 1" in hostapd.conf.
    Define the HE capability in the hostapd.conf to override for
    debug or testing (e.g. he_phy_ldpc_coding_in_payload =0/1)
    Before set BSS if debug mode enabled then override the HW HE
    capability with the config HE capability so that hostapd will
    use the override he capability for Beacon/probe_resp/assoc_resp and Add station.
    Send the override HE capability to driver for negotiated station
    he capability calculation for ADD_STA.
---
 hostapd/mxl_config.c             | 645 +++++++++++++++++++++++++++++
 src/ap/hostapd.c                 |  11 +
 src/ap/hostapd.h                 |   4 +
 src/ap/ieee802_11_he.c           |   1 +
 src/ap/mxl_config.h              | 130 ++++++
 src/ap/mxl_hostapd.c             | 671 +++++++++++++++++++++++++++++++
 src/ap/mxl_hostapd.h             |   1 +
 src/common/ieee802_11_defs.h     |   5 +-
 src/common/mxl_ieee802_11_defs.h | 142 +++++++
 src/common/vendor_cmds_copy.h    |  10 +
 src/drivers/driver.h             |   7 +
 11 files changed, 1625 insertions(+), 2 deletions(-)

diff --git a/hostapd/mxl_config.c b/hostapd/mxl_config.c
index 14ed9e433..a52a2452a 100644
--- a/hostapd/mxl_config.c
+++ b/hostapd/mxl_config.c
@@ -16,6 +16,640 @@
 #include "ap/ap_config.h"
 #include "utils/mxl_common.h"
 #include "ap/mxl_config.h"
+#include "ap/mxl_hostapd.h"
+#include "common/mxl_ieee802_11_defs.h"
+
+#ifdef CONFIG_IEEE80211AX
+static int
+mxl_conf_fill_he_mac_capab_info(struct mxl_hostapd_config *conf, const char *buf, char *pos)
+{
+	u8 *he_mac_capab_info = conf->he_capab_dbg.he_mac_capab_info;
+	struct he_override_hw_capab *cap_idx = &conf->override_hw_capab;
+
+	if (os_strcmp(buf, "he_mac_plus_htc_he_support") == 0) {
+		cap_idx->he_mac_plus_htc_he_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP0_HTC_HE_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_twt_requester_support") == 0) {
+		cap_idx->he_mac_twt_requester_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP0_TWT_REQUESTER_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_twt_responder_support") == 0) {
+		cap_idx->he_mac_twt_responder_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP0_TWT_RESPONDER_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_fragmentation") == 0) {
+		cap_idx->he_mac_fragmentation = 1;
+		he_mac_capab_info[HE_MACCAP_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP0_FRAGMENTATION_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_maximum_number_of_fragmented_msdus_amsdus") == 0) {
+		cap_idx->he_mac_maximum_number_of_fragmented_msdus_amsdus = 1;
+		he_mac_capab_info[HE_MACCAP_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP0_MAX_NUM_OF_FRAG_MSDU);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_minimum_fragment_size") == 0) {
+		cap_idx->he_mac_minimum_fragment_size = 1;
+		he_mac_capab_info[HE_MACCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP1_MINIMUM_FRAGMENT_SIZE);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_trigger_frame_mac_padding_duration") == 0) {
+		cap_idx->he_mac_trigger_frame_mac_padding_duration = 1;
+		he_mac_capab_info[HE_MACCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP1_TRIGGER_FRAME_MAC_PAD_DUR);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_multi_tid_aggregation_rx_support") == 0) {
+		cap_idx->he_mac_multi_tid_aggregation_rx_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP1_MULTI_TID_AGGR_RX_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_he_link_adaptation") == 0) {
+		cap_idx->he_mac_he_link_adaptation = 1;
+		he_mac_capab_info[HE_MACCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP1_HE_LINK_ADAPTION_SUPPORT);
+		he_mac_capab_info[HE_MACCAP_CAP2_IDX] |= set_he_cap((atoi(pos) >> 1),
+						HE_MAC_CAP2_HE_LINK_ADAPTION_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_all_ack_support") == 0) {
+		cap_idx->he_mac_all_ack_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP2_ALL_ACK_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_bsr_support") == 0) {
+		cap_idx->he_mac_bsr_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP2_BSR_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_broadcast_twt_support") == 0) {
+		cap_idx->he_mac_broadcast_twt_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP2_BROADCAST_TWT_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_32bit_ba_bitmap_support") == 0) {
+		cap_idx->he_mac_32bit_ba_bitmap_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP2_32BIT_BA_BITMAP_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_mu_cascading_support") == 0) {
+		cap_idx->he_mac_mu_cascading_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP2_MU_CASCADING_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_ack_enabled_aggregation_support") == 0) {
+		cap_idx->he_mac_ack_enabled_aggregation_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP2_ACK_ENABLED_AGGREGATION_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_group_addressed_multi_sta_blockack_in_dl_mu_support") == 0) {
+		cap_idx->he_mac_group_addressed_multi_sta_blockack_in_dl_mu_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP3_GROUP_ADD_MULTI_STA_BA_IN_DL_MU_SUP);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_om_control_support") == 0) {
+		cap_idx->he_mac_om_control_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP3_OM_CONTROL_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_ofdma_ra_support") == 0) {
+		cap_idx->he_mac_ofdma_ra_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP3_OFDMA_RA_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_maximum_a_mpdu_length_exponent") == 0) {
+		cap_idx->he_mac_maximum_a_mpdu_length_exponent = 1;
+		he_mac_capab_info[HE_MACCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_a_msdu_fragmentation_support") == 0) {
+		cap_idx->he_mac_a_msdu_fragmentation_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP3_AMSDU_FRGMENTATION_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_flexible_twt_schedule_support") == 0) {
+		cap_idx->he_mac_flexible_twt_schedule_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP3_FLEXIBLE_TWT_SCHEDULE_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_rx_control_frame_to_multibss") == 0) {
+		cap_idx->he_mac_rx_control_frame_to_multibss = 1;
+		he_mac_capab_info[HE_MACCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP3_RX_CONTROL_FRAME_TO_MULTIBSS);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_bsrp_bqrp_a_mpdu_aggregation") == 0) {
+		cap_idx->he_mac_bsrp_bqrp_a_mpdu_aggregation = 1;
+		he_mac_capab_info[HE_MACCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP4_BSRP_BQRP_AMPDU_AGGREGATION);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_qtp_support") == 0) {
+		cap_idx->he_mac_qtp_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP4_QTP_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_bqr_support") == 0) {
+		cap_idx->he_mac_bqr_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP4_BQR_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_ndp_feedback_report_support") == 0) {
+		cap_idx->he_mac_ndp_feedback_report_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP4_NDP_FEEDBACK_REPORT_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_a_msdu_in_ack_enabled_a_mpdu_support") == 0) {
+		cap_idx->he_mac_a_msdu_in_ack_enabled_a_mpdu_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP4_AMSDU_IN_AMPDU_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_multi_tid_aggregation_tx_support") == 0) {
+		cap_idx->he_mac_multi_tid_aggregation_tx_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP4_MULTI_TID_AGGR_TX_SUPPORT);
+		he_mac_capab_info[HE_MACCAP_CAP5_IDX] |= set_he_cap((atoi(pos) >> 1),
+						HE_MAC_CAP5_MULTI_TID_AGGR_TX_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_ul_2x996tone_ru_support") == 0) {
+		cap_idx->he_mac_ul_2x996tone_ru_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP5_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP5_UL_2X996TONE_RU_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_mac_om_control_ul_mu_data_disable_rx_support") == 0) {
+		cap_idx->he_mac_om_control_ul_mu_data_disable_rx_support = 1;
+		he_mac_capab_info[HE_MACCAP_CAP5_IDX] |= set_he_cap(atoi(pos),
+						HE_MAC_CAP5_OM_CONTROL_UL_MU_DATA_DIS_RX_SUP);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+mxl_conf_fill_he_phy_capab_info(struct mxl_hostapd_config *conf, const char *buf,
+				   char *pos)
+{
+	u8 *he_phy_capab_info = conf->he_capab_dbg.he_phy_capab_info;
+	struct he_override_hw_capab *cap_idx = &conf->override_hw_capab;
+
+	if (os_strcmp(buf, "he_phy_preamble_puncturing_rx") == 0) {
+		cap_idx->he_phy_preamble_puncturing_rx = 1;
+		cap_idx->he_cap_non_adv_punc_pream_rx_support_override = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP1_PUN_PREAM_RX);
+		conf->he_cap_non_adv_punc_pream_rx_support = atoi(pos) ? HE_PHY_CAP1_PUN_PREAM_RX : 0;
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_device_class") == 0) {
+		cap_idx->he_phy_device_class = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP1_DEVICE_CLASS);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_ldpc_coding_in_payload") == 0) {
+		cap_idx->he_phy_ldpc_coding_in_payload = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_su_ppdu_with_1x_he_ltf_and_08_us_gi") == 0) {
+		cap_idx->he_phy_su_ppdu_with_1x_he_ltf_and_08_us_gi = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP1_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP1_SU_PPDU_1XHE_LTF_0_8US_GI);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_ndp_with_4x_he_ltf_and_32_us_gi") == 0) {
+		cap_idx->he_phy_ndp_with_4x_he_ltf_and_32_us_gi = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP2_NDP_4X_HE_LTF_AND_3_2MS_GI);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_stbc_tx_less_than_or_equal_80mhz") == 0) {
+		cap_idx->he_phy_stbc_tx_less_than_or_equal_80mhz = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP2_STBC_TX_LESS_OR_EQUAL_80MHz);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_stbc_rx_less_than_or_equal_80mhz") == 0) {
+		cap_idx->he_phy_stbc_rx_less_than_or_equal_80mhz = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP2_STBC_RX_LESS_OR_EQUAL_80MHz);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_doppler_rx") == 0) {
+		cap_idx->he_phy_doppler_rx = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP2_DOPPLER_RX);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_doppler_tx") == 0) {
+		cap_idx->he_phy_doppler_tx = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP2_DOPPLER_TX);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_full_bandwidth_ul_mu_mimo") == 0) {
+		cap_idx->he_phy_full_bandwidth_ul_mu_mimo = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP2_FULL_BANDWIDTH_UL_MU_MIMO);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_partial_bandwidth_ul_mu_mimo") == 0) {
+		cap_idx->he_phy_partial_bandwidth_ul_mu_mimo = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP2_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP2_PARTIAL_BANDWIDTH_UL_MU_MIMO);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_dcm_max_constellation_tx") == 0) {
+		cap_idx->he_phy_dcm_max_constellation_tx = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP3_DCM_MAX_CONSTELLATION_TX);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_dcm_max_nss_tx") == 0) {
+		cap_idx->he_phy_dcm_max_nss_tx = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP3_DCM_MAX_NSS_TX);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_dcm_max_constellation_rx") == 0) {
+		cap_idx->he_phy_dcm_max_constellation_rx = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP3_DCM_MAX_CONSTELLATION_RX);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_dcm_max_nss_rx") == 0) {
+		cap_idx->he_phy_dcm_max_nss_rx = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP3_DCM_MAX_NSS_RX);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_su_beamformer_capable") == 0) {
+		cap_idx->he_phy_su_beamformer_capable = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP3_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP3_SU_BEAMFORMER);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_beamformee_sts_for_less_than_or_equal_80mhz") == 0) {
+		cap_idx->he_phy_beamformee_sts_for_less_than_or_equal_80mhz = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP4_BF_STS_LESS_OR_EQ_80MHz);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_su_beamformee_capable") == 0) {
+		cap_idx->he_phy_su_beamformee_capable = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP4_SU_BEAMFORMEE);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_mu_beamformer_capable") == 0) {
+		cap_idx->he_phy_mu_beamformer_capable = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP4_MU_BEAMFORMER);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_beamformee_sts_for_greater_than_80mhz") == 0) {
+		cap_idx->he_phy_beamformee_sts_for_greater_than_80mhz = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP4_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP4_BF_STS_GREATER_THAN_80MHz);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_number_of_sounding_dimensions_for_less_than_or_equal_80mhz") == 0) {
+		cap_idx->he_phy_number_of_sounding_dimensions_for_less_than_or_equal_80mhz = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP5_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP5_NUM_SOUND_DIM_LESS_80MHz);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_number_of_sounding_dimensions_for_greater_than_80mhz") == 0) {
+		cap_idx->he_phy_number_of_sounding_dimensions_for_greater_than_80mhz = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP5_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP5_NUM_SOUND_DIM_GREAT_80MHz);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_ng_16_su_feedback") == 0) {
+		cap_idx->he_phy_ng_16_su_feedback = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP5_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP5_NG_16_FOR_SU_FB_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_ng_16_mu_feedback") == 0) {
+		cap_idx->he_phy_ng_16_mu_feedback = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP5_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP5_NG_16_FOR_MU_FB_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_codebook_size42_for_su_support") == 0) {
+		cap_idx->he_phy_codebook_size42_for_su_support = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP6_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP6_CODEBOOK_SIZE42_FOR_SU_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_codebook_size75_for_mu_support") == 0) {
+		cap_idx->he_phy_codebook_size75_for_mu_support = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP6_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP6_CODEBOOK_SIZE75_FOR_MU_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_triggered_su_beamforming_feedback") == 0) {
+		cap_idx->he_phy_triggered_su_beamforming_feedback = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP6_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP6_TRIGGERED_SU_BEAMFORMING_FEEDBACK);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_triggered_mu_beamforming_partial_bw_feedback") == 0) {
+		cap_idx->he_phy_triggered_mu_beamforming_partial_bw_feedback = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP6_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP6_TRIGGERED_MU_BEAMFORMING_PARTIAL_BW_FEEDBACK);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_triggered_cqi_feedback") == 0) {
+		cap_idx->he_phy_triggered_cqi_feedback = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP6_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP6_TRIGGERED_CQI_FEEDBACK);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_partial_bandwidth_extended_range") == 0) {
+		cap_idx->he_phy_partial_bandwidth_extended_range = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP6_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP6_PARTIAL_BANDWIDTH_EXTENDED_RANGE);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_ppe_thresholds_present") == 0) {
+		cap_idx->he_phy_ppe_thresholds_present = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP6_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP6_PPE_THRESHOLD_PRESENT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_srp_based_sr_support") == 0) {
+		cap_idx->he_phy_srp_based_sr_support = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP7_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP7_SRP_BASED_SR_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_power_boost_factor_alpha_support") == 0) {
+		cap_idx->he_phy_power_boost_factor_alpha_support = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP7_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_su_ppdu_and_he_mu_with_4x_he_ltf_and_08us_gi") == 0) {
+		cap_idx->he_phy_su_ppdu_and_he_mu_with_4x_he_ltf_and_08us_gi = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP7_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP7_SU_PPDU_AND_HE_MU_WITH_4X_HE_LTF_0_8US_GI);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_max_nc") == 0) {
+		cap_idx->he_phy_max_nc = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP7_IDX] |= set_he_cap(atoi(pos), HE_PHY_CAP7_MAX_NC);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_stbc_tx_greater_than_80mhz") == 0) {
+		cap_idx->he_phy_stbc_tx_greater_than_80mhz = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP7_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP7_STBC_TX_GREATER_THAN_80MHz);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_er_su_ppdu_4x_ltf_8us_gi") == 0) {
+		cap_idx->he_phy_er_su_ppdu_4x_ltf_8us_gi = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP8_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP8_HE_ER_SU_PPDU_4X_HE_LTF_0_8_US_GI);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_dcm_max_bw") == 0) {
+		cap_idx->he_phy_dcm_max_bw = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP8_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP8_DCM_MAX_BW);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_longer_than_16_he_sigb_ofdm_sym_support") == 0) {
+		cap_idx->he_phy_longer_than_16_he_sigb_ofdm_sym_support = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP9_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP9_LONGER_THAN_16_HE_SIGB_OFDM_SYMBOLS_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_rx_1024_qam_lt_242_tone_ru_support") == 0) {
+		cap_idx->he_phy_rx_1024_qam_lt_242_tone_ru_support = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP9_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU_SUPPORT);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_rx_full_bw_su_using_mu_non_comp_sigb") == 0) {
+		cap_idx->he_phy_rx_full_bw_su_using_mu_non_comp_sigb = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP9_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_PPDU_NON_COMP_SIGB);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_rx_full_bw_su_using_mu_comp_sigb") == 0) {
+		cap_idx->he_phy_rx_full_bw_su_using_mu_comp_sigb = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP9_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_PPDU_COMP_SIGB);
+		return 1;
+	} else if (os_strcmp(buf, "he_phy_nominal_packet_padding") == 0) {
+		cap_idx->he_phy_nominal_packet_padding = 1;
+		he_phy_capab_info[HE_PHYCAP_CAP9_IDX] |= set_he_cap(atoi(pos),
+					HE_PHY_CAP9_NOMINAL_PACKET_PADDING);
+		return 1;
+	}
+	return 0;
+}
+
+static int
+mxl_conf_fill_he_txrx_mcs_support(struct mxl_hostapd_config *conf, const char *buf, char *pos)
+{
+	u8 *he_txrx_mcs_support = conf->he_capab_dbg.optional;
+	struct he_override_hw_capab *cap_idx = &conf->override_hw_capab;
+
+	if (os_strcmp(buf, "he_mcs_nss_rx_he_mcs_map_less_than_or_equal_80_mhz") == 0) {
+		cap_idx->he_mcs_nss_rx_he_mcs_map_less_than_or_equal_80_mhz = 1;
+		he_txrx_mcs_support[0] = atoi(pos) & 0xff;
+		he_txrx_mcs_support[1] = (atoi(pos) >> 8) & 0xff;
+		return 1;
+	} else if (os_strcmp(buf, "he_mcs_nss_tx_he_mcs_map_less_than_or_equal_80_mhz") == 0) {
+		cap_idx->he_mcs_nss_tx_he_mcs_map_less_than_or_equal_80_mhz = 1;
+		he_txrx_mcs_support[2] = atoi(pos) & 0xff;
+		he_txrx_mcs_support[3] = (atoi(pos) >> 8) & 0xff;
+		return 1;
+	} else if (os_strcmp(buf, "he_mcs_nss_rx_he_mcs_map_160_mhz") == 0) {
+		cap_idx->he_mcs_nss_rx_he_mcs_map_160_mhz = 1;
+		he_txrx_mcs_support[4] = atoi(pos) & 0xff;
+		he_txrx_mcs_support[5] = (atoi(pos) >> 8) & 0xff;
+		return 1;
+	} else if (os_strcmp(buf, "he_mcs_nss_tx_he_mcs_map_160_mhz") == 0) {
+		cap_idx->he_mcs_nss_tx_he_mcs_map_160_mhz = 1;
+		he_txrx_mcs_support[6] = atoi(pos) & 0xff;
+		he_txrx_mcs_support[7] = (atoi(pos) >> 8) & 0xff;
+		return 1;
+	} else if (os_strcmp(buf, "he_mcs_nss_rx_he_mcs_map_8080_mhz") == 0) {
+		cap_idx->he_mcs_nss_rx_he_mcs_map_8080_mhz = 1;
+		he_txrx_mcs_support[8] = atoi(pos) & 0xff;
+		he_txrx_mcs_support[9] = (atoi(pos) >> 8) & 0xff;
+		return 1;
+	} else if (os_strcmp(buf, "he_mcs_nss_tx_he_mcs_map_8080_mhz") == 0) {
+		cap_idx->he_mcs_nss_tx_he_mcs_map_8080_mhz = 1;
+		he_txrx_mcs_support[10] = atoi(pos) & 0xff;
+		he_txrx_mcs_support[11] = (atoi(pos) >> 8) & 0xff;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+mxl_conf_fill_he_ppe_thresholds(struct mxl_hostapd_config *conf, const char *buf, char *pos)
+{
+	u8 *he_ppe_thresholds = conf->he_capab_dbg.optional + HE_PPE_THRES_INDEX;
+	struct he_override_hw_capab *cap_idx = &conf->override_hw_capab;
+
+	if (os_strcmp(buf, "he_ppe_thresholds_nsts") == 0) {
+		cap_idx->he_ppe_thresholds_nsts = 1;
+		he_ppe_thresholds[HE_PPE_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP0_NSS_M1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ru_index_bitmask") == 0) {
+		cap_idx->he_ppe_thresholds_ru_index_bitmask = 1;
+		he_ppe_thresholds[HE_PPE_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP0_RU_INDEX_BITMASK);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts1_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP0_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP0_PPET16_FOR_NSS1_FOR_RU0);
+		he_ppe_thresholds[HE_PPE_CAP1_IDX] |= set_he_cap(atoi(pos) >> 1,
+						HE_PPE_CAP1_PPET16_FOR_NSS1_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts1_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP1_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP1_PPET16_FOR_NSS1_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts1_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP2_PPET16_FOR_NSS1_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts1_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP3_PPET16_FOR_NSS1_FOR_RU3);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts2_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP3_PPET16_FOR_NSS2_FOR_RU0);
+		he_ppe_thresholds[HE_PPE_CAP4_IDX] |= set_he_cap(atoi(pos) >> 1,
+						HE_PPE_CAP4_PPET16_FOR_NSS2_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts2_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP4_PPET16_FOR_NSS2_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts2_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP5_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP5_PPET16_FOR_NSS2_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts2_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP6_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP6_PPET16_FOR_NSS2_FOR_RU3);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts3_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP6_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP6_PPET16_FOR_NSS3_FOR_RU0);
+		he_ppe_thresholds[HE_PPE_CAP7_IDX] |= set_he_cap((atoi(pos) >> 1),
+						HE_PPE_CAP7_PPET16_FOR_NSS3_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts3_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP7_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP7_PPET16_FOR_NSS3_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts3_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP8_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP8_PPET16_FOR_NSS3_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts3_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP9_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP9_PPET16_FOR_NSS3_FOR_RU3);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts4_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP9_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP9_PPET16_FOR_NSS4_FOR_RU0);
+		he_ppe_thresholds[HE_PPE_CAP10_IDX] |= set_he_cap(atoi(pos) >> 1,
+						HE_PPE_CAP10_PPET16_FOR_NSS4_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts4_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP10_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP10_PPET16_FOR_NSS4_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts4_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP11_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP11_PPET16_FOR_NSS4_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet16_for_nsts4_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP12_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP12_PPET16_FOR_NSS4_FOR_RU3);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts1_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP1_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP1_PPET8_FOR_NSS1_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts1_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP2_PPET8_FOR_NSS1_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts1_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP2_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP2_PPET8_FOR_NSS1_FOR_RU2 );
+		he_ppe_thresholds[HE_PPE_CAP3_IDX] |= set_he_cap((atoi(pos) >> 2),
+						HE_PPE_CAP3_PPET8_FOR_NSS1_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts1_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP3_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP3_PPET8_FOR_NSS1_FOR_RU3);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts2_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP4_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP4_PPET8_FOR_NSS2_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts2_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP5_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP5_PPET8_FOR_NSS2_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts2_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP5_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP5_PPET8_FOR_NSS2_FOR_RU2);
+		he_ppe_thresholds[HE_PPE_CAP6_IDX] |= set_he_cap(atoi(pos) >> 2,
+						HE_PPE_CAP6_PPET8_FOR_NSS2_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts2_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP6_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP6_PPET8_FOR_NSS2_FOR_RU3);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts3_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP7_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP7_PPET8_FOR_NSS3_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts3_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP8_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP8_PPET8_FOR_NSS3_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts3_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP8_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP8_PPET8_FOR_NSS3_FOR_RU2);
+		he_ppe_thresholds[HE_PPE_CAP9_IDX] |= set_he_cap(atoi(pos) >> 2,
+						HE_PPE_CAP9_PPET8_FOR_NSS3_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts3_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP9_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP9_PPET8_FOR_NSS3_FOR_RU3);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts4_for_ru0") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru0 = 1;
+		he_ppe_thresholds[HE_PPE_CAP10_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP10_PPET8_FOR_NSS4_FOR_RU0);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts4_for_ru1") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru1 = 1;
+		he_ppe_thresholds[HE_PPE_CAP11_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP11_PPET8_FOR_NSS4_FOR_RU1);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts4_for_ru2") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru2 = 1;
+		he_ppe_thresholds[HE_PPE_CAP11_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP11_PPET8_FOR_NSS4_FOR_RU2);
+		he_ppe_thresholds[HE_PPE_CAP12_IDX] |= set_he_cap((atoi(pos) >> 2),
+						HE_PPE_CAP12_PPET8_FOR_NSS4_FOR_RU2);
+		return 1;
+	} else if (os_strcmp(buf, "he_ppe_thresholds_ppet8_for_nsts4_for_ru3") == 0) {
+		cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru3 = 1;
+		he_ppe_thresholds[HE_PPE_CAP12_IDX] |= set_he_cap(atoi(pos),
+						HE_PPE_CAP12_PPET8_FOR_NSS4_FOR_RU3);
+		return 1;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_IEEE80211AX */
 
 int mxl_hostapd_config_fill (struct hostapd_config *conf,
 					struct hostapd_bss_config *bss,
@@ -239,6 +873,17 @@ int mxl_hostapd_config_fill (struct hostapd_config *conf,
 	} else if (os_strcmp(buf, "rrm_noise_histogram") == 0) {
 		if (atoi(pos))
 			bss->radio_measurements[1] |= WLAN_RRM_CAPS_NOISE_HISTOGRAM;
+#ifdef CONFIG_IEEE80211AX
+	} else if (os_strcmp(buf, "enable_he_debug_mode") == 0) {
+		mxl_conf->enable_he_debug_mode = atoi(pos);
+	} else if (os_strcmp(buf, "he_cap_non_adv_multi_bss_rx_control_support") == 0) {
+		mxl_conf->override_hw_capab.he_cap_non_adv_multi_bss_rx_control_support_override = 1;
+		mxl_conf->he_cap_non_adv_multi_bss_rx_control_support = atoi(pos);
+	} else if (mxl_conf_fill_he_mac_capab_info(mxl_conf, buf, pos)) {
+	} else if (mxl_conf_fill_he_phy_capab_info(mxl_conf, buf, pos)) {
+	} else if (mxl_conf_fill_he_txrx_mcs_support(mxl_conf, buf, pos)) {
+	} else if (mxl_conf_fill_he_ppe_thresholds(mxl_conf, buf, pos)) {
+#endif /* CONFIG_IEEE80211AX */
 	} else
 		return 0;
 
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 5fd048e2a..8da170096 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -67,6 +67,9 @@
 #ifdef CONFIG_WDS_WPA
 #include "wds_wpa.h"
 #endif
+#ifdef CONFIG_VENDOR_MXL
+#include "mxl_hostapd.h"
+#endif /* CONFIG_VENDOR_MXL */
 
 
 static int hostapd_flush_old_stations(struct hostapd_data *hapd, u16 reason);
@@ -2378,6 +2381,11 @@ static int setup_interface(struct hostapd_iface *iface)
 	if (hostapd_pre_up_vendor_vap_cmd(hapd))
 		return -1;
 
+#ifdef CONFIG_VENDOR_MXL
+	if (mxl_hostapd_setup_interface(hapd))
+		return -1;
+#endif
+
 	if (hapd->iconf->country[0] && hapd->iconf->country[1]) {
 		char country[4], previous_country[4];
 
@@ -3378,6 +3386,9 @@ dfs_offload:
 		ieee802_11_set_beacons(iface);
 
 	hostapd_post_up_vendor_radio_cmd(iface);
+#ifdef CONFIG_VENDOR_MXL
+	mxl_hostapd_setup_interface_post(iface);
+#endif /* CONFIG_VENDOR_MXL */
 	return 0;
 
 fail:
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index f8faaa8e7..2a86d2d36 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -788,6 +788,10 @@ int hostapd_get_psd_val(struct hostapd_iface *iface, u8 *val);
 void hostapd_color_switch_trigger(struct hostapd_data *hapd, u8 new_color);
 void hostapd_handle_bss_color_collision(struct hostapd_data *hapd, u64 bitmap, u8 *bssid);
 int hostapd_cca_calc_switch_time(struct hostapd_iface *iface);
+int hostapd_conf_get_he_debug_parameters (struct hostapd_config *conf, const char *buf, char *pos);
+void hostapd_set_debug_mode_he_cap(struct hostapd_data *hapd);
+void hostapd_send_debug_mode_he_cap(struct hostapd_data *hapd);
+void hostapd_send_non_adv_he_cap(struct hostapd_data *hapd);
 #endif /* CONFIG_IEEE80211AX*/
 
 void hostapd_switch_color(struct hostapd_data *hapd, u64 bitmap);
diff --git a/src/ap/ieee802_11_he.c b/src/ap/ieee802_11_he.c
index f7f66e6ed..7638d7a2a 100644
--- a/src/ap/ieee802_11_he.c
+++ b/src/ap/ieee802_11_he.c
@@ -18,6 +18,7 @@
 #include "sta_info.h"
 #include "ieee802_11.h"
 #include "dfs.h"
+#include "ap_drv_ops.h"
 
 static u8 ieee80211_he_ppet_size(u8 ppe_thres_hdr, const u8 *phy_cap_info)
 {
diff --git a/src/ap/mxl_config.h b/src/ap/mxl_config.h
index dafb1eea5..db3dd2d9f 100644
--- a/src/ap/mxl_config.h
+++ b/src/ap/mxl_config.h
@@ -15,6 +15,125 @@
 #define MXL_CONFIG_H
 
 #include "mxl_softblock.h"
+#include "common/ieee802_11_defs.h"
+
+struct he_override_hw_capab {
+	u8  he_mac_fragmentation;
+	u8  he_mac_plus_htc_he_support;
+	u8  he_mac_twt_requester_support;
+	u8  he_mac_twt_responder_support;
+	u8  he_mac_all_ack_support;
+	u8  he_mac_bsr_support;
+	u8  he_mac_broadcast_twt_support;
+	u8  he_mac_32bit_ba_bitmap_support;
+	u8  he_mac_mu_cascading_support;
+	u8  he_mac_ack_enabled_aggregation_support;
+	u8  he_mac_group_addressed_multi_sta_blockack_in_dl_mu_support;
+	u8  he_mac_om_control_support;
+	u8  he_mac_ofdma_ra_support;
+	u8  he_mac_a_msdu_fragmentation_support;
+	u8  he_mac_flexible_twt_schedule_support;
+	u8  he_mac_rx_control_frame_to_multibss;
+	u8  he_mac_bsrp_bqrp_a_mpdu_aggregation;
+	u8  he_mac_qtp_support;
+	u8  he_mac_bqr_support;
+	u8  he_mac_a_msdu_in_ack_enabled_a_mpdu_support;
+	u8  he_mac_maximum_number_of_fragmented_msdus_amsdus;
+	u8  he_mac_minimum_fragment_size;
+	u8  he_mac_trigger_frame_mac_padding_duration;
+	u8  he_mac_multi_tid_aggregation_rx_support;
+	u8  he_mac_he_link_adaptation;
+	u8  he_mac_maximum_a_mpdu_length_exponent;
+	u8  he_mac_multi_tid_aggregation_tx_support;
+	u8  he_mac_ndp_feedback_report_support;
+	u8  he_mac_om_control_ul_mu_data_disable_rx_support;
+	u8  he_mac_ul_2x996tone_ru_support;
+	u8  he_phy_preamble_puncturing_rx;
+	u8  he_phy_device_class;
+	u8  he_phy_ldpc_coding_in_payload;
+	u8  he_phy_su_beamformer_capable;
+	u8  he_phy_su_beamformee_capable;
+	u8  he_phy_mu_beamformer_capable;
+	u8  he_phy_ng_16_su_feedback;
+	u8  he_phy_ng_16_mu_feedback;
+	u8  he_phy_codebook_size42_for_su_support;
+	u8  he_phy_codebook_size75_for_mu_support;
+	u8  he_phy_ppe_thresholds_present;
+	u8  he_phy_srp_based_sr_support;
+	u8  he_phy_power_boost_factor_alpha_support;
+	u8  he_phy_su_ppdu_and_he_mu_with_4x_he_ltf_and_08us_gi;
+	u8  he_phy_triggered_su_beamforming_feedback;
+	u8  he_phy_triggered_mu_beamforming_partial_bw_feedback;
+	u8  he_phy_triggered_cqi_feedback;
+	u8  he_phy_partial_bandwidth_extended_range;
+	u8  he_phy_su_ppdu_with_1x_he_ltf_and_08_us_gi;
+	u8  he_phy_ndp_with_4x_he_ltf_and_32_us_gi;
+	u8  he_phy_stbc_tx_less_than_or_equal_80mhz;
+	u8  he_phy_stbc_rx_less_than_or_equal_80mhz;
+	u8  he_phy_stbc_tx_greater_than_80mhz;
+	u8  he_phy_doppler_rx;
+	u8  he_phy_doppler_tx;
+	u8  he_phy_full_bandwidth_ul_mu_mimo;
+	u8  he_phy_partial_bandwidth_ul_mu_mimo;
+	u8  he_phy_dcm_max_constellation_tx;
+	u8  he_phy_dcm_max_constellation_rx;
+	u8  he_phy_dcm_max_nss_tx;
+	u8  he_phy_dcm_max_nss_rx;
+	u8  he_phy_dcm_max_bw;
+	u8  he_phy_er_su_ppdu_4x_ltf_8us_gi;
+	u8  he_phy_beamformee_sts_for_less_than_or_equal_80mhz;
+	u8  he_phy_beamformee_sts_for_greater_than_80mhz;
+	u8  he_phy_number_of_sounding_dimensions_for_less_than_or_equal_80mhz;
+	u8  he_phy_number_of_sounding_dimensions_for_greater_than_80mhz;
+	u8  he_phy_max_nc;
+	u8  he_phy_nominal_packet_padding;
+	u8  he_phy_longer_than_16_he_sigb_ofdm_sym_support;
+	u8  he_phy_rx_1024_qam_lt_242_tone_ru_support;
+	u8  he_phy_rx_full_bw_su_using_mu_non_comp_sigb;
+	u8  he_phy_rx_full_bw_su_using_mu_comp_sigb;
+	u8  he_mcs_nss_rx_he_mcs_map_less_than_or_equal_80_mhz;
+	u8  he_mcs_nss_tx_he_mcs_map_less_than_or_equal_80_mhz;
+	u8  he_mcs_nss_rx_he_mcs_map_160_mhz;
+	u8  he_mcs_nss_tx_he_mcs_map_160_mhz;
+	u8  he_mcs_nss_rx_he_mcs_map_8080_mhz;
+	u8  he_mcs_nss_tx_he_mcs_map_8080_mhz;
+	u8  he_ppe_thresholds_nsts;
+	u8  he_ppe_thresholds_ru_index_bitmask;
+	u8  he_ppe_thresholds_ppet16_for_nsts1_for_ru0;
+	u8  he_ppe_thresholds_ppet16_for_nsts1_for_ru1;
+	u8  he_ppe_thresholds_ppet16_for_nsts1_for_ru2;
+	u8  he_ppe_thresholds_ppet16_for_nsts1_for_ru3;
+	u8  he_ppe_thresholds_ppet16_for_nsts2_for_ru0;
+	u8  he_ppe_thresholds_ppet16_for_nsts2_for_ru1;
+	u8  he_ppe_thresholds_ppet16_for_nsts2_for_ru2;
+	u8  he_ppe_thresholds_ppet16_for_nsts2_for_ru3;
+	u8  he_ppe_thresholds_ppet16_for_nsts3_for_ru0;
+	u8  he_ppe_thresholds_ppet16_for_nsts3_for_ru1;
+	u8  he_ppe_thresholds_ppet16_for_nsts3_for_ru2;
+	u8  he_ppe_thresholds_ppet16_for_nsts3_for_ru3;
+	u8  he_ppe_thresholds_ppet16_for_nsts4_for_ru0;
+	u8  he_ppe_thresholds_ppet16_for_nsts4_for_ru1;
+	u8  he_ppe_thresholds_ppet16_for_nsts4_for_ru2;
+	u8  he_ppe_thresholds_ppet16_for_nsts4_for_ru3;
+	u8  he_ppe_thresholds_ppet8_for_nsts1_for_ru0;
+	u8  he_ppe_thresholds_ppet8_for_nsts1_for_ru1;
+	u8  he_ppe_thresholds_ppet8_for_nsts1_for_ru2;
+	u8  he_ppe_thresholds_ppet8_for_nsts1_for_ru3;
+	u8  he_ppe_thresholds_ppet8_for_nsts2_for_ru0;
+	u8  he_ppe_thresholds_ppet8_for_nsts2_for_ru1;
+	u8  he_ppe_thresholds_ppet8_for_nsts2_for_ru2;
+	u8  he_ppe_thresholds_ppet8_for_nsts2_for_ru3;
+	u8  he_ppe_thresholds_ppet8_for_nsts3_for_ru0;
+	u8  he_ppe_thresholds_ppet8_for_nsts3_for_ru1;
+	u8  he_ppe_thresholds_ppet8_for_nsts3_for_ru2;
+	u8  he_ppe_thresholds_ppet8_for_nsts3_for_ru3;
+	u8  he_ppe_thresholds_ppet8_for_nsts4_for_ru0;
+	u8  he_ppe_thresholds_ppet8_for_nsts4_for_ru1;
+	u8  he_ppe_thresholds_ppet8_for_nsts4_for_ru2;
+	u8  he_ppe_thresholds_ppet8_for_nsts4_for_ru3;
+	u8  he_cap_non_adv_multi_bss_rx_control_support_override;
+	u8  he_cap_non_adv_punc_pream_rx_support_override;
+};
 
 typedef u8 macaddr[ETH_ALEN];
 
@@ -39,6 +158,17 @@ struct mxl_hostapd_config {
 
 	int vht_capab_set;
 	u32 event_cache_interval;
+#ifdef CONFIG_IEEE80211AX
+	/* Override non-advertised HE caps */
+	u8 he_cap_non_adv_multi_bss_rx_control_support;
+	u8 he_cap_non_adv_punc_pream_rx_support;
+	/* Override driver reported HE Capabilities
+	 * by ones defined in hostapd configuration file.
+	 */
+	u8 enable_he_debug_mode;
+	struct he_override_hw_capab override_hw_capab;
+	struct ieee80211_he_capabilities he_capab_dbg;
+#endif /* CONFIG_IEEE80211AX */
 };
 
 /**
diff --git a/src/ap/mxl_hostapd.c b/src/ap/mxl_hostapd.c
index b3bf77f96..558c79140 100644
--- a/src/ap/mxl_hostapd.c
+++ b/src/ap/mxl_hostapd.c
@@ -22,6 +22,8 @@
 #include "mxl_hostapd.h"
 #include "common/vendor_cmds_copy.h"
 #include "ieee802_11.h"
+#include "mxl_config.h"
+#include "common/mxl_ieee802_11_defs.h"
 
 
 #define COC_POWER_1x1_STATE 1
@@ -165,6 +167,658 @@ void mxl_hostapd_free_aid(struct hostapd_data *hapd, struct sta_info *sta)
 	sta->aid = 0;
 }
 
+#ifdef CONFIG_IEEE80211AX
+static void mxl_clr_set_he_cap(u8 *field, int val, u8 mask)
+{
+	*field &= ~mask;
+	*field |= (u8) (mask & val);
+}
+
+static void
+mxl_hostapd_set_debug_he_mac_capab_info(u8 *debug_he_mac, u8 *conf_he_mac,
+			struct he_override_hw_capab *cap_idx)
+{
+	if (cap_idx->he_mac_fragmentation)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP0_IDX],
+			conf_he_mac[HE_MACCAP_CAP0_IDX], HE_MAC_CAP0_FRAGMENTATION_SUPPORT);
+
+	if (cap_idx->he_mac_plus_htc_he_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP0_IDX],
+			conf_he_mac[HE_MACCAP_CAP0_IDX], HE_MAC_CAP0_HTC_HE_SUPPORT);
+
+	if (cap_idx->he_mac_twt_requester_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP0_IDX],
+			conf_he_mac[HE_MACCAP_CAP0_IDX], HE_MAC_CAP0_TWT_REQUESTER_SUPPORT);
+
+	if (cap_idx->he_mac_twt_responder_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP0_IDX],
+			conf_he_mac[HE_MACCAP_CAP0_IDX], HE_MAC_CAP0_TWT_RESPONDER_SUPPORT);
+
+	if (cap_idx->he_mac_all_ack_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP2_IDX],
+			conf_he_mac[HE_MACCAP_CAP2_IDX], HE_MAC_CAP2_ALL_ACK_SUPPORT);
+
+	if (cap_idx->he_mac_bsr_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP2_IDX],
+			conf_he_mac[HE_MACCAP_CAP2_IDX], HE_MAC_CAP2_BSR_SUPPORT);
+
+	if (cap_idx->he_mac_broadcast_twt_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP2_IDX],
+			conf_he_mac[HE_MACCAP_CAP2_IDX], HE_MAC_CAP2_BROADCAST_TWT_SUPPORT);
+
+	if (cap_idx->he_mac_32bit_ba_bitmap_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP2_IDX],
+			conf_he_mac[HE_MACCAP_CAP2_IDX], HE_MAC_CAP2_32BIT_BA_BITMAP_SUPPORT);
+
+	if (cap_idx->he_mac_mu_cascading_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP2_IDX],
+			conf_he_mac[HE_MACCAP_CAP2_IDX], HE_MAC_CAP2_MU_CASCADING_SUPPORT);
+
+	if (cap_idx->he_mac_ack_enabled_aggregation_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP2_IDX],
+			conf_he_mac[HE_MACCAP_CAP2_IDX], HE_MAC_CAP2_ACK_ENABLED_AGGREGATION_SUPPORT);
+
+	if (cap_idx->he_mac_group_addressed_multi_sta_blockack_in_dl_mu_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP3_IDX],
+			conf_he_mac[HE_MACCAP_CAP3_IDX], HE_MAC_CAP3_GROUP_ADD_MULTI_STA_BA_IN_DL_MU_SUP);
+
+	if (cap_idx->he_mac_om_control_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP3_IDX],
+			conf_he_mac[HE_MACCAP_CAP3_IDX], HE_MAC_CAP3_OM_CONTROL_SUPPORT);
+
+	if (cap_idx->he_mac_ofdma_ra_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP3_IDX],
+			conf_he_mac[HE_MACCAP_CAP3_IDX], HE_MAC_CAP3_OFDMA_RA_SUPPORT);
+
+	if (cap_idx->he_mac_a_msdu_fragmentation_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP3_IDX],
+			conf_he_mac[HE_MACCAP_CAP3_IDX], HE_MAC_CAP3_AMSDU_FRGMENTATION_SUPPORT);
+
+	if (cap_idx->he_mac_flexible_twt_schedule_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP3_IDX],
+			conf_he_mac[HE_MACCAP_CAP3_IDX], HE_MAC_CAP3_FLEXIBLE_TWT_SCHEDULE_SUPPORT);
+
+	if (cap_idx->he_mac_rx_control_frame_to_multibss)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP3_IDX],
+			conf_he_mac[HE_MACCAP_CAP3_IDX], HE_MAC_CAP3_RX_CONTROL_FRAME_TO_MULTIBSS);
+
+	if (cap_idx->he_mac_bsrp_bqrp_a_mpdu_aggregation)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP4_IDX],
+			conf_he_mac[HE_MACCAP_CAP4_IDX], HE_MAC_CAP4_BSRP_BQRP_AMPDU_AGGREGATION);
+
+	if (cap_idx->he_mac_qtp_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP4_IDX],
+			conf_he_mac[HE_MACCAP_CAP4_IDX], HE_MAC_CAP4_QTP_SUPPORT);
+
+	if (cap_idx->he_mac_bqr_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP4_IDX],
+			conf_he_mac[HE_MACCAP_CAP4_IDX], HE_MAC_CAP4_BQR_SUPPORT);
+
+	if (cap_idx->he_mac_a_msdu_in_ack_enabled_a_mpdu_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP4_IDX],
+			conf_he_mac[HE_MACCAP_CAP4_IDX], HE_MAC_CAP4_AMSDU_IN_AMPDU_SUPPORT);
+
+	if (cap_idx->he_mac_maximum_number_of_fragmented_msdus_amsdus)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP0_IDX],
+			conf_he_mac[HE_MACCAP_CAP0_IDX], HE_MAC_CAP0_MAX_NUM_OF_FRAG_MSDU);
+
+	if (cap_idx->he_mac_minimum_fragment_size)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP1_IDX],
+			conf_he_mac[HE_MACCAP_CAP1_IDX], HE_MAC_CAP1_MINIMUM_FRAGMENT_SIZE);
+
+	if (cap_idx->he_mac_trigger_frame_mac_padding_duration)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP1_IDX],
+			conf_he_mac[HE_MACCAP_CAP1_IDX], HE_MAC_CAP1_TRIGGER_FRAME_MAC_PAD_DUR);
+
+	if (cap_idx->he_mac_multi_tid_aggregation_rx_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP1_IDX],
+			conf_he_mac[HE_MACCAP_CAP1_IDX], HE_MAC_CAP1_MULTI_TID_AGGR_RX_SUPPORT);
+
+	if (cap_idx->he_mac_he_link_adaptation) {
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP1_IDX],
+			conf_he_mac[HE_MACCAP_CAP1_IDX], HE_MAC_CAP1_HE_LINK_ADAPTION_SUPPORT);
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP2_IDX],
+			conf_he_mac[HE_MACCAP_CAP2_IDX], HE_MAC_CAP2_HE_LINK_ADAPTION_SUPPORT);
+	}
+
+	if (cap_idx->he_mac_maximum_a_mpdu_length_exponent)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP3_IDX],
+			conf_he_mac[HE_MACCAP_CAP3_IDX], HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT);
+
+	if (cap_idx->he_mac_multi_tid_aggregation_tx_support) {
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP4_IDX],
+			conf_he_mac[HE_MACCAP_CAP4_IDX], HE_MAC_CAP4_MULTI_TID_AGGR_TX_SUPPORT);
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP5_IDX],
+			conf_he_mac[HE_MACCAP_CAP5_IDX], HE_MAC_CAP5_MULTI_TID_AGGR_TX_SUPPORT);
+	}
+
+	if (cap_idx->he_mac_ndp_feedback_report_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP4_IDX],
+			conf_he_mac[HE_MACCAP_CAP4_IDX], HE_MAC_CAP4_NDP_FEEDBACK_REPORT_SUPPORT);
+
+	if (cap_idx->he_mac_om_control_ul_mu_data_disable_rx_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP5_IDX],
+			conf_he_mac[HE_MACCAP_CAP5_IDX], HE_MAC_CAP5_OM_CONTROL_UL_MU_DATA_DIS_RX_SUP);
+
+	if (cap_idx->he_mac_ul_2x996tone_ru_support)
+		mxl_clr_set_he_cap(&debug_he_mac[HE_MACCAP_CAP5_IDX],
+			conf_he_mac[HE_MACCAP_CAP5_IDX], HE_MAC_CAP5_UL_2X996TONE_RU_SUPPORT);
+
+}
+
+static void
+mxl_hostapd_set_debug_he_phy_capab_info(u8 *debug_he_phy, u8 *conf_he_phy,
+			struct he_override_hw_capab *cap_idx)
+{
+	if (cap_idx->he_phy_preamble_puncturing_rx)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP1_IDX],
+			conf_he_phy[HE_PHYCAP_CAP1_IDX], HE_PHY_CAP1_PUN_PREAM_RX);
+
+	if (cap_idx->he_phy_device_class)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP1_IDX],
+			conf_he_phy[HE_PHYCAP_CAP1_IDX], HE_PHY_CAP1_DEVICE_CLASS);
+
+	if (cap_idx->he_phy_ldpc_coding_in_payload)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP1_IDX],
+			conf_he_phy[HE_PHYCAP_CAP1_IDX], HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD);
+
+	if (cap_idx->he_phy_su_beamformer_capable)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP3_IDX],
+			conf_he_phy[HE_PHYCAP_CAP3_IDX], HE_PHY_CAP3_SU_BEAMFORMER);
+
+	if (cap_idx->he_phy_su_beamformee_capable)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP4_IDX],
+			conf_he_phy[HE_PHYCAP_CAP4_IDX], HE_PHY_CAP4_SU_BEAMFORMEE);
+
+	if (cap_idx->he_phy_mu_beamformer_capable)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP4_IDX],
+			conf_he_phy[HE_PHYCAP_CAP4_IDX], HE_PHY_CAP4_MU_BEAMFORMER);
+
+	if (cap_idx->he_phy_ng_16_su_feedback)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP5_IDX],
+			conf_he_phy[HE_PHYCAP_CAP5_IDX], HE_PHY_CAP5_NG_16_FOR_SU_FB_SUPPORT);
+
+	if (cap_idx->he_phy_ng_16_mu_feedback)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP5_IDX],
+			conf_he_phy[HE_PHYCAP_CAP5_IDX], HE_PHY_CAP5_NG_16_FOR_MU_FB_SUPPORT);
+
+	if (cap_idx->he_phy_codebook_size42_for_su_support)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP6_IDX],
+			conf_he_phy[HE_PHYCAP_CAP6_IDX], HE_PHY_CAP6_CODEBOOK_SIZE42_FOR_SU_SUPPORT);
+
+	if (cap_idx->he_phy_codebook_size75_for_mu_support)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP6_IDX],
+			conf_he_phy[HE_PHYCAP_CAP6_IDX], HE_PHY_CAP6_CODEBOOK_SIZE75_FOR_MU_SUPPORT);
+
+	if (cap_idx->he_phy_ppe_thresholds_present)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP6_IDX],
+			conf_he_phy[HE_PHYCAP_CAP6_IDX], HE_PHY_CAP6_PPE_THRESHOLD_PRESENT);
+
+	if (cap_idx->he_phy_srp_based_sr_support)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP7_IDX],
+			conf_he_phy[HE_PHYCAP_CAP7_IDX], HE_PHY_CAP7_SRP_BASED_SR_SUPPORT);
+
+	if (cap_idx->he_phy_power_boost_factor_alpha_support)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP7_IDX],
+			conf_he_phy[HE_PHYCAP_CAP7_IDX], HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPPORT);
+
+	if (cap_idx->he_phy_su_ppdu_and_he_mu_with_4x_he_ltf_and_08us_gi) {
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP7_IDX],
+			conf_he_phy[HE_PHYCAP_CAP7_IDX],
+			HE_PHY_CAP7_SU_PPDU_AND_HE_MU_WITH_4X_HE_LTF_0_8US_GI);
+	}
+
+	if (cap_idx->he_phy_stbc_tx_greater_than_80mhz)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP7_IDX],
+			conf_he_phy[HE_PHYCAP_CAP7_IDX], HE_PHY_CAP7_STBC_TX_GREATER_THAN_80MHz);
+
+	if (cap_idx->he_phy_triggered_su_beamforming_feedback) {
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP6_IDX],
+			conf_he_phy[HE_PHYCAP_CAP6_IDX],
+			HE_PHY_CAP6_TRIGGERED_SU_BEAMFORMING_FEEDBACK);
+	}
+
+	if (cap_idx->he_phy_triggered_mu_beamforming_partial_bw_feedback) {
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP6_IDX],
+			conf_he_phy[HE_PHYCAP_CAP6_IDX],
+			HE_PHY_CAP6_TRIGGERED_MU_BEAMFORMING_PARTIAL_BW_FEEDBACK);
+	}
+
+	if (cap_idx->he_phy_triggered_cqi_feedback)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP6_IDX],
+			conf_he_phy[HE_PHYCAP_CAP6_IDX], HE_PHY_CAP6_TRIGGERED_CQI_FEEDBACK);
+
+	if (cap_idx->he_phy_partial_bandwidth_extended_range)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP6_IDX],
+			conf_he_phy[HE_PHYCAP_CAP6_IDX], HE_PHY_CAP6_PARTIAL_BANDWIDTH_EXTENDED_RANGE);
+
+	if (cap_idx->he_phy_su_ppdu_with_1x_he_ltf_and_08_us_gi)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP1_IDX],
+			conf_he_phy[HE_PHYCAP_CAP1_IDX], HE_PHY_CAP1_SU_PPDU_1XHE_LTF_0_8US_GI);
+
+	if (cap_idx->he_phy_ndp_with_4x_he_ltf_and_32_us_gi)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP2_IDX],
+			conf_he_phy[HE_PHYCAP_CAP2_IDX], HE_PHY_CAP2_NDP_4X_HE_LTF_AND_3_2MS_GI);
+
+	if (cap_idx->he_phy_stbc_tx_less_than_or_equal_80mhz)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP2_IDX],
+			conf_he_phy[HE_PHYCAP_CAP2_IDX], HE_PHY_CAP2_STBC_TX_LESS_OR_EQUAL_80MHz);
+
+	if (cap_idx->he_phy_stbc_rx_less_than_or_equal_80mhz)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP2_IDX],
+			conf_he_phy[HE_PHYCAP_CAP2_IDX], HE_PHY_CAP2_STBC_RX_LESS_OR_EQUAL_80MHz);
+
+	if (cap_idx->he_phy_doppler_rx)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP2_IDX],
+			conf_he_phy[HE_PHYCAP_CAP2_IDX], HE_PHY_CAP2_DOPPLER_RX);
+
+	if (cap_idx->he_phy_doppler_tx)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP2_IDX],
+			conf_he_phy[HE_PHYCAP_CAP2_IDX], HE_PHY_CAP2_DOPPLER_TX);
+
+	if (cap_idx->he_phy_full_bandwidth_ul_mu_mimo)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP2_IDX],
+			conf_he_phy[HE_PHYCAP_CAP2_IDX], HE_PHY_CAP2_FULL_BANDWIDTH_UL_MU_MIMO);
+
+	if (cap_idx->he_phy_partial_bandwidth_ul_mu_mimo)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP2_IDX],
+			conf_he_phy[HE_PHYCAP_CAP2_IDX], HE_PHY_CAP2_PARTIAL_BANDWIDTH_UL_MU_MIMO);
+
+	if (cap_idx->he_phy_dcm_max_constellation_tx)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP3_IDX],
+			conf_he_phy[HE_PHYCAP_CAP3_IDX], HE_PHY_CAP3_DCM_MAX_CONSTELLATION_TX);
+
+	if (cap_idx->he_phy_dcm_max_constellation_rx)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP3_IDX],
+			conf_he_phy[HE_PHYCAP_CAP3_IDX], HE_PHY_CAP3_DCM_MAX_CONSTELLATION_RX);
+
+	if (cap_idx->he_phy_dcm_max_nss_tx)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP3_IDX],
+			conf_he_phy[HE_PHYCAP_CAP3_IDX], HE_PHY_CAP3_DCM_MAX_NSS_TX);
+
+	if (cap_idx->he_phy_dcm_max_nss_rx)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP3_IDX],
+			conf_he_phy[HE_PHYCAP_CAP3_IDX], HE_PHY_CAP3_DCM_MAX_NSS_RX);
+
+	if (cap_idx->he_phy_beamformee_sts_for_less_than_or_equal_80mhz)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP4_IDX],
+			conf_he_phy[HE_PHYCAP_CAP4_IDX], HE_PHY_CAP4_BF_STS_LESS_OR_EQ_80MHz);
+
+	if (cap_idx->he_phy_beamformee_sts_for_greater_than_80mhz)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP4_IDX],
+			conf_he_phy[HE_PHYCAP_CAP4_IDX], HE_PHY_CAP4_BF_STS_GREATER_THAN_80MHz);
+
+	if (cap_idx->he_phy_number_of_sounding_dimensions_for_less_than_or_equal_80mhz)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP5_IDX],
+			conf_he_phy[HE_PHYCAP_CAP5_IDX], HE_PHY_CAP5_NUM_SOUND_DIM_LESS_80MHz);
+
+	if (cap_idx->he_phy_number_of_sounding_dimensions_for_greater_than_80mhz)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP5_IDX],
+			conf_he_phy[HE_PHYCAP_CAP5_IDX], HE_PHY_CAP5_NUM_SOUND_DIM_GREAT_80MHz);
+
+	if (cap_idx->he_phy_max_nc)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP7_IDX],
+			conf_he_phy[HE_PHYCAP_CAP7_IDX], HE_PHY_CAP7_MAX_NC);
+
+	if (cap_idx->he_phy_dcm_max_bw)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP8_IDX],
+			conf_he_phy[HE_PHYCAP_CAP8_IDX], HE_PHY_CAP8_DCM_MAX_BW);
+
+	if (cap_idx->he_phy_er_su_ppdu_4x_ltf_8us_gi)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP8_IDX],
+			conf_he_phy[HE_PHYCAP_CAP8_IDX], HE_PHY_CAP8_HE_ER_SU_PPDU_4X_HE_LTF_0_8_US_GI);
+
+	if (cap_idx->he_phy_nominal_packet_padding)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP9_IDX],
+			conf_he_phy[HE_PHYCAP_CAP9_IDX], HE_PHY_CAP9_NOMINAL_PACKET_PADDING);
+
+	if (cap_idx->he_phy_longer_than_16_he_sigb_ofdm_sym_support)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP9_IDX],
+			conf_he_phy[HE_PHYCAP_CAP9_IDX], HE_PHY_CAP9_LONGER_THAN_16_HE_SIGB_OFDM_SYMBOLS_SUPPORT);
+
+	if (cap_idx->he_phy_rx_1024_qam_lt_242_tone_ru_support)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP9_IDX],
+			conf_he_phy[HE_PHYCAP_CAP9_IDX], HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU_SUPPORT);
+
+	if (cap_idx->he_phy_rx_full_bw_su_using_mu_non_comp_sigb)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP9_IDX],
+			conf_he_phy[HE_PHYCAP_CAP9_IDX], HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_PPDU_NON_COMP_SIGB);
+
+	if (cap_idx->he_phy_rx_full_bw_su_using_mu_comp_sigb)
+		mxl_clr_set_he_cap(&debug_he_phy[HE_PHYCAP_CAP9_IDX],
+			conf_he_phy[HE_PHYCAP_CAP9_IDX], HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_PPDU_COMP_SIGB);
+}
+
+static void
+mxl_hostapd_set_debug_he_txrx_mcs_support(u8 *debug_he_txrx_mcs, u8 *conf_he_txrx_mcs,
+				      struct he_override_hw_capab *cap_idx)
+{
+	if (cap_idx->he_mcs_nss_rx_he_mcs_map_less_than_or_equal_80_mhz) {
+		debug_he_txrx_mcs[0] = conf_he_txrx_mcs[0];
+		debug_he_txrx_mcs[1] = conf_he_txrx_mcs[1];
+	}
+
+	if (cap_idx->he_mcs_nss_tx_he_mcs_map_less_than_or_equal_80_mhz) {
+		debug_he_txrx_mcs[2] = conf_he_txrx_mcs[2];
+		debug_he_txrx_mcs[3] = conf_he_txrx_mcs[3];
+	}
+
+	if (cap_idx->he_mcs_nss_rx_he_mcs_map_160_mhz) {
+		debug_he_txrx_mcs[4] = conf_he_txrx_mcs[4];
+		debug_he_txrx_mcs[5] = conf_he_txrx_mcs[5];
+	}
+
+	if (cap_idx->he_mcs_nss_tx_he_mcs_map_160_mhz) {
+		debug_he_txrx_mcs[6] = conf_he_txrx_mcs[6];
+		debug_he_txrx_mcs[7] = conf_he_txrx_mcs[7];
+	}
+
+	if (cap_idx->he_mcs_nss_rx_he_mcs_map_8080_mhz) {
+		debug_he_txrx_mcs[8] = conf_he_txrx_mcs[8];
+		debug_he_txrx_mcs[9] = conf_he_txrx_mcs[9];
+	}
+
+	if (cap_idx->he_mcs_nss_tx_he_mcs_map_8080_mhz) {
+		debug_he_txrx_mcs[10] = conf_he_txrx_mcs[10];
+		debug_he_txrx_mcs[11] = conf_he_txrx_mcs[11];
+	}
+}
+static void
+mxl_hostapd_set_debug_he_ppe_thresholds(u8 *debug_he_ppet, u8 *conf_he_ppet,
+				    struct he_override_hw_capab *cap_idx)
+{
+	if (cap_idx->he_ppe_thresholds_nsts)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP0_IDX],
+			conf_he_ppet[HE_PPE_CAP0_IDX], HE_PPE_CAP0_NSS_M1);
+
+	if (cap_idx->he_ppe_thresholds_ru_index_bitmask)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP0_IDX],
+			conf_he_ppet[HE_PPE_CAP0_IDX], HE_PPE_CAP0_RU_INDEX_BITMASK);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru0) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP0_IDX],
+			conf_he_ppet[HE_PPE_CAP0_IDX], HE_PPE_CAP0_PPET16_FOR_NSS1_FOR_RU0);
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP1_IDX],
+			conf_he_ppet[HE_PPE_CAP1_IDX], HE_PPE_CAP1_PPET16_FOR_NSS1_FOR_RU0);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP1_IDX],
+			conf_he_ppet[HE_PPE_CAP1_IDX], HE_PPE_CAP1_PPET16_FOR_NSS1_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru2)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP2_IDX],
+			conf_he_ppet[HE_PPE_CAP2_IDX], HE_PPE_CAP2_PPET16_FOR_NSS1_FOR_RU2);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts1_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP3_IDX],
+			conf_he_ppet[HE_PPE_CAP3_IDX], HE_PPE_CAP3_PPET16_FOR_NSS1_FOR_RU3);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru0) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP3_IDX],
+			conf_he_ppet[HE_PPE_CAP3_IDX], HE_PPE_CAP3_PPET16_FOR_NSS2_FOR_RU0);
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP4_IDX],
+			conf_he_ppet[HE_PPE_CAP4_IDX], HE_PPE_CAP4_PPET16_FOR_NSS2_FOR_RU0);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP4_IDX],
+			conf_he_ppet[HE_PPE_CAP4_IDX], HE_PPE_CAP4_PPET16_FOR_NSS2_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru2)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP5_IDX],
+			conf_he_ppet[HE_PPE_CAP5_IDX], HE_PPE_CAP5_PPET16_FOR_NSS2_FOR_RU2);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts2_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP6_IDX],
+			conf_he_ppet[HE_PPE_CAP6_IDX], HE_PPE_CAP6_PPET16_FOR_NSS2_FOR_RU3);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru0) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP6_IDX],
+			conf_he_ppet[HE_PPE_CAP6_IDX], HE_PPE_CAP6_PPET16_FOR_NSS3_FOR_RU0);
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP7_IDX],
+			conf_he_ppet[HE_PPE_CAP7_IDX], HE_PPE_CAP7_PPET16_FOR_NSS3_FOR_RU0);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP7_IDX],
+			conf_he_ppet[HE_PPE_CAP7_IDX], HE_PPE_CAP7_PPET16_FOR_NSS3_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru2)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP8_IDX],
+			conf_he_ppet[HE_PPE_CAP8_IDX], HE_PPE_CAP8_PPET16_FOR_NSS3_FOR_RU2);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts3_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP9_IDX],
+			conf_he_ppet[HE_PPE_CAP9_IDX], HE_PPE_CAP9_PPET16_FOR_NSS3_FOR_RU3);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru0) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP9_IDX],
+			conf_he_ppet[HE_PPE_CAP9_IDX], HE_PPE_CAP9_PPET16_FOR_NSS4_FOR_RU0);
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP10_IDX],
+			conf_he_ppet[HE_PPE_CAP10_IDX], HE_PPE_CAP10_PPET16_FOR_NSS4_FOR_RU0);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP10_IDX],
+			conf_he_ppet[HE_PPE_CAP10_IDX], HE_PPE_CAP10_PPET16_FOR_NSS4_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru2)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP11_IDX],
+			conf_he_ppet[HE_PPE_CAP11_IDX], HE_PPE_CAP11_PPET16_FOR_NSS4_FOR_RU2);
+
+	if (cap_idx->he_ppe_thresholds_ppet16_for_nsts4_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP12_IDX],
+			conf_he_ppet[HE_PPE_CAP12_IDX], HE_PPE_CAP12_PPET16_FOR_NSS4_FOR_RU3);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru0)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP1_IDX],
+			conf_he_ppet[HE_PPE_CAP1_IDX], HE_PPE_CAP1_PPET8_FOR_NSS1_FOR_RU0);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP2_IDX],
+			conf_he_ppet[HE_PPE_CAP2_IDX], HE_PPE_CAP2_PPET8_FOR_NSS1_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru2) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP2_IDX],
+			conf_he_ppet[HE_PPE_CAP2_IDX], HE_PPE_CAP2_PPET8_FOR_NSS1_FOR_RU2 );
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP3_IDX],
+			conf_he_ppet[HE_PPE_CAP3_IDX], HE_PPE_CAP3_PPET8_FOR_NSS1_FOR_RU2);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts1_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP3_IDX],
+			conf_he_ppet[HE_PPE_CAP3_IDX], HE_PPE_CAP3_PPET8_FOR_NSS1_FOR_RU3);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru0)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP4_IDX],
+			conf_he_ppet[HE_PPE_CAP4_IDX], HE_PPE_CAP4_PPET8_FOR_NSS2_FOR_RU0);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP5_IDX],
+			conf_he_ppet[HE_PPE_CAP5_IDX], HE_PPE_CAP5_PPET8_FOR_NSS2_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru2) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP5_IDX],
+			conf_he_ppet[HE_PPE_CAP5_IDX], HE_PPE_CAP5_PPET8_FOR_NSS2_FOR_RU2);
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP6_IDX],
+			conf_he_ppet[HE_PPE_CAP6_IDX], HE_PPE_CAP6_PPET8_FOR_NSS2_FOR_RU2);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts2_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP6_IDX],
+			conf_he_ppet[HE_PPE_CAP6_IDX], HE_PPE_CAP6_PPET8_FOR_NSS2_FOR_RU3);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru0)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP7_IDX],
+			conf_he_ppet[HE_PPE_CAP7_IDX], HE_PPE_CAP7_PPET8_FOR_NSS3_FOR_RU0);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP8_IDX],
+			conf_he_ppet[HE_PPE_CAP8_IDX], HE_PPE_CAP8_PPET8_FOR_NSS3_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru2) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP8_IDX],
+			conf_he_ppet[HE_PPE_CAP8_IDX], HE_PPE_CAP8_PPET8_FOR_NSS3_FOR_RU2);
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP9_IDX],
+			conf_he_ppet[HE_PPE_CAP9_IDX], HE_PPE_CAP9_PPET8_FOR_NSS3_FOR_RU2);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts3_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP9_IDX],
+			conf_he_ppet[HE_PPE_CAP9_IDX], HE_PPE_CAP9_PPET8_FOR_NSS3_FOR_RU3);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru0)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP10_IDX],
+			conf_he_ppet[HE_PPE_CAP10_IDX], HE_PPE_CAP10_PPET8_FOR_NSS4_FOR_RU0);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru1)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP11_IDX],
+			conf_he_ppet[HE_PPE_CAP11_IDX], HE_PPE_CAP11_PPET8_FOR_NSS4_FOR_RU1);
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru2) {
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP11_IDX],
+			conf_he_ppet[HE_PPE_CAP11_IDX], HE_PPE_CAP11_PPET8_FOR_NSS4_FOR_RU2);
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP12_IDX],
+			conf_he_ppet[HE_PPE_CAP12_IDX], HE_PPE_CAP12_PPET8_FOR_NSS4_FOR_RU2);
+	}
+
+	if (cap_idx->he_ppe_thresholds_ppet8_for_nsts4_for_ru3)
+		mxl_clr_set_he_cap(&debug_he_ppet[HE_PPE_CAP12_IDX],
+			conf_he_ppet[HE_PPE_CAP12_IDX], HE_PPE_CAP12_PPET8_FOR_NSS4_FOR_RU3);
+}
+
+static void mxl_hostapd_set_debug_mode_he_cap (struct hostapd_data *hapd)
+{
+	struct he_capabilities *hw = NULL;
+	struct ieee80211_he_capabilities *conf = &hapd->iconf->mxl_conf.he_capab_dbg;
+	struct he_override_hw_capab *override_cap_idx = &hapd->iconf->mxl_conf.override_hw_capab;
+	enum ieee80211_op_mode mode = IEEE80211_MODE_AP;
+
+	if (!hapd->iface->current_mode ||
+		!hapd->iface->current_mode->he_capab[mode].he_supported) {
+		wpa_printf(MSG_ERROR, "HE is not supported");
+		return;
+	}
+
+	hw = &hapd->iface->current_mode->he_capab[mode];
+
+	if (hapd->iconf->mxl_conf.enable_he_debug_mode) {
+		mxl_hostapd_set_debug_he_mac_capab_info(hw->mac_cap,
+				conf->he_mac_capab_info, override_cap_idx);
+		mxl_hostapd_set_debug_he_phy_capab_info(hw->phy_cap,
+				conf->he_phy_capab_info, override_cap_idx);
+		mxl_hostapd_set_debug_he_txrx_mcs_support(hw->mcs,
+				conf->optional, override_cap_idx);
+		/* PPE thresholds for now in conf stored with static offset HE_PPE_THRES_INDEX */
+		mxl_hostapd_set_debug_he_ppe_thresholds(hw->ppet,
+				conf->optional + HE_PPE_THRES_INDEX, override_cap_idx);
+	}
+}
+
+static void mxl_hostapd_send_debug_mode_he_cap (struct hostapd_data *hapd)
+{
+	errno_t err = EOK;
+	struct intel_vendor_he_capa debug_data = { 0 };
+	struct he_capabilities *he_capab = NULL;
+	enum ieee80211_op_mode mode = IEEE80211_MODE_AP;
+
+	if (!hapd->iconf->mxl_conf.enable_he_debug_mode)
+		return;
+
+
+	if (!hapd->iface->current_mode ||
+		!hapd->iface->current_mode->he_capab[mode].he_supported) {
+		wpa_printf(MSG_ERROR, "HE is not supported");
+		return;
+	}
+
+	he_capab = &hapd->iface->current_mode->he_capab[mode];
+
+	/* Sanity check */
+	if ((sizeof(he_capab->mcs) + sizeof(he_capab->ppet)) < (sizeof(debug_data.he_txrx_mcs_support) + sizeof(debug_data.he_ppe_thresholds))) {
+		wpa_printf(MSG_ERROR, "%s: unsufficient size to copy from", __func__);
+		return;
+	}
+
+	err = memcpy_s(debug_data.he_mac_capab_info, sizeof(debug_data.he_mac_capab_info),
+			he_capab->mac_cap, sizeof(he_capab->mac_cap));
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+
+	err = memcpy_s(debug_data.he_phy_capab_info, sizeof(debug_data.he_phy_capab_info),
+			he_capab->phy_cap, sizeof(he_capab->phy_cap));
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+
+	err = memcpy_s(debug_data.he_txrx_mcs_support, sizeof(debug_data.he_txrx_mcs_support),
+			he_capab->mcs, sizeof(he_capab->mcs));
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+
+	err = memcpy_s(debug_data.he_ppe_thresholds, sizeof(debug_data.he_ppe_thresholds),
+			he_capab->ppet, sizeof(he_capab->ppet));
+	if (EOK != err) {
+		wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+		return;
+	}
+
+	MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_HE_DEBUG_DATA, &debug_data, sizeof(debug_data));
+}
+
+static void mxl_hostapd_send_non_adv_he_cap (struct hostapd_data *hapd)
+{
+	bool he_cap_non_adv_override = false;
+	struct intel_vendor_he_capa he_non_advertised_caps = { 0 };
+	struct he_override_hw_capab *ovrd_flags = &hapd->iconf->mxl_conf.override_hw_capab;
+	struct he_capabilities *he_capab = NULL;
+	enum ieee80211_op_mode mode = IEEE80211_MODE_AP;
+
+	if (!hapd->iface->current_mode ||
+		!hapd->iface->current_mode->he_capab[mode].he_supported) {
+		wpa_printf(MSG_ERROR, "HE is not supported");
+		return;
+	}
+
+	he_capab = &hapd->iface->current_mode->he_capab[mode];
+
+	he_cap_non_adv_override =
+		((ovrd_flags->he_cap_non_adv_multi_bss_rx_control_support_override |
+		ovrd_flags->he_cap_non_adv_punc_pream_rx_support_override) != 0);
+
+	if (he_cap_non_adv_override) {
+		if (MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_GET_HE_NON_ADVERTISED, NULL, 0, &he_non_advertised_caps, sizeof(he_non_advertised_caps))) {
+			wpa_printf(MSG_ERROR, "Failed to get non-advertised HE capabilities from driver");
+			return;
+		}
+
+		if (ovrd_flags->he_cap_non_adv_punc_pream_rx_support_override) {
+			clr_set_he_cap(&he_non_advertised_caps.he_phy_capab_info[HE_PHYCAP_CAP1_IDX],
+				hapd->iconf->mxl_conf.he_cap_non_adv_punc_pream_rx_support, HE_PHY_CAP1_PUN_PREAM_RX);
+			clr_set_he_cap(&he_capab->phy_cap[HE_PHYCAP_CAP1_IDX],
+				hapd->iconf->mxl_conf.he_cap_non_adv_punc_pream_rx_support, HE_PHY_CAP1_PUN_PREAM_RX);
+		}
+
+		if (ovrd_flags->he_cap_non_adv_multi_bss_rx_control_support_override) {
+			clr_set_he_cap(&he_non_advertised_caps.he_mac_capab_info[HE_MACCAP_CAP3_IDX],
+				hapd->iconf->mxl_conf.he_cap_non_adv_multi_bss_rx_control_support, HE_MAC_CAP3_RX_CONTROL_FRAME_TO_MULTIBSS);
+			clr_set_he_cap(&he_capab->mac_cap[HE_MACCAP_CAP3_IDX],
+				hapd->iconf->mxl_conf.he_cap_non_adv_multi_bss_rx_control_support, HE_MAC_CAP3_RX_CONTROL_FRAME_TO_MULTIBSS);
+		}
+
+		if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_HE_NON_ADVERTISED, &he_non_advertised_caps, sizeof(he_non_advertised_caps)))
+			wpa_printf(MSG_ERROR, "Failed to set non-advertised HE capabilities in driver");
+	}
+}
+#endif /* CONFIG_IEEE80211AX */
+
+
 int mxl_hostapd_setup_interface(struct hostapd_data *hapd)
 {
 	struct mxl_hostapd_config *mxl_conf = &hapd->iconf->mxl_conf;
@@ -172,6 +826,11 @@ int mxl_hostapd_setup_interface(struct hostapd_data *hapd)
 	(void)mxl_conf;
 	(void)mxl_bss_conf;
 
+#ifdef CONFIG_IEEE80211AX
+	/* He Debug mode */
+	mxl_hostapd_set_debug_mode_he_cap(hapd);
+#endif
+
 	/* Add next vendor command here */
 	return 0;
 }
@@ -207,9 +866,21 @@ int mxl_hostapd_setup_bss_post(struct hostapd_data *hapd)
 	struct mxl_hostapd_config *mxl_conf = &hapd->iconf->mxl_conf;
 	(void)mxl_bss_conf;
 	(void)mxl_conf;
+
+#ifdef CONFIG_IEEE80211AX
+	mxl_hostapd_send_debug_mode_he_cap(hapd);
+	mxl_hostapd_send_non_adv_he_cap(hapd);
+#endif /* CONFIG_IEEE80211AX */
+
 	return 0;
 }
 
+void mxl_hostapd_setup_interface_post(struct hostapd_iface *iface)
+{
+	struct hostapd_data *hapd = iface->bss[0];
+	(void)hapd;
+}
+
 int mxl_hostapd_drv_get_vendor_data(struct hostapd_data *hapd,
 			unsigned int vendor_id, unsigned int subcmd,
 			void *input_data, size_t input_data_size,
diff --git a/src/ap/mxl_hostapd.h b/src/ap/mxl_hostapd.h
index caa238783..2a223dda1 100644
--- a/src/ap/mxl_hostapd.h
+++ b/src/ap/mxl_hostapd.h
@@ -140,6 +140,7 @@ int hostapd_chan_to_freq(int channel, bool op_class_6g);
 int is_24ghz_op_class(u8 op_class);
 int is_5ghz_op_class(u8 op_class);
 int mxl_hostapd_setup_interface(struct hostapd_data *hapd);
+void mxl_hostapd_setup_interface_post(struct hostapd_iface *iface);
 int mxl_hostapd_setup_bss_pre(struct hostapd_data *hapd);
 int mxl_hostapd_setup_bss_post(struct hostapd_data *hapd);
 
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index 63e5bc97f..4dd686e06 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -2496,8 +2496,8 @@ struct ieee80211_spatial_reuse {
 #define HE_PHY_CAP7_SU_PPDU_AND_HE_MU_WITH_4X_HE_LTF_0_8US_GI ((u8) BIT(2))
 
 #define HE_PHYCAP_CAP8_IDX 8
-#define HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_2_4_GHZ_BAND	((u8) BIT(1))
-#define HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU		((u8) BIT(2))
+#define HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_2_4_GHZ_BAND ((u8) BIT(1))
+#define HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU ((u8) BIT(2))
 
 /* HE-MCS and NSS set field */
 #define HE_MCS_NSS_RX_MCS_MAP_LESS_EQ_80_MHZ_PART1_IDX 0
@@ -3107,6 +3107,7 @@ struct ieee80211_neighbor_ap_info {
 #pragma pack(pop)
 #endif /* _MSC_VER */
 
+
 /* IEEE 802.11AX DRAFT VER 4.3
  * HE MAC Capabilities Information field defines
  */
diff --git a/src/common/mxl_ieee802_11_defs.h b/src/common/mxl_ieee802_11_defs.h
index 482a90ce2..8325220f4 100644
--- a/src/common/mxl_ieee802_11_defs.h
+++ b/src/common/mxl_ieee802_11_defs.h
@@ -123,5 +123,147 @@ struct dmg_link_adaptation_ack {
 	le32 ref_timestamp;
 } STRUCT_PACKED;
 
+/* According to IEEE80211-2016 "The subfields of the
+ * VHT Operation Information field are defined in Table 9-252.*/
+#define VHT_OPER_CHANWIDTH_20_40MHZ			0
+#define VHT_OPER_CHANWIDTH_80_160_80P80MHZ	1
+#define VHT_OPER_CHANWIDTH_160MHZ			2
+#define VHT_OPER_CHANWIDTH_80P80MHZ			3
+
+#define HE_PHYCAP_CAP1_IDX 1
+#define HE_PHY_CAP1_PUN_PREAM_RX ((u8) (BIT(0) | BIT(1) | BIT(2) | BIT(3)))
+#define HE_PHY_CAP1_DEVICE_CLASS ((u8) BIT(4))
+#define HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD ((u8) BIT(5))
+#define HE_PHY_CAP1_SU_PPDU_1XHE_LTF_0_8US_GI ((u8) BIT(6))
+/* HE_PHYCAP_MIDAMBLE_TXRX_MAX__NSTS B15 B16 */
+#define HE_PHY_CAP1_MIDAMBLE_TXRX_MAX_NSTS ((u8) BIT(7))
+
+#define HE_PHY_CAP2_MIDAMBLE_TXRX_MAX_NSTS ((u8) BIT(0))
+#define HE_PHY_CAP2_NDP_4X_HE_LTF_AND_3_2MS_GI ((u8) BIT(1))
+#define HE_PHY_CAP2_STBC_TX_LESS_OR_EQUAL_80MHz ((u8) BIT(2))
+#define HE_PHY_CAP2_STBC_RX_LESS_OR_EQUAL_80MHz ((u8) BIT(3))
+#define HE_PHY_CAP2_DOPPLER_TX ((u8) BIT(4))
+#define HE_PHY_CAP2_DOPPLER_RX ((u8) BIT(5))
+
+#define HE_PHYCAP_CAP3_IDX 3
+#define HE_PHY_CAP3_DCM_MAX_CONSTELLATION_TX ((u8) (BIT(0) | BIT(1)))
+#define HE_PHY_CAP3_DCM_MAX_NSS_TX ((u8) BIT(2))
+#define HE_PHY_CAP3_DCM_MAX_CONSTELLATION_RX ((u8) (BIT(3) | BIT(4)))
+#define HE_PHY_CAP3_DCM_MAX_NSS_RX ((u8) BIT(5))
+#define HE_PHY_CAP3_RX_HE_MUPPDU_FROM_NON_AP_STA ((u8) BIT(6))
+#define HE_PHY_CAP3_SU_BEAMFORMER ((u8) BIT(7))
+
+#define HE_PHYCAP_CAP4_IDX 4
+#define HE_PHY_CAP4_SU_BEAMFORMEE ((u8) BIT(0))
+#define HE_PHY_CAP4_MU_BEAMFORMER ((u8) BIT(1))
+#define HE_PHY_CAP4_BF_STS_LESS_OR_EQ_80MHz ((u8) (BIT(2) | BIT(3) | BIT(4)))
+#define HE_PHY_CAP4_BF_STS_GREATER_THAN_80MHz ((u8) (BIT(5) | BIT(6) | BIT(7)))
+
+#define HE_PHYCAP_CAP5_IDX 5
+#define HE_PHY_CAP5_NUM_SOUND_DIM_LESS_80MHz ((u8) (BIT(0) | BIT(1) | BIT(2)))
+#define HE_PHY_CAP5_NUM_SOUND_DIM_GREAT_80MHz ((u8) (BIT(3) | BIT(4) | BIT(5)))
+#define HE_PHY_CAP5_NG_16_FOR_SU_FB_SUPPORT ((u8) BIT(6))
+#define HE_PHY_CAP5_NG_16_FOR_MU_FB_SUPPORT ((u8) BIT(7))
+
+#define HE_PHY_CAP6_CODEBOOK_SIZE42_FOR_SU_SUPPORT ((u8) BIT(0))
+#define HE_PHY_CAP6_CODEBOOK_SIZE75_FOR_MU_SUPPORT ((u8) BIT(1))
+#define HE_PHY_CAP6_TRIGGERED_SU_BEAMFORMING_FEEDBACK ((u8) BIT(2))
+#define HE_PHY_CAP6_TRIGGERED_MU_BEAMFORMING_PARTIAL_BW_FEEDBACK ((u8) BIT(3))
+#define HE_PHY_CAP6_TRIGGERED_CQI_FEEDBACK ((u8) BIT(4))
+#define HE_PHY_CAP6_PARTIAL_BANDWIDTH_EXTENDED_RANGE ((u8) BIT(5))
+#define HE_PHY_CAP6_PPE_THRESHOLD_PRESENT ((u8) BIT(7))
+
+#define HE_PHY_CAP7_SRP_BASED_SR_SUPPORT ((u8) BIT(0))
+#define HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPPORT ((u8) BIT(1))
+#define HE_PHY_CAP7_MAX_NC ((u8) (BIT(3) | BIT(4) | BIT(5)))
+#define HE_PHY_CAP7_STBC_TX_GREATER_THAN_80MHz ((u8) BIT(6))
+#define HE_PHY_CAP7_STBC_RX_GREATER_THAN_80MHz ((u8) BIT(7))
+
+#define HE_PHY_CAP8_HE_ER_SU_PPDU_4X_HE_LTF_0_8_US_GI ((u8) BIT(0))
+#define HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU ((u8) BIT(3))
+#define HE_PHY_CAP8_HE_ER_SU_PPDU_1X_HE_LTF_0_8_US_GI ((u8) BIT(4))
+#define HE_PHY_CAP8_MIDAMBLE_TX_RX_2X_AND_1X_HE_LTF ((u8) BIT(5))
+#define HE_PHY_CAP8_DCM_MAX_BW ((u8) (BIT(6) | BIT(7)))
+
+#define HE_PHYCAP_CAP9_IDX 9
+#define HE_PHY_CAP9_LONGER_THAN_16_HE_SIGB_OFDM_SYMBOLS_SUPPORT ((u8) BIT(0))
+#define HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK ((u8) BIT(1))
+#define HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU_SUPPORT ((u8) BIT(2))
+#define HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU_SUPPORT ((u8) BIT(3))
+#define HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_PPDU_NON_COMP_SIGB ((u8) BIT(4))
+#define HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_PPDU_COMP_SIGB ((u8) BIT(5))
+#define HE_PHY_CAP9_NOMINAL_PACKET_PADDING ((u8) (BIT(6) | BIT(7)))
+
+/* HE PPE Thresholds field */
+#define HE_PPE_THRES_INDEX 12
+
+#define HE_PPE_CAP0_IDX 0
+#define HE_PPE_CAP0_NSS_M1 ((u8) (BIT(0) | BIT(1) | BIT(2)))
+#define HE_PPE_CAP0_RU_INDEX_BITMASK ((u8) (BIT(3) | BIT(4) | BIT(5) | BIT(6)))
+#define HE_PPE_CAP0_PPET16_FOR_NSS1_FOR_RU0 ((u8) BIT(7))
+
+#define HE_PPE_CAP1_IDX 1
+#define HE_PPE_CAP1_PPET16_FOR_NSS1_FOR_RU0 ((u8) (BIT(0) | BIT(1)))
+#define HE_PPE_CAP1_PPET8_FOR_NSS1_FOR_RU0 ((u8) (BIT(2) | BIT(3) | BIT(4)))
+#define HE_PPE_CAP1_PPET16_FOR_NSS1_FOR_RU1 ((u8) (BIT(5) | BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP2_IDX 2
+#define HE_PPE_CAP2_PPET8_FOR_NSS1_FOR_RU1 ((u8) (BIT(0) | BIT(1) | BIT(2)))
+#define HE_PPE_CAP2_PPET16_FOR_NSS1_FOR_RU2 ((u8) (BIT(3) | BIT(4) | BIT(5)))
+#define HE_PPE_CAP2_PPET8_FOR_NSS1_FOR_RU2 ((u8) (BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP3_IDX 3
+#define HE_PPE_CAP3_PPET8_FOR_NSS1_FOR_RU2 (u8) BIT(0)
+#define HE_PPE_CAP3_PPET16_FOR_NSS1_FOR_RU3 ((u8) (BIT(1) | BIT(2) | BIT(3)))
+#define HE_PPE_CAP3_PPET8_FOR_NSS1_FOR_RU3 ((u8) (BIT(4) | BIT(5) | BIT(6)))
+#define HE_PPE_CAP3_PPET16_FOR_NSS2_FOR_RU0 ((u8) BIT(7))
+
+#define HE_PPE_CAP4_IDX 4
+#define HE_PPE_CAP4_PPET16_FOR_NSS2_FOR_RU0 ((u8) (BIT(0) | BIT(1)))
+#define HE_PPE_CAP4_PPET8_FOR_NSS2_FOR_RU0 ((u8) (BIT(2) | BIT(3) | BIT(4)))
+#define HE_PPE_CAP4_PPET16_FOR_NSS2_FOR_RU1 ((u8) (BIT(5) | BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP5_IDX 5
+#define HE_PPE_CAP5_PPET8_FOR_NSS2_FOR_RU1 ((u8) (BIT(0) | BIT(1) | BIT(2)))
+#define HE_PPE_CAP5_PPET16_FOR_NSS2_FOR_RU2 ((u8) (BIT(3) | BIT(4) | BIT(5)))
+#define HE_PPE_CAP5_PPET8_FOR_NSS2_FOR_RU2 ((u8) (BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP6_IDX 6
+#define HE_PPE_CAP6_PPET8_FOR_NSS2_FOR_RU2 ((u8) BIT(0))
+#define HE_PPE_CAP6_PPET16_FOR_NSS2_FOR_RU3 ((u8) (BIT(1) | BIT(2) | BIT(3)))
+#define HE_PPE_CAP6_PPET8_FOR_NSS2_FOR_RU3 ((u8) (BIT(4) | BIT(5) | BIT(6)))
+#define HE_PPE_CAP6_PPET16_FOR_NSS3_FOR_RU0 ((u8) BIT(7))
+
+#define HE_PPE_CAP7_IDX 7
+#define HE_PPE_CAP7_PPET16_FOR_NSS3_FOR_RU0 ((u8) (BIT(0) | BIT(1)))
+#define HE_PPE_CAP7_PPET8_FOR_NSS3_FOR_RU0 ((u8) (BIT(2) | BIT(3) | BIT(4)))
+#define HE_PPE_CAP7_PPET16_FOR_NSS3_FOR_RU1 ((u8) (BIT(5) | BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP8_IDX 8
+#define HE_PPE_CAP8_PPET8_FOR_NSS3_FOR_RU1 ((u8) (BIT(0) | BIT(1) | BIT(2)))
+#define HE_PPE_CAP8_PPET16_FOR_NSS3_FOR_RU2 ((u8) (BIT(3) | BIT(4) | BIT(5)))
+#define HE_PPE_CAP8_PPET8_FOR_NSS3_FOR_RU2 ((u8) (BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP9_IDX 9
+#define HE_PPE_CAP9_PPET8_FOR_NSS3_FOR_RU2 ((u8) BIT(0))
+#define HE_PPE_CAP9_PPET16_FOR_NSS3_FOR_RU3 ((u8) (BIT(1) | BIT(2) | BIT(3)))
+#define HE_PPE_CAP9_PPET8_FOR_NSS3_FOR_RU3 ((u8) (BIT(4) | BIT(5) | BIT(6)))
+#define HE_PPE_CAP9_PPET16_FOR_NSS4_FOR_RU0 ((u8) BIT(7))
+
+#define HE_PPE_CAP10_IDX 10
+#define HE_PPE_CAP10_PPET16_FOR_NSS4_FOR_RU0 ((u8) (BIT(0) | BIT(1)))
+#define HE_PPE_CAP10_PPET8_FOR_NSS4_FOR_RU0 ((u8) (BIT(2) | BIT(3) | BIT(4)))
+#define HE_PPE_CAP10_PPET16_FOR_NSS4_FOR_RU1 ((u8) (BIT(5) | BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP11_IDX 11
+#define HE_PPE_CAP11_PPET8_FOR_NSS4_FOR_RU1 ((u8) (BIT(0) | BIT(1) | BIT(2)))
+#define HE_PPE_CAP11_PPET16_FOR_NSS4_FOR_RU2 ((u8) (BIT(3) | BIT(4) | BIT(5)))
+#define HE_PPE_CAP11_PPET8_FOR_NSS4_FOR_RU2 ((u8) (BIT(6) | BIT(7)))
+
+#define HE_PPE_CAP12_IDX 12
+#define HE_PPE_CAP12_PPET8_FOR_NSS4_FOR_RU2 ((u8) BIT(0))
+#define HE_PPE_CAP12_PPET16_FOR_NSS4_FOR_RU3 ((u8) (BIT(1) | BIT(2) | BIT(3)))
+#define HE_PPE_CAP12_PPET8_FOR_NSS4_FOR_RU3 ((u8) (BIT(4) | BIT(5) | BIT(6)))
+
 #endif /* MXL_IEEE802_11_DEFS_H */
 
diff --git a/src/common/vendor_cmds_copy.h b/src/common/vendor_cmds_copy.h
index 1aee2976e..16b479a9d 100644
--- a/src/common/vendor_cmds_copy.h
+++ b/src/common/vendor_cmds_copy.h
@@ -631,6 +631,16 @@ struct intel_vendor_mac_addr_list_cfg {
   u8 remove;
 } __attribute__ ((packed));
 
+/* Data for LTQ_NL80211_VENDOR_SUBCMD_SET_HE_DEBUG_DATA,
+ *          LTQ_NL80211_VENDOR_SUBCMD_SET_HE_NON_ADVERTISED and
+ *          LTQ_NL80211_VENDOR_SUBCMD_GET_HE_NON_ADVERTISED vendor commands */
+struct intel_vendor_he_capa {
+  u8 he_mac_capab_info[6];
+  u8 he_phy_capab_info[11];
+  u8 he_txrx_mcs_support[12];
+  u8 he_ppe_thresholds[25];
+} __attribute__ ((packed));
+
 /*******************************************************************************
 *                           Event structures                                   *
 *******************************************************************************/
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 34f091918..ca327b70e 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -5360,6 +5360,13 @@ struct wpa_driver_ops {
 	 * Returns: 0 on success, -1 on failure
 	 */
 	int (*set_he_beacon)(void *priv, int enable);
+
+	/**
+	 * set_he_non_advertised_info - Set non-advertised HE Capabilities element
+	 * @priv: Private driver interface data
+	 * @he_capab: Non advertised HE capabilities data
+	 */
+	int (*set_he_non_advertised_info)(void *priv, struct intel_vendor_he_capa *he_capab);
 };
 
 /**
-- 
2.43.0

