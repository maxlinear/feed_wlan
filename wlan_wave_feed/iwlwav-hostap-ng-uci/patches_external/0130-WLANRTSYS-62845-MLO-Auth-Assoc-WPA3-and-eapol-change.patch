From d04057be88d67ef9d02fff04a714e9ad27fbe9eb Mon Sep 17 00:00:00 2001
From: hmgokhale <hmgokhale@maxlinear.com>
Date: Wed, 6 Mar 2024 16:04:05 +0530
Subject: [PATCH] WLANRTSYS-62845 MLO Auth Assoc, WPA3 and eapol changes

Signed-off-by: hmgokhale <hmgokhale@maxlinear.com>
---
 hostapd/Makefile                 |   3 +
 hostapd/ctrl_iface.c             |   2 +
 hostapd/mxl_config.c             |  64 +++
 hostapd/mxl_ctrl_iface.c         |  52 +-
 src/ap/ap_drv_ops.c              |   4 +
 src/ap/drv_callbacks.c           |  16 +
 src/ap/hostapd.c                 |   9 +
 src/ap/ieee802_11.c              | 225 ++++++++-
 src/ap/ieee802_11_eht.c          |  15 +
 src/ap/mxl_config.h              |   5 +
 src/ap/mxl_drv_callbacks.c       |  89 ++++
 src/ap/mxl_drv_callbacks.h       |  16 +
 src/ap/mxl_hostapd.c             | 218 ++++++++-
 src/ap/mxl_hostapd.h             |  19 +
 src/ap/mxl_ieee802_11.c          | 782 +++++++++++++++++++++++++++++++
 src/ap/mxl_ieee802_11.h          |  27 +-
 src/ap/mxl_ieee802_11_eht.h      |  17 +
 src/ap/mxl_mld.c                 | 631 ++++++++++++++++---------
 src/ap/mxl_mld.h                 |  19 +-
 src/ap/mxl_sta_info.c            | 264 +++++++++++
 src/ap/mxl_sta_info.h            |  38 ++
 src/ap/mxl_utils.c               | 125 +++++
 src/ap/mxl_utils.h               |  21 +
 src/ap/mxl_wpa_auth.c            | 711 ++++++++++++++++++++++++++++
 src/ap/mxl_wpa_auth.h            |  29 ++
 src/ap/mxl_wpa_auth_glue.c       |  42 ++
 src/ap/mxl_wpa_auth_glue.h       |   3 +
 src/ap/sta_info.c                |  40 ++
 src/ap/sta_info.h                |   6 +
 src/ap/utils.c                   |   5 +
 src/ap/wnm_ap.c                  |  12 +
 src/ap/wpa_auth.c                |  99 ++++
 src/ap/wpa_auth_ft.c             |   7 +
 src/ap/wpa_auth_glue.c           |   8 +
 src/ap/wpa_auth_i.h              |   3 +
 src/ap/wpa_auth_ie.c             |  20 +
 src/common/mxl_defs.h            |   4 +
 src/common/mxl_ieee802_11_defs.h |  13 +
 src/common/mxl_sae.h             |  20 +
 src/common/sae.h                 |   7 +
 src/common/vendor_cmds_copy.h    |  37 ++
 src/common/wpa_common.c          |  10 +
 src/common/wpa_common.h          |   4 +
 src/drivers/driver.h             |   3 +
 src/drivers/driver_nl80211.c     |   9 +
 src/drivers/mxl_driver.h         |   6 +
 46 files changed, 3505 insertions(+), 254 deletions(-)
 create mode 100644 src/ap/mxl_drv_callbacks.c
 create mode 100644 src/ap/mxl_drv_callbacks.h
 create mode 100644 src/ap/mxl_ieee802_11_eht.h
 create mode 100644 src/ap/mxl_sta_info.c
 create mode 100644 src/ap/mxl_sta_info.h
 create mode 100644 src/ap/mxl_utils.c
 create mode 100644 src/ap/mxl_utils.h
 create mode 100644 src/common/mxl_sae.h

diff --git a/hostapd/Makefile b/hostapd/Makefile
index b805e2d6a..b4327c719 100644
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -396,6 +396,9 @@ OBJS += ../src/ap/mxl_wpa_auth.o
 OBJS += ../src/ap/mxl_wpa_auth_glue.o
 OBJS += ../src/ap/mxl_beacon.o
 OBJS += ../src/ap/mxl_ieee802_11_shared.o
+OBJS += ../src/ap/mxl_drv_callbacks.o
+OBJS += ../src/ap/mxl_sta_info.o
+OBJS += ../src/ap/mxl_utils.o
 ifdef CONFIG_IEEE80211BE_MXL_MLO
 OBJS += ../src/ap/mxl_mld.o
 endif
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 1408b0a97..9e2ce1235 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -6243,9 +6243,11 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
 		if (hostapd_ctrl_iface_deauthenticate(hapd, buf + 15))
 			reply_len = -1;
+#ifndef CONFIG_IEEE80211BE_MXL_MLO
 	} else if (os_strncmp(buf, "DISASSOCIATE ", 13) == 0) {
 		if (hostapd_ctrl_iface_disassociate(hapd, buf + 13))
 			reply_len = -1;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #ifdef CONFIG_TAXONOMY
 	} else if (os_strncmp(buf, "SIGNATURE ", 10) == 0) {
 		reply_len = hostapd_ctrl_iface_signature(hapd, buf + 10,
diff --git a/hostapd/mxl_config.c b/hostapd/mxl_config.c
index 2a8482803..329a08ce3 100644
--- a/hostapd/mxl_config.c
+++ b/hostapd/mxl_config.c
@@ -1463,6 +1463,59 @@ static int mxl_hostapd_config_fill_mlo(struct hostapd_config *conf, const char *
 			wpa_printf(MSG_ERROR, "Line %d: invalid ap_mld_mac item", line);
 			return 0;
 		}
+	} else if (os_strcmp(buf, "eml_capab_transition_timeout") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, EML_CAPAB_TRANSITION_TIMEOUT_MIN, EML_CAPAB_TRANSITION_TIMEOUT_MAX)) {
+			wpa_printf(MSG_ERROR, "Invalid EML Capability transition timeout, "
+					"must be in range %u..%u", EML_CAPAB_TRANSITION_TIMEOUT_MIN, EML_CAPAB_TRANSITION_TIMEOUT_MAX);
+			return 0;
+		}
+		bss->mxl_bss_conf.eml_transition_timeout = (u16)val;
+	} else if (os_strcmp(buf, "mld_mediumsync_present") == 0 ) {
+		int val = atoi(pos);
+		if (!IS_VALID_BOOL_RANGE(val)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid mld_mediumsync_present %d",
+					line, val);
+			return 0;
+		}
+		bss->mxl_bss_conf.mld_mediumsync_present = val;
+	} else if (os_strcmp(buf, "mld_mediumsync_duration") == 0 ) {
+		/* Value of mld_mediumsync_duration is in multiples of 32usec
+		 * Below division by 32 is to advertise in units of 32usec
+		 */
+		int val = atoi(pos)/32;
+		if (!IS_VALID_RANGE(val, 0, MLO_MEDIUM_SYNC_DURATION_MAX)) {
+			wpa_printf(MSG_ERROR, "Invalid mld_mediumsync_duration, "
+					"must be in range 0..%u", MLO_MEDIUM_SYNC_DURATION_MAX * 32);
+			return 0;
+		}
+		bss->mxl_bss_conf.mld_mediumsync_duration = (u8)val;
+	} else if (os_strcmp(buf, "mld_mediumsync_ofdmedthresh") == 0 ) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, 0, MLO_MEDIUM_SYNC_OFDMED_THRESH_MAX)) {
+			wpa_printf(MSG_ERROR, "Invalid mld_mediumsync_ofdmedthresh, "
+					"must be in range 0..%u", MLO_MEDIUM_SYNC_OFDMED_THRESH_MAX);
+			return 0;
+		}
+		bss->mxl_bss_conf.mld_mediumsync_ofdmedthresh = (u8)val;
+	} else if (os_strcmp(buf, "mld_mediumsync_maxtxop") == 0 ) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, 0, MLO_MEDIUM_SYNC_MAXTXOP_MAX)) {
+			wpa_printf(MSG_ERROR, "Invalid mld_mediumsync_maxtxop, "
+					"must be in range 0..%u", MLO_MEDIUM_SYNC_MAXTXOP_MAX);
+			return 0;
+		}
+		bss->mxl_bss_conf.mld_mediumsync_maxtxop = (u8)val;
+	} else if (os_strcmp(buf, "eht_mld_tsf_diff") == 0) {
+		int val = atoi(pos);
+		if (!IS_VALID_RANGE(val, ML_IE_LINK_INFO_TSF_OFFSET_MIN, ML_IE_LINK_INFO_TSF_OFFSET_MAX)) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid eht_mld_tsf_diff %d (expected [%d...%d])",
+					line, val, ML_IE_LINK_INFO_TSF_OFFSET_MIN, ML_IE_LINK_INFO_TSF_OFFSET_MAX);
+			return 0;
+		}
+		conf->mxl_conf.eht_mld_tsf_diff = val;
+	} else if (os_strcmp(buf, "mlo_t2lm_support") == 0) {
+		bss->mxl_bss_conf.mlo_t2lm_support = atoi(pos);
 	} else
 		return 0;
 
@@ -1893,6 +1946,16 @@ void mxl_hostapd_config_free(struct hostapd_config *conf)
 }
 int mxl_hostapd_config_check(struct hostapd_config *conf, int full_config)
 {
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (!conf->ieee80211be) {
+		int i;
+		for (i = 0; i < conf->num_bss; i++) {
+			if (conf->bss[i]->mxl_bss_conf.mlo_enable)
+				return -1;
+		}
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #ifdef CONFIG_IEEE80211BE
 	if (full_config && conf->ieee80211be) {
 		int i;
@@ -1905,6 +1968,7 @@ int mxl_hostapd_config_check(struct hostapd_config *conf, int full_config)
 		}
 	}
 #endif /* CONFIG_IEEE80211BE */
+
 	return 0;
 }
 
diff --git a/hostapd/mxl_ctrl_iface.c b/hostapd/mxl_ctrl_iface.c
index f80f7b838..0f49565e8 100644
--- a/hostapd/mxl_ctrl_iface.c
+++ b/hostapd/mxl_ctrl_iface.c
@@ -26,9 +26,9 @@
 #include "ap/mxl_hostapd.h"
 #include "drivers/mxl_driver_nl80211.h"
 #include "mxl_ctrl_iface.h"
-#include "ap/ctrl_iface_ap.h"
 #include "ap/mxl_softblock.h"
 #include "ap/mxl_rrm.h"
+#include "ap/ctrl_iface_ap.h"
 
 
 struct hostapd_data *mxl_get_bss_index(const char **cmd, struct hostapd_data *hapd, bool ctrl_iface, bool delim)
@@ -2692,6 +2692,50 @@ exit:
 			rep_reason_p);
 }
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+static int mxl_hostapd_ctrl_iface_send_t2lm_teardown_frame(struct hostapd_data *hapd,
+		const char *cmd)
+{
+	u8 addr[ETH_ALEN];
+
+	hapd = mxl_get_bss_index(&cmd, hapd, true, true);
+	if (NULL == hapd) {
+		wpa_printf(MSG_ERROR, "CTRL: SEND_T2LM_TEARDOWN_FRAME - there is no iface with the given name");
+		return -1;
+	}
+
+	if (!hapd->conf->mxl_bss_conf.mlo_enable) {
+		wpa_printf(MSG_ERROR, "CTRL: SEND_T2LM_TEARDOWN_FRAME - MLO not enabled in AP");
+		return -1;
+	}
+
+	cmd = os_strchr(cmd, ' ');
+	if (!cmd) {
+		wpa_printf(MSG_ERROR, "CTRL: SEND_T2LM_TEARDOWN_FRAME - mac address is missing");
+		return -1;
+	}
+	cmd++;
+
+	if (hwaddr_aton(cmd, addr)) {
+		wpa_printf(MSG_ERROR, "CTRL: SEND_T2LM_TEARDOWN_FRAME - invalid peer mac address");
+		return -1;
+	}
+
+	return ml_sta_send_t2lm_teardown_frame(hapd, addr);
+}
+
+static void mxl_mlo_hostapd_ctrl_disassociate(struct hostapd_data *hapd, char *buf, int *reply_len)
+{
+	if (mxl_is_mlo_enabled(hapd->conf)) {
+		*reply_len = -1;
+	} else {
+		if (hostapd_ctrl_iface_disassociate(hapd, buf))
+			*reply_len = -1;
+	}
+}
+
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 int mxl_hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      char *buf, char *reply,
 					      int reply_size,
@@ -2866,6 +2910,12 @@ int mxl_hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 		*reply_len = mxl_hostapd_ctrl_iface_get_power_mode(hapd->iface, reply, reply_size);
 	} else if (os_strncmp(buf, "SET_POWER_MODE", 14) == 0) {
 		*reply_len = mxl_hostapd_ctrl_iface_set_power_mode(hapd->iface, buf + 14, reply, reply_size);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	} else if (os_strncmp(buf, "SEND_T2LM_TEARDOWN_FRAME ", sizeof("SEND_T2LM_TEARDOWN_FRAME ") - 1) == 0) {
+		*reply_len = mxl_hostapd_ctrl_iface_send_t2lm_teardown_frame(hapd, buf + sizeof("SEND_T2LM_TEARDOWN_FRAME ") - 1);
+	} else if (os_strncmp(buf, "DISASSOCIATE ", 13) == 0) {
+		mxl_mlo_hostapd_ctrl_disassociate(hapd, buf + 13, reply_len);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	} else {
 		return 0;
 	}
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index e3725cb23..2e9acce7f 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -477,6 +477,10 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 	}
 #endif /* CONFIG_IEEE80211BE */
 
+#ifdef CONFIG_VENDOR_MXL
+	mxl_hostapd_sta_add_params(hapd, &params);
+#endif /* CONFIG_VENDOR_MXL */
+
 	params.last_assoc_req = last_assoc_req;
 	params.last_assoc_req_len = last_assoc_req_len;
 	params.ssi_signal = ssi_signal;
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index 1e3a80699..c51e4444c 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -42,9 +42,15 @@
 #include "dpp_hostapd.h"
 #include "fils_hlp.h"
 #include "neighbor_db.h"
+#ifdef CONFIG_VENDOR_MXL
+#include "wpa_auth_i.h"
 #include "../hostapd/mxl_ctrl_iface.h"
 #include "mxl_beacon.h"
 #include "ap/mxl_config.h"
+#include "mxl_sta_info.h"
+#include "mxl_drv_callbacks.h"
+#include "mxl_ieee802_11.h"
+#endif /* CONFIG_VENDOR_MXL */
 
 #ifdef CONFIG_FILS
 void hostapd_notify_assoc_fils_finish(struct hostapd_data *hapd,
@@ -519,10 +525,16 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 		}
 #endif /* CONFIG_WPS */
 
+
 		if (sta->wpa_sm == NULL)
 			sta->wpa_sm = wpa_auth_sta_init(hapd->wpa_auth,
 							sta->addr,
 							p2p_dev_addr);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta))
+			mxl_wpa_mld_auth_sta_init(sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 		if (sta->wpa_sm == NULL) {
 			wpa_printf(MSG_ERROR,
 				   "Failed to initialize WPA state machine");
@@ -925,6 +937,10 @@ void hostapd_notif_disassoc(struct hostapd_data *hapd, const u8 *addr)
 {
 	struct sta_info *sta;
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd)
+		mxl_hostapd_notif_disassoc(hapd, addr);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	if (addr == NULL) {
 		/*
 		 * This could potentially happen with unexpected event from the
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 5081a7f26..603758fba 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -5799,6 +5799,15 @@ hostapd_color_switch_trigger(struct hostapd_data *hapd, u8 new_color)
 		return;
 	}
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	for (int k = 0; k < hapd->iface->num_bss; k++) {
+		if (mxl_is_mlo_enabled(hapd->iface->bss[k]->conf) && !(hapd->iface->bss[k]->beacon_set_done)) {
+			wpa_printf(MSG_ERROR, "BSS color collision detected before one of the mld vap %s is up, can't switch color", hapd->iface->bss[k]->conf->iface);
+			return;
+		}
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 	if (master->iface->in_unconnected_sta_scan) {
 		wpa_printf(MSG_ERROR, "unconnected_sta: Scan is already running, can't switch color");
 		return;
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index ffe072095..a5ff8e47b 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -58,14 +58,20 @@
 #include "comeback_token.h"
 #include "pasn/pasn_common.h"
 #ifdef CONFIG_VENDOR_MXL
+#include "wpa_auth_i.h"
 #include "mxl_hostapd.h"
 #include "mxl_coexistence.h"
 #include "mxl_wds.h"
 #include "mxl_beacon.h"
+#include "mxl_sta_info.h"
+#include "mxl_ieee802_11.h"
 #endif /* CONFIG_VENDOR_MXL */
 #ifdef CONFIG_WDS_WPA
 #include "wds_wpa.h"
 #endif
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+#include "mxl_mld.h"
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 
 #ifdef CONFIG_FILS
@@ -433,6 +439,9 @@ static int send_auth_reply(struct hostapd_data *hapd, struct sta_info *sta,
 	rlen = IEEE80211_HDRLEN + sizeof(reply->u.auth) + ies_len;
 	if (ml_resp)
 		rlen += wpabuf_len(ml_resp);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	rlen += mxl_ml_auth_len(hapd, sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	buf = os_zalloc(rlen);
 	if (!buf) {
 		wpabuf_free(ml_resp);
@@ -461,6 +470,10 @@ static int send_auth_reply(struct hostapd_data *hapd, struct sta_info *sta,
 	wpabuf_free(ml_resp);
 #endif /* CONFIG_IEEE80211BE */
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	mxl_auth_hostapd_eid_multilink(hapd, sta, reply->u.auth.variable + ies_len);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 	wpa_printf(MSG_DEBUG, "authentication reply: STA=" MACSTR
 		   " auth_alg=%d auth_transaction=%d resp=%d (IE len=%lu) (dbg=%s)",
 		   MAC2STR(dst), auth_alg, auth_transaction,
@@ -638,6 +651,12 @@ static struct wpabuf * auth_build_sae_commit(struct hostapd_data *hapd,
 		os_memcpy(sta->sae->tmp->own_addr, own_addr, ETH_ALEN);
 		os_memcpy(sta->sae->tmp->peer_addr, sta->addr, ETH_ALEN);
 #endif /* CONFIG_SAE_PK */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+			memcpy_s(sta->sae->tmp->mxl_sae_tmp_data.own_mld_addr, ETH_ALEN, hapd->conf->mxl_bss_conf.ap_mld_mac, ETH_ALEN);
+			memcpy_s(sta->sae->tmp->mxl_sae_tmp_data.peer_mld_addr, ETH_ALEN, sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN);
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	}
 
 	if (rx_id && hapd->conf->sae_pwe != SAE_PWE_FORCE_HUNT_AND_PECK)
@@ -654,9 +673,13 @@ static struct wpabuf * auth_build_sae_commit(struct hostapd_data *hapd,
 		return NULL;
 	}
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (update &&  use_pt && mxl_mlo_sae_prepare_commit_pt(hapd, sta, pt, pk))
+#else /* CONFIG_IEEE80211BE_MXL_MLO */
 	if (update && use_pt &&
 	    sae_prepare_commit_pt(sta->sae, pt, own_addr, sta->addr,
 				  NULL, pk) < 0)
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		return NULL;
 
 	if (update && !use_pt &&
@@ -913,6 +936,9 @@ static void sae_sme_send_external_auth_status(struct hostapd_data *hapd,
 
 void sae_accept_sta(struct hostapd_data *hapd, struct sta_info *sta)
 {
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	u8 *spa_addr;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #ifndef CONFIG_NO_VLAN
 	struct vlan_description vlan_desc;
 
@@ -950,9 +976,18 @@ void sae_accept_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	crypto_bignum_deinit(sta->sae->peer_commit_scalar_accepted, 0);
 	sta->sae->peer_commit_scalar_accepted = sta->sae->peer_commit_scalar;
 	sta->sae->peer_commit_scalar = NULL;
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	spa_addr = sta->addr;
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta))
+		spa_addr = sta->mxl_sta_info.non_ap_mld_mac;
+	wpa_auth_pmksa_add_sae(hapd->wpa_auth, spa_addr,
+			       sta->sae->pmk, sta->sae->pmk_len,
+			       sta->sae->pmkid, sta->sae->akmp);
+#else /* CONFIG_IEEE80211BE_MXL_MLO */
 	wpa_auth_pmksa_add_sae(hapd->wpa_auth, sta->addr,
 			       sta->sae->pmk, sta->sae->pmk_len,
 			       sta->sae->pmkid, sta->sae->akmp);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	sae_sme_send_external_auth_status(hapd, sta, WLAN_STATUS_SUCCESS);
 }
 
@@ -3089,6 +3124,12 @@ static void handle_auth(struct hostapd_data *hapd,
 #endif /* CONFIG_SAE */
 
 	sta = ap_get_sta(hapd, sa);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sta && (sta->flags & WLAN_STA_ASSOC)) {
+		mxl_hostapd_drv_cleanup_sta(hapd, sta);
+		sta = NULL;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	if (sta) {
 		sta->flags &= ~WLAN_STA_PENDING_FILS_ERP;
 		sta->ft_over_ds = 0;
@@ -3220,6 +3261,10 @@ static void handle_auth(struct hostapd_data *hapd,
 		}
 	}
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	mxl_auth_parse_ml_ie(hapd, mgmt, len, sta);
+#endif
+
 	switch (auth_alg) {
 	case WLAN_AUTH_OPEN:
 		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
@@ -3846,6 +3891,17 @@ static u16 owe_process_assoc_req(struct hostapd_data *hapd,
 
 	wpa_hexdump_key(MSG_DEBUG, "OWE: PMK", sta->owe_pmk, sta->owe_pmk_len);
 	wpa_hexdump(MSG_DEBUG, "OWE: PMKID", pmkid, PMKID_LEN);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	u8 *spa_addr;
+	/* If the ML STA supports more than one link, add the same PMK in each link's PMK cache. */
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		spa_addr = sta->mxl_sta_info.non_ap_mld_mac;
+		if (sta->mxl_sta_info.linked_sta) {
+			wpa_auth_pmksa_add2(hapd->mxl_data.sibling_hapd->wpa_auth, spa_addr, sta->owe_pmk,
+					    sta->owe_pmk_len, pmkid, 0, WPA_KEY_MGMT_OWE, NULL);
+		}
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	wpa_auth_pmksa_add2(hapd->wpa_auth, sta->addr, sta->owe_pmk,
 			    sta->owe_pmk_len, pmkid, 0, WPA_KEY_MGMT_OWE, NULL);
 
@@ -3912,6 +3968,11 @@ u16 owe_process_rsn_ie(struct hostapd_data *hapd,
 	if (!sta->wpa_sm)
 		sta->wpa_sm = wpa_auth_sta_init(hapd->wpa_auth,	sta->addr,
 						NULL);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta))
+		mxl_wpa_mld_auth_sta_init(sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 	if (!sta->wpa_sm) {
 		wpa_printf(MSG_WARNING,
 			   "OWE: Failed to initialize WPA state machine");
@@ -4157,14 +4218,22 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 		if (resp != WLAN_STATUS_SUCCESS)
 			return resp;
 
+#ifndef CONFIG_IEEE80211BE_MXL_MLO
 		if (!link) {
 			resp = hostapd_process_ml_assoc_req(hapd, elems, sta);
 			if (resp != WLAN_STATUS_SUCCESS)
 				return resp;
 		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	}
 #endif /* CONFIG_IEEE80211BE */
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	resp = mxl_check_assoc_ie_ml_ie_validate(hapd, sta, elems);
+	if (resp != WLAN_STATUS_SUCCESS)
+		return resp;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef CONFIG_P2P
 	if (elems->p2p && ies && ies_len) {
 		wpabuf_free(sta->p2p_ie);
@@ -4237,6 +4306,10 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 			sta->wpa_sm = wpa_auth_sta_init(hapd->wpa_auth,
 							sta->addr,
 							p2p_dev_addr);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+			if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta))
+				mxl_wpa_mld_auth_sta_init(sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 			if (!sta->wpa_sm) {
 				wpa_printf(MSG_WARNING,
@@ -4275,6 +4348,15 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 		else
 			sta->flags &= ~WLAN_STA_MFP;
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (mxl_check_assoc_ies_owe(hapd, sta, elems)) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD STA: " MACSTR " trying to associate without WPA3 security",
+				   MAC2STR(sta->addr));
+			return WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef CONFIG_IEEE80211R_AP
 		if (sta->auth_alg == WLAN_AUTH_FT) {
 			if (!reassoc) {
@@ -4297,10 +4379,26 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 #ifdef CONFIG_SAE
 		if (wpa_auth_uses_sae(sta->wpa_sm) && sta->sae &&
 		    sta->sae->state == SAE_ACCEPTED)
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		{
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 			wpa_auth_add_sae_pmkid(sta->wpa_sm, sta->sae->pmkid);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+			/*
+			 * If the ML STA supports more than one link, add the PMK already derived
+			 * using SAE authentication frame exchanges in sibling link PMK cache as well.
+			 */
+			if (mxl_mlo_is_ml_sta(sta) && sta->mxl_sta_info.linked_sta && !link) {
+				mxl_wpa_auth_pmksa_add_sae_sibling(hapd->mxl_data.sibling_hapd->wpa_auth, sta->mxl_sta_info.non_ap_mld_mac,
+						    sta->sae->pmk, sta->sae->pmk_len,
+						    sta->sae->pmkid, sta->sae->akmp);
+			}
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 		if (wpa_auth_uses_sae(sta->wpa_sm) &&
 		    sta->auth_alg == WLAN_AUTH_OPEN) {
+#ifndef CONFIG_VENDOR_MXL
 			struct rsn_pmksa_cache_entry *sa;
 			sa = wpa_auth_sta_get_pmksa(sta->wpa_sm);
 			if (!sa || !wpa_key_mgmt_sae(sa->akmp)) {
@@ -4311,6 +4409,14 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 			}
 			wpa_printf(MSG_DEBUG, "SAE: " MACSTR
 				   " using PMKSA caching", MAC2STR(sta->addr));
+#else /* CONFIG_VENDOR_MXL */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+			if (mxl_pmksa_cache_handle(sta) == WLAN_STATUS_INVALID_PMKID) {
+				return WLAN_STATUS_INVALID_PMKID;
+			}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+#endif /* CONFIG_VENDOR_MXL */
+
 		} else if (wpa_auth_uses_sae(sta->wpa_sm) &&
 			   sta->auth_alg != WLAN_AUTH_SAE &&
 			   !(sta->auth_alg == WLAN_AUTH_FT &&
@@ -4337,10 +4443,20 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 		if ((hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) &&
 		    wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_OWE &&
 		    elems->owe_dh) {
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+			/*
+			 * Skip processing the OWE DH IE for the affiliated sta from
+			 * multilink per-sta profile IE.
+			 */
+			if (!link) {
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 			resp = owe_process_assoc_req(hapd, sta, elems->owe_dh,
 						     elems->owe_dh_len);
 			if (resp != WLAN_STATUS_SUCCESS)
 				return resp;
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+			}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		}
 #endif /* CONFIG_OWE */
 	skip_sae_owe:
@@ -4839,6 +4955,12 @@ static int add_associated_sta(struct hostapd_data *hapd,
 	const u8 *mld_link_addr = NULL;
 	bool mld_link_sta = false;
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		return WLAN_STATUS_SUCCESS;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap && sta->mld_info.mld_sta) {
 		u8 mld_link_id = hapd->mld_link_id;
@@ -4989,6 +5111,13 @@ static u16 send_assoc_resp(struct hostapd_data *hapd, struct sta_info *sta,
 	}
 #endif /* CONFIG_IEEE80211BE */
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sta && mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		buflen += MULTILINK_IE_LEN;
+		if (sta->mxl_sta_info.linked_sta)
+			buflen += PER_STA_PROFILE_LENGTH;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	buf = os_zalloc(buflen);
 	if (!buf) {
 		res = WLAN_STATUS_UNSPECIFIED_FAILURE;
@@ -5212,6 +5341,14 @@ rsnxe_done:
 	if (sta && (sta->flags & WLAN_STA_WMM))
 		p = hostapd_eid_wmm(hapd, p);
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	p = mxl_assoc_add_ml_ie(hapd, sta, p, reply, sta->mxl_sta_info.sta_profile_status);
+	if (!p) {
+		res = WLAN_STATUS_UNSPECIFIED_FAILURE;
+		goto done;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef CONFIG_WPS
 	if (sta &&
 	    ((sta->flags & WLAN_STA_WPS) ||
@@ -5303,6 +5440,12 @@ rsnxe_done:
 	}
 #endif /* CONFIG_FILS */
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (reassoc) {
+		mxl_mlo_reassoc_notify(hapd, sta);
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 	if (hostapd_drv_send_mlme(hapd, reply, send_len, 0, NULL, 0, 0) < 0) {
 		wpa_printf(MSG_INFO, "Failed to send assoc resp: %s",
 			   strerror(errno));
@@ -5573,6 +5716,10 @@ static void handle_assoc(struct hostapd_data *hapd,
 		}
 	}
 #endif /* CONFIG_IEEE80211BE */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sta)
+		mxl_ml_drv_remove_sta(hapd, sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 #ifdef CONFIG_IEEE80211R_AP
 	if (sta && sta->auth_alg == WLAN_AUTH_FT &&
@@ -5736,6 +5883,11 @@ static void handle_assoc(struct hostapd_data *hapd,
 		goto fail;
 	omit_rsnxe = !get_ie(pos, left, WLAN_EID_RSNX);
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	sta->mxl_sta_info.sta_profile_status = WLAN_STATUS_SUCCESS;
+	if (mxl_mlo_check_assoc_ie(hapd, sta, pos, left, reassoc, capab_info))
+		goto fail;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #ifdef CONFIG_VENDOR_MXL
 	if (!mxl_hostapd_check_softblock_connect(hapd, mgmt->sa, &resp))
 		goto fail;
@@ -5835,6 +5987,11 @@ static void handle_assoc(struct hostapd_data *hapd,
 	 * remove the STA immediately. */
 	sta->timeout_next = STA_NULLFUNC;
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_mlo_update_last_assoc_req(hapd, sta, mgmt, len))
+		goto fail;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef CONFIG_TAXONOMY
 	taxonomy_sta_info_assoc_req(hapd, sta, pos, left);
 #endif /* CONFIG_TAXONOMY */
@@ -5982,6 +6139,9 @@ static void hostapd_deauth_sta(struct hostapd_data *hapd,
 		hapd, sta, le_to_host16(mgmt->u.deauth.reason_code));
 	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
 	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+#ifdef CONFIG_VENDOR_MXL
+	return mxl_free_sta(hapd, sta);
+#endif /* CONFIG_VENDOR_MXL */
 	ap_free_sta(hapd, sta);
 }
 
@@ -6015,6 +6175,9 @@ static void hostapd_disassoc_sta(struct hostapd_data *hapd,
 	ap_sta_ip6addr_del(hapd, sta);
 	hostapd_drv_sta_remove(hapd, sta->addr);
 	sta->added_unassoc = 0;
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	mxl_hostapd_free_aid(hapd,sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 	if (sta->timeout_next == STA_NULLFUNC ||
 	    sta->timeout_next == STA_DISASSOC) {
@@ -6027,6 +6190,10 @@ static void hostapd_disassoc_sta(struct hostapd_data *hapd,
 	mlme_disassociate_indication(
 		hapd, sta, le_to_host16(mgmt->u.disassoc.reason_code));
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	mxl_free_sta_profile(hapd, sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 	/* DMG/IEEE 802.11ad does not use deauthication. Deallocate sta upon
 	 * disassociation. */
 	if (hapd->iface->current_mode &&
@@ -6625,12 +6792,20 @@ int ieee802_11_mgmt(struct hostapd_data *hapd, const u8 *buf, size_t len,
 		break;
 	case WLAN_FC_STYPE_DISASSOC:
 		wpa_printf(MSG_DEBUG, "mgmt::disassoc");
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		mxl_mlo_handle_disassoc(hapd, mgmt, len);
+#else /* CONFIG_IEEE80211BE_MXL_MLO */
 		handle_disassoc(hapd, mgmt, len);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		ret = 1;
 		break;
 	case WLAN_FC_STYPE_DEAUTH:
 		wpa_msg(hapd->msg_ctx, MSG_DEBUG, "mgmt::deauth");
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		mxl_mlo_handle_deauth(hapd, mgmt, len);
+#else /* CONFIG_IEEE80211BE_MXL_MLO */
 		handle_deauth(hapd, mgmt, len);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		ret = 1;
 		break;
 	case WLAN_FC_STYPE_ACTION:
@@ -6890,7 +7065,6 @@ static void handle_assoc_cb(struct hostapd_data *hapd,
 			       HOSTAPD_LEVEL_DEBUG,
 			       "did not acknowledge association response");
 		sta->flags &= ~WLAN_STA_ASSOC_REQ_OK;
-		/* The STA is added only in case of SUCCESS */
 		if (status == WLAN_STATUS_SUCCESS)
 			hostapd_drv_sta_remove(hapd, sta->addr);
 
@@ -6909,6 +7083,12 @@ static void handle_assoc_cb(struct hostapd_data *hapd,
 		       "associated (aid %d)",
 		       sta->aid);
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		mxl_mlo_add_associated_sta(hapd, sta, reassoc);
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 	if (sta->flags & WLAN_STA_ASSOC)
 		new_assoc = 0;
 	sta->flags |= WLAN_STA_ASSOC;
@@ -6931,6 +7111,13 @@ static void handle_assoc_cb(struct hostapd_data *hapd,
 		ap_sta_set_authorized(hapd, sta, 0);
 	}
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && hapd->mxl_data.sibling_hapd) {
+		if (sta->mxl_sta_info.linked_sta) {
+			sta->mxl_sta_info.linked_sta->flags |= WLAN_STA_ASSOC;
+		}
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	if (reassoc)
 		mlme_reassociate_indication(hapd, sta);
 	else
@@ -6986,6 +7173,14 @@ static void handle_assoc_cb(struct hostapd_data *hapd,
 	hapd->new_assoc_sta_cb(hapd, sta, !new_assoc);
 	ieee802_1x_notify_port_enabled(sta->eapol_sm, 1);
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && sta->mxl_sta_info.linked_sta && hapd->mxl_data.sibling_hapd &&
+			mxl_mlo_is_ml_sta(sta)) {
+		sta->mxl_sta_info.linked_sta->added_unassoc = 0;
+		ieee802_1x_notify_port_enabled(sta->mxl_sta_info.linked_sta->eapol_sm, 1);
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef CONFIG_FILS
 	if ((sta->auth_alg == WLAN_AUTH_FILS_SK ||
 	     sta->auth_alg == WLAN_AUTH_FILS_SK_PFS ||
@@ -7036,6 +7231,13 @@ static void handle_deauth_cb(struct hostapd_data *hapd,
 			   " not found", MAC2STR(mgmt->da));
 		return;
 	}
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sta->mxl_sta_info.ext_flags & WLAN_STA_MLD_STA) {
+		mxl_mlo_handle_deauth_cb(hapd, mgmt, len, ok);
+		return;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	if (ok)
 		wpa_printf(MSG_DEBUG, "STA " MACSTR " acknowledged deauth",
 			   MAC2STR(sta->addr));
@@ -8489,4 +8691,25 @@ u16 mxl_copy_supp_rates(struct hostapd_data *hapd, struct sta_info *sta,
 {
 	return copy_supp_rates(hapd, sta, elems);
 }
+void mxl_handle_disassoc(struct hostapd_data *hapd,
+				const struct ieee80211_mgmt *mgmt, size_t len)
+{
+	return handle_disassoc(hapd, mgmt, len);
+}
+void mxl_handle_deauth(struct hostapd_data *hapd,
+				const struct ieee80211_mgmt *mgmt, size_t len)
+{
+	return handle_deauth(hapd, mgmt, len);
+}
+void mxl_hostapd_set_wds_encryption(struct hostapd_data *hapd,
+					struct sta_info *sta,
+					char *ifname_wds)
+{
+	return hostapd_set_wds_encryption(hapd, sta, ifname_wds);
+}
+int mxl_check_linked_sta_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
+				struct ieee802_11_elems *elems, int reassoc)
+{
+	return __check_assoc_ies(hapd, sta, NULL, 0, elems, reassoc, true);
+}
 #endif /* CONFIG_VENDOR_MXL */
diff --git a/src/ap/ieee802_11_eht.c b/src/ap/ieee802_11_eht.c
index 008f701c9..848fa0b2c 100644
--- a/src/ap/ieee802_11_eht.c
+++ b/src/ap/ieee802_11_eht.c
@@ -1412,3 +1412,18 @@ out:
 
 	return WLAN_STATUS_SUCCESS;
 }
+
+#ifdef CONFIG_VENDOR_MXL
+const u8 * mxl_auth_skip_fixed_fields(struct hostapd_data *hapd,
+					const struct ieee80211_mgmt *mgmt,
+					size_t len)
+{
+	u16 auth_alg = le_to_host16(mgmt->u.auth.auth_alg);
+
+	if ((auth_alg == WLAN_AUTH_FILS_SK) || (auth_alg == WLAN_AUTH_FILS_SK_PFS)) {
+		return mgmt->u.auth.variable;
+	}
+
+	return auth_skip_fixed_fields(hapd, mgmt, len);
+}
+#endif /* CONFIG_VENDOR_MXL */
diff --git a/src/ap/mxl_config.h b/src/ap/mxl_config.h
index 49c0e4c59..9f9280a11 100644
--- a/src/ap/mxl_config.h
+++ b/src/ap/mxl_config.h
@@ -280,6 +280,10 @@ typedef struct colocated_6g_ap_info {
 #define EML_CAPAB_TRANSITION_TIMEOUT_MAX 11
 #define EML_CAPAB_TRANSITION_TIMEOUT_DEFAULT 4 /* 1TU default transition timeout */
 
+#define MLO_MEDIUM_SYNC_DURATION_MAX (UINT8_MAX)
+#define MLO_MEDIUM_SYNC_OFDMED_THRESH_MAX 10
+#define MLO_MEDIUM_SYNC_MAXTXOP_MAX 15
+
 typedef u8 macaddr[ETH_ALEN];
 
 #define PROBE_REQUEST_TIME_MIN 0
@@ -373,6 +377,7 @@ struct mxl_hostapd_bss_config {
 	u8 mld_mediumsync_ofdmedthresh;
 	u8 mld_mediumsync_maxtxop;
 	u8 mld_bpcc_count;
+	bool mlo_t2lm_support; /* tid to link mapping negotiation support */
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	int rnr_auto_update;
 };
diff --git a/src/ap/mxl_drv_callbacks.c b/src/ap/mxl_drv_callbacks.c
new file mode 100644
index 000000000..8f61480ff
--- /dev/null
+++ b/src/ap/mxl_drv_callbacks.c
@@ -0,0 +1,89 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "radius/radius.h"
+#include "drivers/driver.h"
+#include "common/hw_features_common.h"
+#include "hostapd.h"
+#include "ieee802_1x.h"
+#include "wpa_auth.h"
+#include "ap_drv_ops.h"
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+void mxl_hostapd_notif_disassoc(struct hostapd_data *hapd, const u8 *addr)
+{
+	struct sta_info *sta = NULL;
+	struct sta_info *sta1 = NULL;
+	struct hostapd_data *hapd1 = NULL;
+
+	if (addr == NULL) {
+		/*
+		 * This could potentially happen with unexpected event from the
+		 * driver wrapper. This was seen at least in one case where the
+		 * driver ended up reporting a station mode event while hostapd
+		 * was running, so better make sure we stop processing such an
+		 * event here.
+		 */
+		wpa_printf(MSG_DEBUG,
+			   "hostapd_notif_disassoc: Skip event with no address");
+		return;
+	}
+
+	hostapd_logger(hapd, addr, HOSTAPD_MODULE_IEEE80211,
+		       HOSTAPD_LEVEL_INFO, "disassociated");
+
+	sta = ap_get_sta(hapd, addr);
+	if (sta == NULL) {
+		wpa_printf(MSG_DEBUG,
+			   "Disassociation notification for unknown STA "
+			   MACSTR, MAC2STR(addr));
+		return;
+	}
+
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+	}
+
+	sta->flags &= ~WLAN_STA_BSS_TRANS_MGMT_REQ_TIMEOUT;
+	/* until required details is made available driver,
+	 * set reason and source values to unspecified and local respectively */
+	sta->disassoc_reason = WLAN_REASON_UNSPECIFIED;
+	sta->disconnect_source = DISCONNECT_SOURCE_LOCAL;
+	ap_sta_set_authorized(hapd, sta, 0);
+	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);
+	hostapd_set_sta_flags(hapd, sta);
+	wpa_auth_sm_event(sta->wpa_sm, WPA_DISASSOC);
+	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
+	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		sta1 = sta->mxl_sta_info.linked_sta;
+	}
+	if (hapd1 && sta1) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		sta1->flags &= ~WLAN_STA_BSS_TRANS_MGMT_REQ_TIMEOUT;
+		/* until required details is made available driver,
+		 * set reason and source values to unspecified and local respectively */
+		sta1->disassoc_reason = WLAN_REASON_UNSPECIFIED;
+		sta1->disconnect_source = DISCONNECT_SOURCE_LOCAL;
+		ap_sta_set_authorized(hapd1, sta1, 0);
+		sta1->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);
+		hostapd_set_sta_flags(hapd1, sta1);
+		wpa_auth_sm_event(sta1->wpa_sm, WPA_DISASSOC);
+		sta1->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
+		ieee802_1x_notify_port_enabled(sta1->eapol_sm, 0);
+		ap_free_sta(hapd1, sta1);
+	}
+	ap_free_sta(hapd, sta);
+}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
diff --git a/src/ap/mxl_drv_callbacks.h b/src/ap/mxl_drv_callbacks.h
new file mode 100644
index 000000000..44445096f
--- /dev/null
+++ b/src/ap/mxl_drv_callbacks.h
@@ -0,0 +1,16 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#ifndef MXL_DRV_CALLBACKS_H
+#define MXL_DRV_CALLBACKS_H
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+void mxl_hostapd_notif_disassoc(struct hostapd_data *hapd, const u8 *addr);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+#endif /* MXL_DRV_CALLBACKS_H */
diff --git a/src/ap/mxl_hostapd.c b/src/ap/mxl_hostapd.c
index 824e1f594..fe95e6737 100644
--- a/src/ap/mxl_hostapd.c
+++ b/src/ap/mxl_hostapd.c
@@ -29,6 +29,7 @@
 #include "common/wpa_ctrl.h"
 #include "mxl_beacon.h"
 #include "mxl_wpa_auth.h"
+#include "mxl_sta_info.h"
 
 #define COC_POWER_1x1_STATE 1
 #define COC_POWER_2x2_STATE 2
@@ -63,6 +64,32 @@ static void ap_sta_remove_in_other_bss_now(struct hostapd_data *hapd, struct sta
 	}
 }
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+void mxl_hostapd_ml_sta_info_set(struct sta_info *sta, struct ieee80211_ml_sta_info ml_sta_info)
+{
+	sta->mxl_sta_info.ml_sta_info = ml_sta_info;
+}
+
+static struct ieee80211_ml_sta_info * mxl_hostapd_ml_sta_info_get(struct hostapd_data *hapd, const u8 *addr)
+{
+	struct sta_info *sta = ap_get_sta(hapd, addr);
+
+	if (!sta) {
+		wpa_printf(MSG_DEBUG, "STA " MACSTR "not found", MAC2STR(addr));
+		return NULL;
+	}
+
+	return &(sta->mxl_sta_info.ml_sta_info);
+}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
+void mxl_hostapd_sta_add_params(struct hostapd_data *hapd, struct hostapd_sta_add_params *params)
+{
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	params->mxl_params.ml_sta_info = mxl_hostapd_ml_sta_info_get(hapd, params->addr);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+}
+
 int mxl_hostapd_get_aid(struct hostapd_data *hapd, struct sta_info *sta)
 {
 	struct mxl_hostapd_iface *mxl_iface = &hapd->iface->mxl_iface;
@@ -88,6 +115,14 @@ int mxl_hostapd_get_aid(struct hostapd_data *hapd, struct sta_info *sta)
 		if (TEST_FAIL())
 			return -1;
 #endif
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+			aid_offset = MXL_ML_AID_OFFSET;
+			aid_words = ML_AID_WORDS;
+			aid_max = MXL_ML_AID_MAX;
+			aid_pool = hapd->iface->interfaces->mxl_interfaces.non_ap_mld_aid;
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 		for (i = 0; i < aid_words; i++) {
 			if (aid_pool[i] == (u32) -1)
@@ -107,31 +142,131 @@ int mxl_hostapd_get_aid(struct hostapd_data *hapd, struct sta_info *sta)
 			return -1;
 		sta->aid = aid;
 		aid_pool[i] |= BIT(j);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (sta->mxl_sta_info.linked_sta && mxl_mlo_is_ml_sta(sta))
+			sta->mxl_sta_info.linked_sta->aid = aid;
+
+		if (hapd->iconf->ieee80211be && hapd->iconf->mxl_conf.mlo_supported) {
+			/* Legacy Association */
+			/* We need SID to be derived the legacy way */
+			if (!(mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta))) {
+				if (hapd->driver->get_aid) {
+					u16 sid = 0;
+					struct mxl_ml_sta_info *ml_sta_info = os_malloc(sizeof(struct mxl_ml_sta_info));
+					if (!ml_sta_info)
+						return -1;
+					ap_sta_remove_in_other_bss_now(hapd, sta);
+					res = (*hapd->driver->get_aid)(hapd->drv_priv, &sid, sta->addr);
+					if (res) {
+						wpa_printf(MSG_ERROR, "get_aid failed for station " MACSTR, MAC2STR(sta->addr));
+						os_free(ml_sta_info);
+						return res;
+					}
+					/* set SID for the WAVE700 legacy STA */
+					/* Using the same ML wrapper to set SID-AID mapping*/
+					memcpy_s(ml_sta_info->addr, ETH_ALEN, sta->addr, ETH_ALEN);
+					ml_sta_info->sid = sid;
+					ml_sta_info->aid = sta->aid;
+					res = MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_ML_SID, ml_sta_info, sizeof(*ml_sta_info));
+					if (res) {
+						wpa_printf(MSG_ERROR, "SET_ML_SID failed");
+						os_free(ml_sta_info);
+						return res;
+					}
+
+					os_free(ml_sta_info);
+				}
+			} else {
+				/* ML request SID */
+				struct mxl_vendor_ml_sid ml_sid = {0};
+				struct mxl_ml_sta_mac_addr ml_sta_mac = {0}; /*= os_malloc(sizeof( struct mxl_ml_sta_mac_addr));*/
+				struct mxl_ml_sta_info ml_sta_info;/* = os_malloc(sizeof(ml_sta_info));*/
+
+				if (hapd->conf->mxl_bss_conf.link_id == LINK_ID_2G) {
+					ml_sta_mac.assoc_link_bitmap |= 1 << LINK_ID_2G;
+					memcpy_s(ml_sta_mac.addr1, ETH_ALEN, sta->addr, ETH_ALEN);
+				}
+				if (hapd->conf->mxl_bss_conf.link_id == LINK_ID_5G) {
+					ml_sta_mac.assoc_link_bitmap |= 1 << LINK_ID_5G;
+					memcpy_s(ml_sta_mac.addr2, ETH_ALEN, sta->addr, ETH_ALEN);
+				}
+				if (hapd->conf->mxl_bss_conf.link_id == LINK_ID_6G) {
+					ml_sta_mac.assoc_link_bitmap |= 1 << LINK_ID_6G;
+					memcpy_s(ml_sta_mac.addr3, ETH_ALEN, sta->addr, ETH_ALEN);
+				}
+				if(sta->mxl_sta_info.linked_sta) {
+					if (hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.link_id == LINK_ID_2G) {
+						ml_sta_mac.assoc_link_bitmap |= 1 << LINK_ID_2G;
+						memcpy_s(ml_sta_mac.addr1, ETH_ALEN, sta->mxl_sta_info.linked_sta->addr, ETH_ALEN);
+					}
+					if (hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.link_id == LINK_ID_5G) {
+						ml_sta_mac.assoc_link_bitmap |= 1 << LINK_ID_5G;
+						memcpy_s(ml_sta_mac.addr2, ETH_ALEN, sta->mxl_sta_info.linked_sta->addr, ETH_ALEN);
+					}
+					if (hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.link_id == LINK_ID_6G) {
+						ml_sta_mac.assoc_link_bitmap |= 1 << LINK_ID_6G;
+						memcpy_s(ml_sta_mac.addr3, ETH_ALEN, sta->mxl_sta_info.linked_sta->addr, ETH_ALEN);
+					}
+				}
 
-		if (hapd->driver->get_aid) {
-			u16 sid = 0;
-			struct mxl_ml_sta_info ml_sta_info = { 0 };
-			ap_sta_remove_in_other_bss_now(hapd, sta);
-			res = (*hapd->driver->get_aid)(hapd->drv_priv, &sid, sta->addr);
-			if (res) {
-				wpa_printf(MSG_ERROR, "get_aid failed");
-				return res;
-			}
-			/* set SID for the WAVE700 legacy STA */
-			/* Using the same ML wrapper to set SID-AID mapping */
-			os_memcpy(ml_sta_info.addr, sta->addr, ETH_ALEN);
-			ml_sta_info.sid = sid;
-			ml_sta_info.aid = sta->aid;
-			res = MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_ML_SID, &ml_sta_info, sizeof(ml_sta_info));
-			if (res) {
-				wpa_printf(MSG_ERROR, "SET_ML_SID failed");
-				return res;
+				if (MXL_DRV_VENDOR_GET(LTQ_NL80211_VENDOR_SUBCMD_REQUEST_ML_SID, &ml_sta_mac,
+							sizeof(ml_sta_mac), &ml_sid, sizeof(ml_sid))) {
+					wpa_printf(MSG_ERROR, "Failed request SID for ML STA");
+					return -1;
+				}
+
+				/* set SID for the STA1 */
+				memcpy_s(ml_sta_info.addr, ETH_ALEN, sta->addr, ETH_ALEN);
+				ml_sta_info.sid = ml_sid.sid[hapd->conf->mxl_bss_conf.link_id];
+				ml_sta_info.aid = sta->aid;
+				if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_ML_SID, &ml_sta_info, sizeof(ml_sta_info))) {
+					wpa_printf(MSG_ERROR, "SET_ML_SID failed");
+					return res;
+				}
+				/* set SID for the affiliated STA */
+				if(sta->mxl_sta_info.linked_sta && hapd->mxl_data.sibling_hapd && hapd->mxl_data.sibling_hapd->conf) {
+					os_memset(&ml_sta_info, 0, sizeof(ml_sta_info));
+					memcpy_s(ml_sta_info.addr, ETH_ALEN, sta->mxl_sta_info.linked_sta->addr, ETH_ALEN);
+					ml_sta_info.sid = ml_sid.sid[hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.link_id];
+					ml_sta_info.aid = sta->mxl_sta_info.linked_sta->aid;
+					hapd = hapd->mxl_data.sibling_hapd;
+					if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_ML_SID, &ml_sta_info,
+								sizeof(ml_sta_info))) {
+						wpa_printf(MSG_ERROR, "SET_ML_SID failed");
+						return res;
+					}
+				}
 			}
-			wpa_printf(MSG_ERROR, "  new AID %d", sta->aid);
+			wpa_printf(MSG_DEBUG, "  new AID %d", sta->aid);
 			return 0;
+		} else {
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+			if (hapd->driver->get_aid) {
+				u16 sid = 0;
+				struct mxl_ml_sta_info ml_sta_info = { 0 };
+				ap_sta_remove_in_other_bss_now(hapd, sta);
+				res = (*hapd->driver->get_aid)(hapd->drv_priv, &sid, sta->addr);
+				if (res) {
+					wpa_printf(MSG_ERROR, "get_aid failed");
+					return res;
+				}
+				/* set SID for the WAVE700 legacy STA */
+				/* Using the same ML wrapper to set SID-AID mapping */
+				os_memcpy(ml_sta_info.addr, sta->addr, ETH_ALEN);
+				ml_sta_info.sid = sid;
+				ml_sta_info.aid = sta->aid;
+				if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_SET_ML_SID, &ml_sta_info, sizeof(ml_sta_info))) {
+					wpa_printf(MSG_ERROR, "SET_ML_SID failed");
+					return res;
+				}
+				wpa_printf(MSG_ERROR, "  new AID %d", sta->aid);
+				return 0;
+			}
+			wpa_printf(MSG_ERROR, "get AID failed for EHT STA");
+			return -1;
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
 		}
-		wpa_printf(MSG_ERROR, "get AID failed for EHT STA");
-		return -1;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	}
 
 	if (hapd->driver->get_aid) {
@@ -160,6 +295,12 @@ void mxl_hostapd_free_aid(struct hostapd_data *hapd, struct sta_info *sta)
 		/* New AID scheme + MultiLink */
 		int aid_offset = MXL_AID_OFFSET;
 		u32 *aid_pool = mxl_iface->sta_aid_link;
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+			aid_offset = MXL_ML_AID_OFFSET;
+			aid_pool = hapd->iface->interfaces->mxl_interfaces.non_ap_mld_aid;
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		aid_pool[(sta->aid - aid_offset - 1) / 32]
 				&= ~BIT((sta->aid - aid_offset - 1) % 32);
 		/* Free SID */
@@ -2342,8 +2483,43 @@ int mxl_update_rnr_check(struct hostapd_iface *iface)
 }
 
 #ifdef CONFIG_IEEE80211BE_MXL_MLO
+void mxl_hostapd_ml_sta_stop_traffic(struct hostapd_iface *iface, unsigned int idx)
+{
+	struct hostapd_data *hapd, *hapd1;
+	struct sta_info *sta;
+
+	hapd = iface->bss[idx];
+	sta = hapd->sta_list;
+
+	if (sta == NULL) {
+		wpa_printf(MSG_INFO, "STA list is empty");
+	}
+
+	while (sta) {
+		wpa_printf(MSG_INFO, "%s removing STA", __func__);
+		if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+			mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+		}
+		sta = sta->next;
+	}
+	hapd1 = hapd->mxl_data.sibling_hapd;
+	if (hapd1 == NULL)
+		return;
+
+	hapd = hapd1;
+	sta = hapd->sta_list;
+	while (sta) {
+		wpa_printf(MSG_INFO, "%s removing linked STA", __func__);
+		if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+			mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+		}
+		sta = sta->next;
+	}
+}
+
 void mxl_hostapd_remove_mld_vap(struct hostapd_iface *iface, unsigned int idx)
 {
+	mxl_hostapd_ml_sta_stop_traffic(iface, idx);
 	hostapd_free_stas(iface->bss[idx]);
 	hostapd_free_stas(iface->bss[idx]->mxl_data.sibling_hapd);
 	mxl_hostapd_mld_remove(iface->bss[idx], 0);
diff --git a/src/ap/mxl_hostapd.h b/src/ap/mxl_hostapd.h
index 33edd4d0f..64c283999 100644
--- a/src/ap/mxl_hostapd.h
+++ b/src/ap/mxl_hostapd.h
@@ -29,6 +29,11 @@
 #define MXL_AID_RANGE			256
 #define MXL_AID_WORDS	((MXL_AID_RANGE + 31) / 32)
 
+#define MXL_6G_AID_MAX                  MXL_AID_MAX
+#define MXL_ML_AID_OFFSET               63
+#define MXL_ML_AID_MAX                  191
+#define MXL_ML_AID_RANGE                128
+
 /* STAs free reason - Recovery */
 #define MXL_STA_FREE_REASON_RECOVERY (-1)
 #define MXL_FLUSH_RADIO (-1)
@@ -193,6 +198,8 @@ void mxl_mlo_hostapd_interface_deinit(struct hostapd_iface *iface);
 void mxl_hostapd_remove_mld_vap(struct hostapd_iface *iface, unsigned int idx);
 int mxl_hostapd_deinit_gmld(struct hostapd_data *hapd);
 int mxl_mld_setup_interfaces (struct hapd_interfaces *interfaces);
+void mxl_hostapd_ml_sta_info_set(struct sta_info *sta, struct ieee80211_ml_sta_info ml_sta_info);
+void mxl_hostapd_sta_add_params(struct hostapd_data *hapd, struct hostapd_sta_add_params *params);
 void mxl_hostapd_deinit_mld_params(struct hostapd_data *hapd);
 int mxl_hostapd_remove_iface(struct hostapd_iface *hapd_iface, unsigned int j);
 void mxl_channel_list_update_timeout(void *eloop_ctx, void *timeout_ctx);
@@ -204,4 +211,16 @@ int mxl_hostapd_send_protected_deauth(struct hostapd_data *hapd, int reason);
 int mxl_hostapd_send_protected_disassoc(struct hostapd_data *hapd, int reason);
 bool mxl_hostapd_check_non_inherit_rsnxe(struct hostapd_data *bss);
 u8 * mxl_hostapd_eid_non_inheritance(struct hostapd_data *hapd, u8 *eid, bool is_beacon);
+void mxl_handle_disassoc(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len);
+void mxl_handle_deauth(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len);
+void mxl_hostapd_set_wds_encryption(struct hostapd_data *hapd,
+					struct sta_info *sta,
+					char *ifname_wds);
+int mxl_check_linked_sta_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
+				struct ieee802_11_elems *elems, int reassoc);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+void mxl_mlo_cleanup_mld_sta(struct hostapd_data *hapd, struct sta_info *sta);
+void mxl_mlo_hostapd_prune_associations_mld_mac(struct hostapd_data *hapd, struct sta_info *new_sta);
+void mxl_mlo_hostapd_prune_associations_mld(struct hostapd_data *hapd, const u8 *addr);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #endif /* MXL_HOSTAPD_H */
diff --git a/src/ap/mxl_ieee802_11.c b/src/ap/mxl_ieee802_11.c
index a68499db8..75086b4db 100644
--- a/src/ap/mxl_ieee802_11.c
+++ b/src/ap/mxl_ieee802_11.c
@@ -13,20 +13,66 @@
 #ifndef CONFIG_NATIVE_WINDOWS
 
 #include "utils/common.h"
+#include "utils/eloop.h"
+#include "crypto/crypto.h"
+#include "crypto/sha256.h"
+#include "crypto/sha384.h"
+#include "crypto/sha512.h"
+#include "crypto/random.h"
 #include "common/ieee802_11_defs.h"
 #include "common/ieee802_11_common.h"
+#include "common/wpa_ctrl.h"
+#include "common/sae.h"
+#include "common/dpp.h"
+#include "common/ocv.h"
+#include "common/wpa_common.h"
+#include "common/wpa_ctrl.h"
+#include "common/ptksa_cache.h"
+#include "radius/radius.h"
+#include "radius/radius_client.h"
+#include "p2p/p2p.h"
+#include "wps/wps.h"
+#include "fst/fst.h"
 #include "hostapd.h"
+#include "beacon.h"
+#include "ieee802_11_auth.h"
+#include "sta_info.h"
+#include "ieee802_1x.h"
+#include "wpa_auth.h"
+#include "pmksa_cache_auth.h"
+#include "wmm.h"
+#include "ap_list.h"
+#include "accounting.h"
 #include "ap_config.h"
 #include "sta_info.h"
 #include "beacon.h"
+#include "ap_mlme.h"
+#include "p2p_hostapd.h"
+#include "ap_drv_ops.h"
+#include "wnm_ap.h"
+#include "hw_features.h"
 #include "ieee802_11.h"
 #include "dfs.h"
 
 #ifdef CONFIG_VENDOR_MXL
+#include "mbo_ap.h"
+#include "rrm.h"
+#include "taxonomy.h"
+#include "fils_hlp.h"
+#include "dpp_hostapd.h"
+#include "gas_query_ap.h"
+#include "comeback_token.h"
+#include "pasn/pasn_common.h"
 #include "mxl_hostapd.h"
 #include "mxl_coexistence.h"
 #include "mxl_ieee802_11.h"
 #endif /* CONFIG_VENDOR_MXL */
+#include "wpa_auth_i.h"
+#include "mxl_sta_info.h"
+#include "mxl_ieee802_11_eht.h"
+#ifdef CONFIG_WDS_WPA
+#include "wds_wpa.h"
+#endif
 
 u8 * hostapd_eid_txpower_envelope_vendor_mxl_6g(struct hostapd_data *hapd, u8 *eid, bool only_one_psd_limit)
 {
@@ -243,4 +289,740 @@ u8 * hostapd_eid_txpower_envelope_vendor_mxl(struct hostapd_data *hapd, u8 *eid)
 				REG_DEFAULT_CLIENT,
 				tx_pwr);
 }
+
+
+void mxl_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
+{
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+   mxl_free_sta_profile(hapd, sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+   mxl_cache_sta_deauth(hapd, sta);
+}
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+int check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
+		const u8 *ies, size_t ies_len, int reassoc);
+
+size_t mxl_ml_auth_len(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	if (sta && mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		/* No Link info, eml capab, mld capab and BSS parameter change field */
+		return (MULTILINK_IE_LEN_AUTH + 2);
+	}
+	return 0;
+}
+
+u16 mxl_check_assoc_ie_ml_ie_validate(struct hostapd_data *hapd, struct sta_info *sta, struct ieee802_11_elems *elems)
+{
+	int resp;
+
+	if (mxl_mlo_is_ml_sta(sta) && !sta->mxl_sta_info.sta_profile_ie) {
+		if (!mxl_is_mlo_enabled(hapd->conf)) {
+			wpa_printf(MSG_ERROR, "Recieved Multi_Link IE in non-ML bss, Error!!!");
+			return WLAN_STATUS_UNSPECIFIED_FAILURE;
+		}
+		if (elems->multilink_ie && (elems->multilink_ie_len >= MIN_BASIC_MULTILINK_IE_LEN)) {
+			sta->mxl_sta_info.linked_sta = NULL;
+			sta->mxl_sta_info.sta_profile_ie = NULL;
+			sta->mxl_sta_info.sta_profile_ie_len = 0;
+			resp = mxl_multilink_ie_validate(hapd, sta, elems->multilink_ie, elems->multilink_ie_len);
+			if (resp != WLAN_STATUS_SUCCESS)
+				return resp;
+		} else {
+			wpa_printf(MSG_ERROR, "Multilink STA: but no Multilink IE present!!!");
+			return WLAN_STATUS_UNSPECIFIED_FAILURE;
+		}
+	}
+
+	return WLAN_STATUS_SUCCESS;
+}
+
+void mxl_auth_hostapd_eid_multilink(struct hostapd_data *hapd, struct sta_info *sta, u8 *eid)
+{
+	if (sta && mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		mxl_hostapd_eid_multilink(hapd, sta, eid, ML_BASIC, WLAN_STATUS_SUCCESS, true, false);
+	}
+}
+
+int mxl_mlo_sae_prepare_commit_pt(struct hostapd_data *hapd, struct sta_info *sta, const struct sae_pt *pt, const struct sae_pk *pk)
+{
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		if (sae_prepare_commit_pt(sta->sae, pt, sta->sae->tmp->mxl_sae_tmp_data.own_mld_addr,
+					sta->sae->tmp->mxl_sae_tmp_data.peer_mld_addr, NULL, pk) < 0)
+			return -1;
+	} else {
+		if (sae_prepare_commit_pt(sta->sae, pt, hapd->own_addr, sta->addr,
+					NULL, pk) < 0)
+			return -1;
+	}
+	return 0;
+}
+
+u8 * mxl_assoc_add_ml_ie(struct hostapd_data *hapd, struct sta_info *sta, u8 *p,
+				struct ieee80211_mgmt *reply, u16 link_sta_status)
+{
+	if (sta && mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		if (sta->mxl_sta_info.ext_flags & WLAN_STA_SINGLE_LINK_ML_ASSOC) {
+			p = mxl_hostapd_eid_multilink(hapd, sta, p, ML_BASIC, link_sta_status, false, false);
+		}
+		else if (sta->mxl_sta_info.linked_sta) {
+			p = mxl_hostapd_eid_multilink(hapd, sta, p, ML_ASSOC, link_sta_status, false, false);
+		}
+
+		if (link_sta_status != WLAN_STATUS_SUCCESS)
+			reply->u.assoc_resp.status_code = host_to_le16(link_sta_status);
+	}
+
+	return p;
+}
+
+void mxl_mlo_reassoc_notify(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	if (mxl_is_mlo_enabled(hapd->conf) &&
+			sta && mxl_mlo_is_ml_sta(sta) &&
+			(sta->flags & WLAN_STA_ASSOC)) {
+		struct mxl_ml_sta_reassoc_notify reassoc_notify;
+
+		reassoc_notify.aid = sta->aid;
+		/*
+		 * * The current operating ML state (for ex, getting out of EMLSR) of this ML STA has
+		 * * to be cleanup in the firmware before sending reassoc resp. Notify reassoc incident
+		 * * to FW.
+		 * */
+		if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_ML_STA_REASSOC_NOTIFY,
+					(u8 *)&reassoc_notify, sizeof(struct mxl_ml_sta_reassoc_notify))) {
+			/* Irrespective of any errors, send a reassociation response. */
+			wpa_printf(MSG_ERROR, "send LTQ_NL80211_VENDOR_SUBCMD_ML_STA_REASSOC_NOTIFY failed!!!");
+		}
+	}
+}
+
+u16 mxl_mlo_check_assoc_ie(struct hostapd_data *hapd, struct sta_info *sta, const u8 *pos, int left,
+				int reassoc, u16 capab_info)
+{
+	struct ieee802_11_elems elems;
+	struct wpabuf *mlbuf = NULL;
+	u16 status = WLAN_STATUS_SUCCESS;
+
+	/* Copy the IEs from STA to Linked STA if it is present. By default Linked STA will inherit
+	 * all the IEs from STA. Also these IEs will be updated as per the per STA profile
+	 */
+	if (hapd->mxl_data.sibling_hapd && sta->mxl_sta_info.linked_sta) {
+		/* TODO: Use capability info from per-sta profile for linked sta */
+		sta->mxl_sta_info.linked_sta->capability = capab_info;
+
+		if (ieee802_11_parse_elems(pos, left, &elems, 1) == ParseFailed) {
+			wpa_printf(MSG_DEBUG,
+					"MLD: link: Station sent an invalid association request");
+			status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			goto out;
+		}
+
+		mlbuf = ieee802_11_defrag(elems.basic_mle, elems.basic_mle_len, true);
+		if (!mlbuf) {
+			wpa_printf(MSG_DEBUG,
+					"MLD: link: Failed to defrag association request Multi-Link element");
+			status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			goto out;
+		}
+
+		if (ieee802_11_parse_link_assoc_req(pos, left, &elems, mlbuf,
+		    hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.link_id, true) ==
+				ParseFailed) {
+			wpa_printf(MSG_DEBUG,
+					"MLD: link: Failed to parse association request Multi-Link element");
+			status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			goto out;
+		}
+
+		status = mxl_check_linked_sta_assoc_ies(hapd->mxl_data.sibling_hapd, sta->mxl_sta_info.linked_sta,
+		                                        &elems, reassoc);
+		if (status != WLAN_STATUS_SUCCESS) {
+			wpa_printf(MSG_DEBUG, "MLD: link: Element check failed");
+		}
+
+out:
+		wpabuf_free(mlbuf);
+		sta->mxl_sta_info.sta_profile_status = status;
+		wpa_printf(MSG_DEBUG, "MLD: link: status=%u", status);
+	}
+
+	return status;
+}
+
+int mxl_mlo_update_last_assoc_req(struct hostapd_data *hapd, struct sta_info *sta, const struct ieee80211_mgmt *mgmt, size_t len)
+{
+	errno_t err;
+	struct sta_info *sta1;
+
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		sta1 = sta->mxl_sta_info.linked_sta;
+
+		if (sta1) {
+			sta1->listen_interval = sta->listen_interval;
+			if (sta1->last_assoc_req)
+				os_free(sta1->last_assoc_req);
+			sta1->last_assoc_req_len = len;
+			sta1->last_assoc_req = os_malloc(len);
+			if (sta1->last_assoc_req) {
+				err = memcpy_s(sta1->last_assoc_req, len, mgmt, len);
+				if (EOK != err) {
+					wpa_printf(MSG_ERROR, "%s: memcpy_s error %d", __func__, err);
+					return -1;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+static void mxl_mlo_handle_disassoc_linked_sta(struct hostapd_data *hapd,
+						le16 reason_code, struct sta_info *sta)
+{
+	if (sta == NULL) {
+		wpa_printf(MSG_INFO, "Station trying to disassociate, but it is not associated");
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG, "Linked STA disassocation: STA=" MACSTR " reason_code=%d",
+			MAC2STR(sta->addr),
+			le_to_host16(reason_code));
+
+	sta->flags &= ~WLAN_STA_BSS_TRANS_MGMT_REQ_TIMEOUT;
+	sta->disassoc_reason = le_to_host16(reason_code);
+	sta->disconnect_source = DISCONNECT_SOURCE_REMOTE;
+	ap_sta_set_authorized(hapd, sta, 0);
+	sta->last_seq_ctrl = WLAN_INVALID_MGMT_SEQ;
+	sta->flags &= ~(WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK);
+	hostapd_set_sta_flags(hapd, sta);
+	wpa_auth_sm_event(sta->wpa_sm, WPA_DISASSOC);
+	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+			HOSTAPD_LEVEL_INFO, "Linked STA disassociated");
+	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
+	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+	/* Stop Accounting and IEEE 802.1X sessions, but leave the STA
+	 * authenticated. */
+	accounting_sta_stop(hapd, sta);
+	ieee802_1x_free_station(hapd, sta);
+	if (sta->ipaddr)
+		hostapd_drv_br_delete_ip_neigh(hapd, 4, (u8 *) &sta->ipaddr);
+	ap_sta_ip6addr_del(hapd, sta);
+	hostapd_drv_sta_remove(hapd, sta->addr);
+	sta->added_unassoc = 0;
+	mxl_hostapd_free_aid(hapd,sta);
+
+	if (sta->timeout_next == STA_NULLFUNC ||
+			sta->timeout_next == STA_DISASSOC) {
+		sta->timeout_next = STA_DEAUTH;
+		eloop_cancel_timeout(ap_handle_timer, hapd, sta);
+		eloop_register_timeout(AP_DEAUTH_DELAY, 0, ap_handle_timer,
+				hapd, sta);
+	}
+
+	mlme_disassociate_indication(
+			hapd, sta, le_to_host16(reason_code));
+
+	/* DMG/IEEE 802.11ad does not use deauthication. Deallocate sta upon
+	 * disassociation. */
+	if (hapd->iface->current_mode &&
+			hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211AD) {
+		sta->flags &= ~WLAN_STA_AUTH;
+		wpa_auth_sm_event(sta->wpa_sm, WPA_DEAUTH);
+		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+				HOSTAPD_LEVEL_DEBUG, "Linked STA deauthenticated");
+		ap_free_sta(hapd, sta);
+	}
+}
+
+static void mxl_handle_deauth_linked_sta(struct hostapd_data *hapd,
+						le16 reason_code, struct sta_info *sta)
+{
+	if (sta == NULL) {
+		wpa_msg(hapd->msg_ctx, MSG_DEBUG, "Station  trying "
+				"to deauthenticate, but it is not authenticated");
+		return;
+	}
+
+	wpa_msg(hapd->msg_ctx, MSG_DEBUG, "Linked STA deauthentication: STA=" MACSTR
+			" reason_code=%d",
+			MAC2STR(sta->addr), le_to_host16(reason_code));
+
+	/* Clear the PTKSA cache entries for PASN */
+	ptksa_cache_flush(hapd->ptksa, sta->addr, WPA_CIPHER_NONE);
+
+	sta->flags &= ~WLAN_STA_BSS_TRANS_MGMT_REQ_TIMEOUT;
+	sta->deauth_reason = le_to_host16(reason_code);
+	sta->disconnect_source = DISCONNECT_SOURCE_REMOTE;
+	ap_sta_set_authorized(hapd, sta, 0);
+	sta->last_seq_ctrl = WLAN_INVALID_MGMT_SEQ;
+	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC |
+			WLAN_STA_ASSOC_REQ_OK);
+	hostapd_set_sta_flags(hapd, sta);
+	wpa_auth_sm_event(sta->wpa_sm, WPA_DEAUTH);
+	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+			HOSTAPD_LEVEL_DEBUG, "Linked STA deauthenticated");
+	mlme_deauthenticate_indication(
+			hapd, sta, le_to_host16(reason_code));
+	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
+	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+
+	if (hapd->conf->disable_pmksa_caching) {
+		ap_free_sta(hapd, sta);
+	} else {
+		/* Stop Accounting and IEEE 802.1X sessions, but leave the STA authenticated. */
+		accounting_sta_stop(hapd, sta);
+		ieee802_1x_free_station(hapd, sta);
+		if (sta->ipaddr)
+			hostapd_drv_br_delete_ip_neigh(hapd, 4, (u8 *) &sta->ipaddr);
+		ap_sta_ip6addr_del(hapd, sta);
+		hostapd_drv_sta_remove(hapd, sta->addr);
+		sta->added_unassoc = 0;
+		mxl_hostapd_free_aid(hapd,sta);
+		if (sta->timeout_next == STA_NULLFUNC ||
+			sta->timeout_next == STA_DISASSOC) {
+			sta->timeout_next = STA_DEAUTH;
+			eloop_cancel_timeout(ap_handle_timer, hapd, sta);
+			eloop_register_timeout(AP_DEAUTH_DELAY, 0, ap_handle_timer,
+									hapd, sta);
+		}
+	}
+}
+
+void mxl_mlo_handle_disassoc(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len)
+{
+	int ret = 0;
+	struct hostapd_data *hapd1 = NULL;
+	struct sta_info *sta = NULL, *sta1 = NULL;
+
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		sta = ap_get_sta(hapd, mgmt->sa);
+		if (sta) {
+			sta1 = sta->mxl_sta_info.linked_sta;
+			ret = mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+		}
+	}
+	if (!ret)
+		mxl_handle_disassoc(hapd, mgmt, len);
+
+	if (hapd1 && sta1 && !ret && (len >= (IEEE80211_HDRLEN + sizeof(mgmt->u.disassoc))))
+		mxl_mlo_handle_disassoc_linked_sta(hapd1, mgmt->u.disassoc.reason_code, sta1);
+}
+
+void mxl_mlo_handle_deauth(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len)
+{
+	int ret = 0;
+	struct hostapd_data *hapd1 = NULL;
+	struct sta_info *sta = NULL, *sta1 = NULL;
+
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		sta = ap_get_sta(hapd, mgmt->sa);
+		if (sta) {
+			sta1 = sta->mxl_sta_info.linked_sta;
+			ret = mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+		}
+	}
+	if (!ret)
+		mxl_handle_deauth(hapd, mgmt, len);
+
+	if (hapd1 && sta1 && !ret && (len >= (IEEE80211_HDRLEN + sizeof(mgmt->u.deauth))))
+		mxl_handle_deauth_linked_sta(hapd1, mgmt->u.deauth.reason_code, sta1);
+}
+
+int mxl_mlo_add_associated_sta(struct hostapd_data *hapd, struct sta_info *sta, int reassoc)
+{
+	struct ieee80211_ht_capabilities ht_cap[2];
+	struct ieee80211_vht_capabilities vht_cap[2];
+	struct ieee80211_he_capabilities he_cap[2];
+	struct ieee80211_eht_capabilities eht_cap[2];
+	int set = 1;
+	struct sta_info *sta1;
+	struct hostapd_data *hapd1;
+	struct ieee80211_ml_sta_info ml_sta_info;
+
+	sta1 = sta->mxl_sta_info.linked_sta;
+	hapd1 = hapd->mxl_data.sibling_hapd;
+	if (!hapd1)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "Add associated STA " MACSTR
+			" (added_unassoc=%d auth_alg=%u ft_over_ds=%u reassoc=%d authorized=%d ft_tk=%d fils_tk=%d)",
+			MAC2STR(sta->addr), sta->added_unassoc, sta->auth_alg,
+			sta->ft_over_ds, reassoc,
+			!!(sta->flags & WLAN_STA_AUTHORIZED),
+			wpa_auth_sta_ft_tk_already_set(sta->wpa_sm),
+			wpa_auth_sta_fils_tk_already_set(sta->wpa_sm));
+
+	if (!sta->added_unassoc && (!(sta->flags & WLAN_STA_AUTHORIZED) ||
+			 (reassoc && sta->ft_over_ds && sta->auth_alg == WLAN_AUTH_FT) ||
+			 (!wpa_auth_sta_ft_tk_already_set(sta->wpa_sm) &&
+			  !wpa_auth_sta_fils_tk_already_set(sta->wpa_sm)))) {
+		hostapd_drv_sta_remove(hapd, sta->addr);
+		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
+		if (hapd1 && sta1) {
+			hostapd_drv_sta_remove(hapd1, sta1->addr);
+			wpa_auth_sm_event(sta1->wpa_sm, WPA_DRV_STA_REMOVED);
+		}
+		set = 0;
+
+		/* Do not allow the FT-over-DS exception to be used more than
+		 * once per authentication exchange to guarantee a new TK is
+		 * used here */
+		sta->ft_over_ds = 0;
+	}
+
+	if (sta->flags & WLAN_STA_HT)
+		hostapd_get_ht_capab(hapd, sta->ht_capabilities, &ht_cap[0]);
+
+	if (sta1)
+		hostapd_get_ht_capab(hapd1, sta1->ht_capabilities, &ht_cap[1]);
+#ifdef CONFIG_IEEE80211AC
+	if (sta->flags & WLAN_STA_VHT)
+		hostapd_get_vht_capab(hapd, sta->vht_capabilities, &vht_cap[0]);
+	if (sta1)
+		hostapd_get_vht_capab(hapd1, sta1->vht_capabilities, &vht_cap[1]);
+#endif /* CONFIG_IEEE80211AC */
+#ifdef CONFIG_IEEE80211AX
+	if (sta->flags & WLAN_STA_HE) {
+		hostapd_get_he_capab(hapd, sta->he_capab, &he_cap[0],
+				sta->he_capab_len);
+	}
+	if (sta1) {
+		hostapd_get_he_capab(hapd1, sta1->he_capab, &he_cap[1],
+				sta1->he_capab_len);
+	}
+#endif /* CONFIG_IEEE80211AX */
+#ifdef CONFIG_IEEE80211BE
+	if (sta->flags & WLAN_STA_EHT)
+		hostapd_get_eht_capab(hapd, sta->eht_capab, &eht_cap[0],
+				sta->eht_capab_len);
+	if (sta1)
+		hostapd_get_eht_capab(hapd1, sta1->eht_capab, &eht_cap[1],
+				sta1->eht_capab_len);
+
+	os_memset(&ml_sta_info, 0, sizeof(ml_sta_info));
+	memcpy_s(ml_sta_info.mld_mac, ETH_ALEN, sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN);
+	if (sta1)
+		memcpy_s(ml_sta_info.linked_sta_mac, ETH_ALEN, sta1->addr, ETH_ALEN);
+
+	ml_sta_info.is_ml = true;
+	mxl_hostapd_ml_sta_info_set(sta, ml_sta_info);
+	/* Remove Station if there is any STA with same mld mac address */
+	mxl_mlo_hostapd_prune_associations_mld_mac(hapd, sta);
+	if (sta->mxl_sta_info.ext_flags & WLAN_STA_SINGLE_LINK_ML_ASSOC)
+		mxl_mlo_hostapd_prune_associations_mld_mac(hapd->mxl_data.sibling_hapd, sta);
+#endif /* CONFIG_IEEE80211BE */
+
+	/*
+	 * Add the station with forced WLAN_STA_ASSOC flag. The sta->flags
+	 * will be set when the ACK frame for the (Re)Association Response frame
+	 * is processed (TX status driver event).
+	 */
+
+	if (hostapd_sta_add(hapd, sta->addr, sta->aid, sta->capability,
+			    sta->supported_rates, sta->supported_rates_len,
+			    sta->listen_interval,
+			    sta->flags & WLAN_STA_HT ? &ht_cap[0] : NULL,
+			    sta->flags & WLAN_STA_VHT ? &vht_cap[0] : NULL,
+			    sta->flags & WLAN_STA_HE ? &he_cap[0] : NULL,
+			    sta->flags & WLAN_STA_HE ? sta->he_capab_len : 0,
+			    sta->flags & WLAN_STA_EHT ? &eht_cap[0] : NULL,
+			    sta->flags & WLAN_STA_EHT ? sta->eht_capab_len : 0,
+			    sta->he_6ghz_capab,
+			    sta->flags | WLAN_STA_ASSOC, sta->qosinfo,
+			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
+			    set,
+			    sta->last_assoc_req,
+			    sta->last_assoc_req_len,
+			    sta->ssi_signal,
+			    NULL, false)) {
+		hostapd_logger(hapd, sta->addr,
+			       HOSTAPD_MODULE_IEEE80211, HOSTAPD_LEVEL_NOTICE,
+			       "Could not %s STA to kernel driver",
+			       set ? "set" : "add");
+
+		if (sta->added_unassoc) {
+			hostapd_drv_sta_remove(hapd, sta->addr);
+			sta->added_unassoc = 0;
+		}
+
+		return -1;
+	}
+
+	mxl_mlo_hostapd_prune_associations_mld(hapd, sta->addr);
+	if (mxl_mlo_is_ml_sta(sta)) {
+		mxl_mlo_hostapd_prune_associations_mld(hapd, sta->mxl_sta_info.non_ap_mld_mac);
+	}
+
+	if (sta1) {
+		wpa_printf(MSG_DEBUG, "Add associated linked STA " MACSTR
+				" (added_unassoc=%d auth_alg=%u ft_over_ds=%u reassoc=%d authorized=%d ft_tk=%d fils_tk=%d)",
+				MAC2STR(sta1->addr), sta1->added_unassoc, sta1->auth_alg,
+				sta1->ft_over_ds, reassoc,
+				!!(sta1->flags & WLAN_STA_AUTHORIZED),
+				wpa_auth_sta_ft_tk_already_set(sta1->wpa_sm),
+				wpa_auth_sta_fils_tk_already_set(sta1->wpa_sm));
+
+		memcpy_s(ml_sta_info.linked_sta_mac, ETH_ALEN, sta1->mxl_sta_info.linked_sta->addr, ETH_ALEN);
+		mxl_hostapd_ml_sta_info_set(sta1, ml_sta_info);
+		if (hostapd_sta_add(hapd1, sta1->addr, sta1->aid, sta1->capability,
+				    sta1->supported_rates, sta1->supported_rates_len,
+				    sta1->listen_interval,
+				    sta1->flags & WLAN_STA_HT ? &ht_cap[1] : NULL,
+				    sta1->flags & WLAN_STA_VHT ? &vht_cap[1] : NULL,
+				    sta1->flags & WLAN_STA_HE ? &he_cap[1] : NULL,
+				    sta1->flags & WLAN_STA_HE ? sta1->he_capab_len : 0,
+				    sta1->flags & WLAN_STA_EHT ? &eht_cap[1] : NULL,
+				    sta1->flags & WLAN_STA_EHT ? sta1->eht_capab_len : 0,
+				    sta1->he_6ghz_capab,
+				    sta1->flags | WLAN_STA_ASSOC, sta1->qosinfo,
+				    sta1->vht_opmode, sta1->p2p_ie ? 1 : 0,
+				    set,
+				    sta1->last_assoc_req,
+				    sta1->last_assoc_req_len,
+				    sta1->ssi_signal,
+				    NULL, false)) {
+			hostapd_logger(hapd1, sta1->addr, HOSTAPD_MODULE_IEEE80211,
+					HOSTAPD_LEVEL_NOTICE, "Could not %s STA to kernel driver",
+					set ? "set" : "add");
+			if (sta1 && sta1->added_unassoc) {
+				hostapd_drv_sta_remove(hapd1, sta1->addr);
+				sta1->added_unassoc = 0;
+			}
+			return -1;
+		}
+	}
+	if (mxl_ml_sta_add(hapd, sta) < 0) {
+		wpa_printf(MSG_ERROR,"ML STA ADD vendor cmd failed!!!");
+		if (sta->added_unassoc) {
+			hostapd_drv_sta_remove(hapd, sta->addr);
+			sta->added_unassoc = 0;
+		}
+		if (sta1 && sta1->added_unassoc) {
+			hostapd_drv_sta_remove(hapd1, sta1->addr);
+			sta1->added_unassoc = 0;
+		}
+		return -1;
+	}
+
+	sta->added_unassoc = 0;
+	if (sta1)
+		sta1->added_unassoc = 0;
+
+	return 0;
+}
+
+void mxl_mlo_handle_deauth_cb(struct hostapd_data *hapd,
+				const struct ieee80211_mgmt *mgmt,
+				size_t len, int ok)
+{
+	struct sta_info *sta;
+	struct hostapd_data *hapd1;
+	struct sta_info *sta1;
+
+	if (is_multicast_ether_addr(mgmt->da))
+		return;
+
+	sta = ap_get_sta(hapd, mgmt->da);
+	if (!sta) {
+		wpa_printf(MSG_DEBUG, "handle_deauth_cb: STA " MACSTR
+				" not found", MAC2STR(mgmt->da));
+		return;
+	}
+
+	if (ok)
+		wpa_printf(MSG_DEBUG, "STA " MACSTR " acknowledged deauth",
+				MAC2STR(sta->addr));
+	else
+		wpa_printf(MSG_DEBUG, "STA " MACSTR " did not acknowledge "
+				"deauth", MAC2STR(sta->addr));
+
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+	}
+
+	ap_sta_deauth_cb(hapd, sta);
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		if (mxl_mlo_is_ml_sta(sta)) {
+			sta1 = sta->mxl_sta_info.linked_sta;
+			if (sta1 && (sta1 == ap_get_sta(hapd1, sta1->addr))) {
+				ap_sta_deauth_cb(hapd1, sta1);
+			}
+		}
+	}
+}
+
+void mxl_mlo_handle_disassoc_cb(struct hostapd_data *hapd,
+				const struct ieee80211_mgmt *mgmt,
+				size_t len, int ok)
+{
+	struct sta_info *sta;
+	struct hostapd_data *hapd1;
+	struct sta_info *sta1;
+
+	if (is_multicast_ether_addr(mgmt->da))
+		return;
+
+	sta = ap_get_sta(hapd, mgmt->da);
+	if (!sta) {
+		wpa_printf(MSG_DEBUG, "handle_disassoc_cb: STA " MACSTR
+				" not found", MAC2STR(mgmt->da));
+		return;
+	}
+	if (ok)
+		wpa_printf(MSG_DEBUG, "STA " MACSTR " acknowledged disassoc",
+				MAC2STR(sta->addr));
+	else
+		wpa_printf(MSG_DEBUG, "STA " MACSTR " did not acknowledge "
+				"disassoc", MAC2STR(sta->addr));
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+	}
+	ap_sta_disassoc_cb(hapd, sta);
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		if (mxl_mlo_is_ml_sta(sta)) {
+			sta1 = sta->mxl_sta_info.linked_sta;
+			if (sta1 && (sta1 == ap_get_sta(hapd1, sta1->addr))) {
+				ap_sta_disassoc_cb(hapd1, sta1);
+			}
+
+		}
+	}
+}
+
+void mxl_wpa_mld_auth_sta_init(struct sta_info *sta)
+{
+	struct sta_info *sta1;
+
+	sta->wpa_sm->mxl_sm.is_ml_sta = true;
+	sta1 = sta->mxl_sta_info.linked_sta;
+	memcpy_s(sta->wpa_sm->mxl_sm.non_ap_mld_mac, ETH_ALEN, sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN);
+
+	if (sta1)
+		memcpy_s(sta->wpa_sm->mxl_sm.sibling_sta_mac, ETH_ALEN, sta1->addr, ETH_ALEN);
+
+	if (sta->mxl_sta_info.ext_flags & (WLAN_STA_SINGLE_LINK_ML_ASSOC))
+		sta->wpa_sm->mxl_sm.is_single_link_ml_sta = true;
+}
+
+void mxl_auth_parse_ml_ie(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len, struct sta_info *sta)
+{
+	const u8 *ml_pos = NULL, *end;
+	struct ieee802_11_elems elems;
+
+	ml_pos = mxl_auth_skip_fixed_fields(hapd, mgmt, len);
+	end = ((const u8 *) mgmt) + len;
+	if (ieee802_11_parse_elems(ml_pos, end - ml_pos, &elems, 1) == ParseFailed) {
+		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
+				HOSTAPD_LEVEL_INFO, "Station sent an invalid"
+				"auth request");
+	}
+	if (elems.multilink_ie && (elems.multilink_ie_len >= MIN_BASIC_MULTILINK_IE_LEN)) {
+		sta->mxl_sta_info.ext_flags |= WLAN_STA_MULTILINK;
+		memcpy_s(sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN, (elems.multilink_ie + 3), ETH_ALEN);
+		wpa_printf(MSG_INFO, "Multilink element found in auth with MLD mac addr " MACSTR,
+					MAC2STR(sta->mxl_sta_info.non_ap_mld_mac));
+	}
+}
+
+bool mxl_check_assoc_ies_owe(struct hostapd_data *hapd, struct sta_info *sta, struct ieee802_11_elems *elems)
+{
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+		if (!(((sta->auth_alg == WLAN_AUTH_SAE) &&
+		       (hapd->conf->wpa_key_mgmt & (WPA_KEY_MGMT_SAE | WPA_KEY_MGMT_SAE_EXT_KEY))) ||
+				 ((sta->auth_alg == WLAN_AUTH_OPEN) && ((wpa_auth_uses_sae(sta->wpa_sm)) || ((hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) &&
+				 elems->owe_dh))))) {
+			return true;
+		}
+	}
+	return false;
+}
+
+void mxl_ml_drv_remove_sta(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+	hostapd_drv_sta_remove(hapd, sta->addr);
+	wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
+	if (hapd->mxl_data.sibling_hapd && sta->mxl_sta_info.linked_sta) {
+		hostapd_drv_sta_remove(hapd->mxl_data.sibling_hapd, sta->mxl_sta_info.linked_sta->addr);
+		wpa_auth_sm_event(sta->mxl_sta_info.linked_sta->wpa_sm, WPA_DRV_STA_REMOVED);
+	}
+}
+void mxl_free_sta_profile(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	if (sta->mxl_sta_info.sta_profile_ie) {
+		os_free(sta->mxl_sta_info.sta_profile_ie);
+		sta->mxl_sta_info.sta_profile_ie = NULL;
+		sta->mxl_sta_info.sta_profile_ie_len = 0;
+	}
+
+	if (mxl_is_mlo_enabled(hapd->conf) && sta->mxl_sta_info.linked_sta) {
+		sta->mxl_sta_info.linked_sta->mxl_sta_info.sta_profile_ie = NULL;
+		sta->mxl_sta_info.linked_sta->mxl_sta_info.sta_profile_ie_len = 0;
+	}
+}
+
+int mxl_pmksa_cache_handle(struct sta_info *sta)
+{
+	if (sta->mxl_sta_info.sta_profile_ie)
+		return 0;
+
+	struct rsn_pmksa_cache_entry *sa;
+	sa = wpa_auth_sta_get_pmksa(sta->wpa_sm);
+	if (!sa || !wpa_key_mgmt_sae(sa->akmp)) {
+		wpa_printf(MSG_DEBUG,
+				"SAE: No PMKSA cache entry found for "
+				MACSTR, MAC2STR(sta->addr));
+		return WLAN_STATUS_INVALID_PMKID;
+	}
+	wpa_printf(MSG_DEBUG, "SAE: " MACSTR
+			" using PMKSA caching", MAC2STR(sta->addr));
+	return 0;
+}
+
+void mxl_hostapd_drv_cleanup_sta(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	struct sta_info *sta1 = NULL;
+
+	if (sta->mxl_sta_info.ext_flags & WLAN_STA_MULTILINK) {
+		sta1 = sta->mxl_sta_info.linked_sta;
+		mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+	}
+
+	wpa_printf(MSG_DEBUG, "Removing STA" MACSTR " AID %d", MAC2STR(sta->addr), sta->aid);
+	ap_free_sta(hapd, sta);
+
+	if (sta1) {
+		wpa_printf(MSG_DEBUG, "Removing STA" MACSTR, MAC2STR(sta1->addr));
+		ap_free_sta(hapd->mxl_data.sibling_hapd, sta1);
+	}
+}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+void mxl_cache_sta_deauth(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	if (hapd->conf->disable_pmksa_caching) {
+		ap_free_sta(hapd, sta);
+	} else {
+		/* Stop Accounting and IEEE 802.1X sessions, but leave the STA
+		* authenticated. */
+		accounting_sta_stop(hapd, sta);
+		ieee802_1x_free_station(hapd, sta);
+		if (sta->ipaddr)
+			hostapd_drv_br_delete_ip_neigh(hapd, 4, (u8 *) &sta->ipaddr);
+		ap_sta_ip6addr_del(hapd, sta);
+		hostapd_drv_sta_remove(hapd, sta->addr);
+		sta->added_unassoc = 0;
+		mxl_hostapd_free_aid(hapd,sta);
+		if (sta->timeout_next == STA_NULLFUNC ||
+			sta->timeout_next == STA_DISASSOC) {
+			sta->timeout_next = STA_DEAUTH;
+			eloop_cancel_timeout(ap_handle_timer, hapd, sta);
+			eloop_register_timeout(AP_DEAUTH_DELAY, 0, ap_handle_timer,
+								hapd, sta);
+		}
+	}
+}
 #endif /* CONFIG_NATIVE_WINDOWS */
diff --git a/src/ap/mxl_ieee802_11.h b/src/ap/mxl_ieee802_11.h
index 173ca3ada..abf1f53cd 100644
--- a/src/ap/mxl_ieee802_11.h
+++ b/src/ap/mxl_ieee802_11.h
@@ -14,12 +14,37 @@ struct hostapd_data;
 
 u8 * hostapd_eid_txpower_envelope_vendor_mxl_6g(struct hostapd_data *hapd, u8 *eid, bool only_one_psd_limit);
 u8 * hostapd_eid_txpower_envelope_vendor_mxl(struct hostapd_data *hapd, u8 *eid);
+void mxl_free_sta(struct hostapd_data *hapd, struct sta_info *sta);
+void mxl_cache_sta_deauth(struct hostapd_data *hapd, struct sta_info *sta);
 #ifdef CONFIG_IEEE80211BE_MXL_MLO
 struct hostapd_data;
 
 u8 * mxl_hostapd_eid_ml_mbssid(struct hostapd_data *hapd, struct hostapd_data *non_tx_hapd,
 			       u8 *pos, u8 *probe_req_mle, size_t probe_req_mle_len);
 int mxl_get_non_tx_mlo_ie_len(struct hostapd_data *hapd, u8 *probe_req_mle, size_t probe_req_mle_len);
-#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
+size_t mxl_ml_auth_len(struct hostapd_data *hapd, struct sta_info *sta);
+u16 mxl_check_assoc_ie_ml_ie_validate(struct hostapd_data *hapd, struct sta_info *sta, struct ieee802_11_elems *elems);
+void mxl_auth_hostapd_eid_multilink(struct hostapd_data *hapd, struct sta_info *sta, u8 *eid);
+u8 * mxl_assoc_add_ml_ie(struct hostapd_data *hapd, struct sta_info *sta,
+			 u8 *p, struct ieee80211_mgmt *reply, u16 link_sta_status);
+void mxl_mlo_reassoc_notify(struct hostapd_data *hapd, struct sta_info *sta);
+u16 mxl_mlo_check_assoc_ie(struct hostapd_data *hapd, struct sta_info *sta, const u8 *pos, int left,
+			   int reassoc, u16 capab_info);
+int mxl_mlo_update_last_assoc_req(struct hostapd_data *hapd, struct sta_info *sta, const struct ieee80211_mgmt *mgmt, size_t len);
+void mxl_mlo_handle_deauth_cb(struct hostapd_data *hapd,
+				const struct ieee80211_mgmt *mgmt,
+				size_t len, int ok);
+void mxl_mlo_handle_disassoc(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len);
+void mxl_mlo_handle_deauth(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len);
+int mxl_mlo_add_associated_sta(struct hostapd_data *hapd, struct sta_info *sta, int reassoc);
+void mxl_wpa_mld_auth_sta_init(struct sta_info *sta);
+int mxl_mlo_sae_prepare_commit_pt(struct hostapd_data *hapd, struct sta_info *sta, const struct sae_pt *pt, const struct sae_pk *pk);
+void mxl_auth_parse_ml_ie(struct hostapd_data *hapd, const struct ieee80211_mgmt *mgmt, size_t len, struct sta_info *sta);
+bool mxl_check_assoc_ies_owe(struct hostapd_data *hapd, struct sta_info *sta, struct ieee802_11_elems *elems);
+void mxl_ml_drv_remove_sta(struct hostapd_data *hapd, struct sta_info *sta);
+int mxl_pmksa_cache_handle(struct sta_info *sta);
+void mxl_free_sta_profile(struct hostapd_data *hapd, struct sta_info *sta);
+void mxl_hostapd_drv_cleanup_sta(struct hostapd_data *hapd, struct sta_info *sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #endif /* MXL_IEEE802_11_H */
diff --git a/src/ap/mxl_ieee802_11_eht.h b/src/ap/mxl_ieee802_11_eht.h
new file mode 100644
index 000000000..f30bdfaaa
--- /dev/null
+++ b/src/ap/mxl_ieee802_11_eht.h
@@ -0,0 +1,17 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#ifndef MXL_IEEE802_11_EHT_H
+#define MXL_IEEE802_11_EHT_H
+
+const u8 * mxl_auth_skip_fixed_fields(struct hostapd_data *hapd,
+					const struct ieee80211_mgmt *mgmt,
+					size_t len);
+
+#endif /* MXL_IEEE802_11_EHT_H */
diff --git a/src/ap/mxl_mld.c b/src/ap/mxl_mld.c
index 33a293d66..fd9366af4 100644
--- a/src/ap/mxl_mld.c
+++ b/src/ap/mxl_mld.c
@@ -12,6 +12,7 @@
 #include "common/ieee802_11_defs.h"
 #include "common/ieee802_11_common.h"
 #include "common/mxl_ieee802_11_common.h"
+#include "common/mxl_sae.h"
 #include "ieee802_11.h"
 #include "mxl_mld.h"
 #include "hostapd.h"
@@ -252,6 +253,10 @@ static int mxl_setup_link(struct p_ap_mld *mld)
 
 	mxl_set_link_id(link1);
 	mxl_set_link_id(link2);
+
+	mxl_hostapd_setup_wpa_mlo_linkid(link1);
+	mxl_hostapd_setup_wpa_mlo_linkid(link2);
+
 	/* set_beacon for each affiliated links */
 	ret = ieee802_11_set_beacon(link1);
 	if (ret < 0)
@@ -440,6 +445,132 @@ static u8 * mxl_hostapd_eid_ml_non_inheritance(struct hostapd_data *hapd, u8 *ei
 	return pos;
 }
 
+static u8 * mxl_hostapd_eid_mld_staprof_assoc(struct hostapd_data *hapd, struct sta_info *sta, u8 *eid, u16 status_code)
+{
+	le16 capab_info = 0;
+
+	/* capability info */
+	capab_info = host_to_le16(hostapd_own_capab_info(hapd));
+	memcpy_s(eid, sizeof(capab_info), &capab_info, sizeof(capab_info));
+	eid += sizeof(capab_info);
+
+	/* Status code */
+	status_code = host_to_le16(status_code);
+	memcpy_s(eid, sizeof(status_code), &status_code, sizeof(status_code));
+	eid += sizeof(status_code);
+
+	/* Supported rates */
+	eid = hostapd_eid_supp_rates(hapd, eid);
+	/* Extended supported rates */
+	eid = hostapd_eid_ext_supp_rates(hapd, eid);
+	/* IOP: mask out or not RX MCS bits in HT caps for ASSOC RSP */
+	/* KLOCWORK  fix for NPD.CHECK.MIGHT for "sta" */
+	eid = hostapd_eid_ht_capabilities(hapd, eid, sta);
+	if (!eid) {
+		wpa_printf(MSG_ERROR, "hostapd_eid_ht_capabilities failed");
+		goto done;
+	}
+	eid = hostapd_eid_ht_operation(hapd, eid);
+
+#ifdef CONFIG_IEEE80211AC
+	if ((hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac && !is_6ghz_op_class(hapd->iconf->op_class)) ||
+			(hapd->conf->vendor_vht && (sta->flags & WLAN_STA_VENDOR2_VHT))) {
+		if (!hapd->iconf->ieee80211n_acax_compat || (sta->flags & WLAN_STA_VHT)) {
+			u32 nsts = 0, sta_nsts;
+
+			if (hapd->conf->use_sta_nsts && sta->vht_capabilities) {
+				struct ieee80211_vht_capabilities *capa;
+
+				nsts = (hapd->iface->conf->vht_capab >>
+						VHT_CAP_BEAMFORMEE_STS_OFFSET) & 7;
+				capa = sta->vht_capabilities;
+				sta_nsts = (le_to_host32(capa->vht_capabilities_info) >>
+						VHT_CAP_BEAMFORMEE_STS_OFFSET) & 7;
+
+				if (nsts < sta_nsts)
+					nsts = 0;
+				else
+					nsts = sta_nsts;
+			}
+			eid = hostapd_eid_vht_capabilities(hapd, eid, nsts);
+			if (!eid) {
+				wpa_printf(MSG_ERROR, "hostapd_eid_vht_capabilities failed");
+				goto done;
+			}
+			eid = hostapd_eid_vht_operation(hapd, eid);
+		}
+	}
+#endif /* CONFIG_IEEE80211AC */
+#ifdef CONFIG_IEEE80211AX
+	if (hapd->iconf->ieee80211ax && !hapd->conf->disable_11ax) {
+		if (!hapd->iconf->ieee80211n_acax_compat || (sta->flags & WLAN_STA_HE)) {
+			u8 *cca_pos;
+			eid = hostapd_eid_he_capab(hapd, eid, IEEE80211_MODE_AP);
+			if (!eid) {
+				wpa_printf(MSG_ERROR, "hostapd_eid_he_capab failed");
+				goto done;
+			}
+			eid = hostapd_eid_he_operation(hapd, eid);
+			if (!eid) {
+				wpa_printf(MSG_ERROR, "hostapd_eid_he_operation failed");
+				goto done;
+			}
+
+			if(hapd->iconf->he_spatial_reuse_ie_present_in_assoc_response) {
+				eid = hostapd_eid_spatial_reuse(hapd, eid);
+				if (!eid) {
+					wpa_printf(MSG_ERROR, "hostapd_eid_spatial_reuse failed");
+					goto done;
+				}
+			}
+
+			if(hapd->iconf->he_mu_edca_ie_present)
+				eid = hostapd_eid_he_mu_edca_parameter_set(hapd, eid);
+
+			/* CCA IE */
+			cca_pos = hostapd_eid_cca(hapd, eid);
+			if (cca_pos != eid) {
+				/* Keep the count as zero, as hostapd won't have
+				 * updated cca count during CCA */
+#define WLAN_CNT_OFF_IN_CCA_IE 3 /* eid(1) + len(1) + ext (1) */
+				cca_pos[WLAN_CNT_OFF_IN_CCA_IE] = 0;
+			}
+			eid = cca_pos;
+			eid = hostapd_eid_he_6ghz_band_cap(hapd, eid);
+		}
+	}
+#endif /* CONFIG_IEEE80211AX */
+
+	eid = hostapd_eid_ext_capab(hapd, eid, false);
+	if (sta->qos_map_enabled)
+		eid = hostapd_eid_qos_map_set(hapd, eid);
+
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->iconf->ieee80211be && !hapd->conf->disable_11be) {
+		eid = hostapd_eid_eht_capab(hapd, eid, IEEE80211_MODE_AP);
+		eid = hostapd_eid_eht_operation(hapd, eid);
+	}
+#endif /* CONFIG_IEEE80211BE */
+#ifdef CONFIG_IEEE80211AC
+	if (hapd->conf->vendor_vht && (sta->flags & WLAN_STA_VENDOR_VHT)) {
+		eid = hostapd_eid_vendor_vht(hapd, eid);
+		if (!eid) {
+			wpa_printf(MSG_ERROR, "hostapd_eid_vendor_vht failed");
+			goto done;
+		}
+	}
+#endif /* CONFIG_IEEE80211AC */
+	/* RSNE,RSNXE,WPS,WMM,DPP etc should be same in both links, and will be in-herited */
+
+	/* To-do: Need to handle the IEs which cannot be Inherited and also not be present here.
+	 * need to explicitly mentioned as part of Non-Inheitance IE
+	 */
+	eid = mxl_hostapd_eid_ml_non_inheritance(hapd, eid, ASSOC_FRAME);
+
+done:
+	return eid;
+}
+
 static u8 * mxl_hostapd_eid_mld_staprof_probe(struct hostapd_data *hapd, u8 *eid)
 {
 	struct hostapd_hw_modes *mode;
@@ -752,6 +883,8 @@ u8 * mxl_hostapd_eid_multilink(struct hostapd_data *hapd, struct sta_info *sta,
 			eid += sizeof(eml_capab);
 		}
 		mld_capab |= mld_num_simul_links;
+		if (hapd->conf->mxl_bss_conf.mlo_t2lm_support)
+			mld_capab |= MLO_T2LM_NEGOTIATION_SUPPORT_MAP_ALL_TID_TO_SAME_LINK;
 		WPA_PUT_LE16(eid, mld_capab);
 		eid += sizeof(mld_capab);
 		/* MLD ID */
@@ -819,6 +952,16 @@ u8 * mxl_hostapd_eid_multilink(struct hostapd_data *hapd, struct sta_info *sta,
 				 */
 				eid = mxl_hostapd_eid_mld_staprof_probe(sibling_hapd, eid);
 				break;
+			case ML_ASSOC:
+				/* TODO
+				 * include the CSA related IEs in the Assoc Response
+				 * during a CSA on the affiliated link
+				 */
+				if (sta && mxl_mlo_is_ml_sta(sta) && sta->mxl_sta_info.linked_sta) {
+					eid = mxl_hostapd_eid_mld_staprof_assoc(sibling_hapd,
+							sta->mxl_sta_info.linked_sta, eid, link_sta_status);
+				}
+				break;
 
 			default:
 				wpa_printf(MSG_ERROR,"MLD: NO valid ML type!!!");
@@ -849,253 +992,118 @@ u8 * mxl_hostapd_eid_multilink(struct hostapd_data *hapd, struct sta_info *sta,
 	return eid;
 }
 
-u16 mxl_check_assoc_ies_linked_sta(struct hostapd_data *hapd, struct sta_info *sta, const u8 *ies, size_t ies_len)
+u16 mxl_multilink_ie_validate(struct hostapd_data *hapd, struct sta_info *sta,
+				const u8 *ies, size_t ies_len)
 {
-	struct ieee802_11_elems elems;
-	u16 resp;
-	u8 *pos;
-	size_t elem_id_len;
-	u8 elem_id;
-
-	if (ieee802_11_parse_elems(ies, ies_len, &elems, 1) == ParseFailed) {
-		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
-				HOSTAPD_LEVEL_INFO, "Station sent an invalid "
-				"association request");
-		return WLAN_STATUS_UNSPECIFIED_FAILURE;
-	}
-
-	/* Parse Non-Inheritance Tag and do not inherit these IEs from STA to Linked TSA*/
-	if (elems.non_inheritance && elems.non_inheritance_len > 0) {
-		pos = (u8 *)elems.non_inheritance;
-		elem_id_len = *pos++;
-		while (elem_id_len) {
-			elem_id = *pos++;
-			switch (elem_id) {
-				case WLAN_EID_EXT_SUPP_RATES:
-					if (elems.supp_rates) {
-						sta->supported_rates_len = merge_byte_arrays(
-							sta->supported_rates, sizeof(sta->supported_rates),
-							elems.supp_rates, elems.supp_rates_len,
-							NULL, 0);
-					}
-					wpa_printf(MSG_DEBUG, "Multilink IE per STA profile extended supported rates parsed");
-					break;
-				case WLAN_EID_HT_CAP:
-					if (sta->ht_capabilities) {
-						sta->flags &= ~WLAN_STA_HT;
-						os_free(sta->ht_capabilities);
-						sta->ht_capabilities = NULL;
-					}
-					break;
-				case WLAN_EID_HT_OPERATION:
-					if (sta->ht_operation) {
-						os_free(sta->ht_operation);
-						sta->ht_operation = NULL;
-					}
-					break;
-				case WLAN_EID_VHT_CAP:
-					if (sta->vht_capabilities) {
-						sta->flags &= ~WLAN_STA_VHT;
-						os_free(sta->vht_capabilities);
-						sta->vht_capabilities = NULL;
-					}
-					break;
-				case WLAN_EID_VHT_OPERATION:
-					if (sta->vht_operation) {
-						os_free(sta->vht_operation);
-						sta->vht_operation = NULL;
-					}
-					break;
-				default:
-					wpa_printf(MSG_ERROR, "MLD: Invalid Non-Inheritance element ID");
-					break;
-			}
-			elem_id_len--;
-		}
-		elem_id_len = *pos++;
-		/* Parse Element ID extension list */
-		while (elem_id_len) {
-			elem_id = *pos++;
-			switch (elem_id) {
-				case WLAN_EID_EXT_HE_6GHZ_BAND_CAP:
-					if (sta->he_6ghz_capab) {
-						sta->flags &= ~WLAN_STA_6GHZ;
-						os_free(sta->he_6ghz_capab);
-						sta->he_6ghz_capab = NULL;
-					}
-					break;
-				default:
-					wpa_printf(MSG_ERROR, "MLD: Invalid Non-Inheritance element ID extension");
-			}
-			elem_id_len--;
-		}
-	}
+	const u8 *per_sta_ie = NULL;
+	const u8 *common_info_ie = NULL;
+	size_t common_info_len = 0;
+	u8 mld_mac[ETH_ALEN] = {'\0'};
+	struct hostapd_data *sibling_hapd = NULL;
 
-	resp = check_ext_capab(hapd, sta, elems.ext_capab, elems.ext_capab_len);
-	if (resp != WLAN_STATUS_SUCCESS)
-		return resp;
+	if (!hapd || !hapd->mxl_data.sibling_hapd)
+		return WLAN_STATUS_UNSPECIFIED_FAILURE;
 
-	/* If the IE is present in per STA profile, use it for linked STA instead of inheriting from STA */
-	if (elems.supp_rates) {
-		resp = mxl_copy_supp_rates(hapd, sta, &elems);
-		if (resp != WLAN_STATUS_SUCCESS)
-			return resp;
-	}
+	sibling_hapd = hapd->mxl_data.sibling_hapd;
 
-	/* Free ht capabilities when STA has ht capabilities and Linked STA also has ht capabilities */
-	if (elems.ht_capabilities) {
-		if (sta->ht_capabilities != NULL) {
-			os_free(sta->ht_capabilities);
-			sta->ht_capabilities = NULL;
-		}
-		resp = copy_sta_ht_capab(hapd, sta, elems.ht_capabilities);
-		if (resp != WLAN_STATUS_SUCCESS)
-			return resp;
+	if (!ies || ies_len < MIN_BASIC_MULTILINK_IE_LEN) {
+		wpa_printf(MSG_ERROR, "invalid ML IE in (Re)Assoc request of length %d", (int) ies_len);
+		return WLAN_STATUS_UNSPECIFIED_FAILURE;
 	}
-
-	if (sta->ht_operation != NULL && elems.ht_operation) {
-		os_free(sta->ht_operation);
-		sta->ht_operation = NULL;
+	sta->mxl_sta_info.sta_ml_capab.ml_control_field = *(u16 *)ies;
+	common_info_ie = (ies + MULTILINK_CTRL_LEN);
+	common_info_len = *common_info_ie;
+	per_sta_ie = (common_info_ie + common_info_len);
+	memcpy_s(mld_mac, ETH_ALEN, (common_info_ie + 1), ETH_ALEN);
+	if (os_memcmp(mld_mac, sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN)) {
+		wpa_printf(MSG_ERROR, "MLD MAC missmatch between Auth/Assoc req in ML IE !!!");
+		return WLAN_STATUS_UNSPECIFIED_FAILURE;
 	}
-	if (elems.ht_capabilities && elems.ht_operation) {
-		resp = copy_sta_ht_operation(hapd, sta, elems.ht_operation);
-		if (resp != WLAN_STATUS_SUCCESS)
-			return resp;
+	common_info_ie += ETH_ALEN + 1;
+	if (sta->mxl_sta_info.sta_ml_capab.ml_control_field & MLO_LINK_ID_INFO_PRESENT) {
+		wpa_printf(MSG_ERROR, "MLD LINK_ID info present in ML IE sent by non-AP STA !!!");
+		common_info_ie++;
 	}
-	if (hapd->iconf->ieee80211n && hapd->iconf->require_ht &&
-			!(sta->flags & WLAN_STA_HT)) {
-		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
-				HOSTAPD_LEVEL_INFO, "Station does not support "
-				"mandatory HT PHY - reject association");
-		return WLAN_STATUS_ASSOC_DENIED_NO_HT;
+	if (sta->mxl_sta_info.sta_ml_capab.ml_control_field & MLO_BSS_PARAM_CHANGE_COUNT_PRESENT) {
+		wpa_printf(MSG_ERROR, "MLD BSS param change count is present ML IE sent by non-AP STA !!!");
+		common_info_ie++;
 	}
-
-#ifdef CONFIG_IEEE80211AC
-	if (hapd->iconf->ieee80211ac) {
-		/* Free vht capabilities when STA has vht capabilities and Linked STA also has vht capabilities */
-		if (elems.vht_capabilities) {
-			if (sta->vht_capabilities != NULL) {
-				os_free(sta->vht_capabilities);
-				sta->vht_capabilities = NULL;
-			}
-			resp = copy_sta_vht_capab(hapd, sta, elems.vht_capabilities);
-			if (resp != WLAN_STATUS_SUCCESS)
-				return resp;
-		}
-
-		/* Free vht operation when STA has vht operation and Linked STA also has vht operation */
-		if (sta->vht_operation != NULL && elems.vht_operation) { /* set by copy_sta_vht_capab, don't reorder */
-			os_free(sta->vht_operation);
-			sta->vht_operation = NULL;
-		}
-		if (elems.vht_capabilities && elems.vht_operation) {
-			resp = copy_sta_vht_oper(hapd, sta, elems.vht_operation);
-			if (resp != WLAN_STATUS_SUCCESS)
-				return resp;
-		}
-
-		resp = set_sta_vht_opmode(hapd, sta, elems.opmode_notif);
-		if (resp != WLAN_STATUS_SUCCESS)
-			return resp;
+	if (sta->mxl_sta_info.sta_ml_capab.ml_control_field & MLO_MSDI_PRESENT) {
+		wpa_printf(MSG_ERROR, "MLD BSS Medium Synchronization Delay Information is present ML IE sent by non-AP STA !!!");
+		common_info_ie += MULTILINK_MSDI_LEN;
 	}
-
-	if (hapd->iconf->ieee80211ac && hapd->iconf->require_vht &&
-			!(sta->flags & WLAN_STA_VHT)) {
-		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
-				HOSTAPD_LEVEL_INFO, "Station does not support "
-				"mandatory VHT PHY - reject association");
-		return WLAN_STATUS_ASSOC_DENIED_NO_VHT;
+	if (sta->mxl_sta_info.sta_ml_capab.ml_control_field & MLO_EML_CAPAB_PRESENT) {
+		sta->mxl_sta_info.sta_ml_capab.eml_capab = *common_info_ie;
+		common_info_ie += MULTILINK_EML_CAPAB_LEN;
 	}
-
-	if (hapd->conf->vendor_vht && !elems.vht_capabilities && elems.vendor_vht) {
-		if (sta->vht_capabilities) {
-			os_free(sta->vht_capabilities);
-			sta->vht_capabilities = NULL;
-		}
-		resp = copy_sta_vendor_vht(hapd, sta, elems.vendor_vht,
-				elems.vendor_vht_len);
-		if (resp != WLAN_STATUS_SUCCESS)
-			return resp;
+	if (sta->mxl_sta_info.sta_ml_capab.ml_control_field & MLO_MLD_CAPAB_PRESENT) {
+		sta->mxl_sta_info.sta_ml_capab.mld_capab_oper = *common_info_ie;
+		common_info_ie += MULTILINK_MLD_CAPAB_OPER_LEN;
 	}
-	if (hapd->conf->vendor_vht && elems.vht_capabilities && !hapd->iconf->ieee80211ac) {
-		if (sta->vht_capabilities) {
-			os_free(sta->vht_capabilities);
-			sta->vht_capabilities = NULL;
-		}
-		resp = copy_sta_vendor2_vht(hapd, sta, elems.vht_capabilities);
-		if (resp != WLAN_STATUS_SUCCESS)
-			return resp;
+	if (sta->mxl_sta_info.sta_ml_capab.ml_control_field & MLO_MLD_ID_PRESENT) {
+		sta->mxl_sta_info.sta_ml_capab.mld_id = *common_info_ie;
 	}
-#endif /* CONFIG_IEEE80211AC */
-
-#ifdef CONFIG_IEEE80211AX
-	if (hapd->iconf->ieee80211ax && !hapd->conf->disable_11ax) {
-		/* Free he capabilities when STA has he caabilities and Linked STA also has he capabilities */
-		if (elems.he_capabilities) {
-			if (sta->he_capab != NULL) {
-				os_free(sta->he_capab);
-				sta->he_capab = NULL;
+	if (ies_len > (common_info_len + MULTILINK_CTRL_LEN + 1)) {
+		if (WLAN_EID_SUBELEMENT_MLO_PER_STA_PROFILE == *per_sta_ie) {
+			const u8 *ie = NULL;
+			size_t ie_len = 0;
+			const u8 *sta_ctrl = NULL;
+			u8 sibling_sta_link_id;
+			size_t per_sta_ie_len = 0;
+
+			per_sta_ie_len = *(per_sta_ie + 1);
+			sta_ctrl = (per_sta_ie + LINK_INFO_STA_CTRL_LEN);
+			sibling_sta_link_id = (*(sta_ctrl) & STA_CTRL_LINK_ID_MASK);
+			if (sibling_sta_link_id != sibling_hapd->conf->mxl_bss_conf.link_id) {
+				wpa_printf(MSG_ERROR, "Multilink NON-AP-MLD link_id mismatch with AP-MLD");
+				return WLAN_STATUS_UNSPECIFIED_FAILURE;
+			}
+			/*sta_info*/
+			ie = (per_sta_ie + LINK_INFO_HDR_LEN);
+			/*sta_info_len*/
+			ie_len = *ie;
+			if (*(sta_ctrl) & STA_CTRL_MAC_ADDR_PRESENT_MASK) {
+				memcpy_s(sta->mxl_sta_info.sibling_sta_mac, ETH_ALEN, (ie + 1), ETH_ALEN);
+			}
+			/*sta_profile*/
+			ie = (ie + ie_len + 2);
+			/*sta_profile_len*/
+			ie_len = per_sta_ie_len - (LINK_INFO_STA_CTRL_LEN + 2 + ie_len);
+			sta->mxl_sta_info.linked_sta = ap_sta_add(sibling_hapd, sta->mxl_sta_info.sibling_sta_mac);
+			if (!sta->mxl_sta_info.linked_sta) {
+				wpa_printf(MSG_ERROR, "Unable to handle linked sta");
+				return WLAN_STATUS_UNSPECIFIED_FAILURE;
+				/* To-do: handle the cleanup part */
 			}
-			resp = copy_sta_he_capab(hapd, sta, IEEE80211_MODE_AP, elems.he_capabilities, elems.he_capabilities_len);
-			if (resp != WLAN_STATUS_SUCCESS)
-				return resp;
-		}
-
-		if (is_6ghz_op_class(hapd->iconf->op_class)) {
-			resp = copy_sta_he_6ghz_capab(hapd, sta,
-					elems.he_6ghz_band_cap);
-			if (resp != WLAN_STATUS_SUCCESS)
-				return resp;
-		}
 
-		if (resp != WLAN_STATUS_SUCCESS)
-			return resp;
-	} else {
-		wpa_printf(MSG_DEBUG, "ieee80211ax is not set !");
-	}
-	if (hapd->iconf->ieee80211ax && hapd->iconf->require_he &&
-			!(sta->flags & WLAN_STA_HE)) {
-		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
-				HOSTAPD_LEVEL_INFO, "Station does not support "
-				"mandatory HE PHY - reject association");
-		return WLAN_STATUS_DENIED_HE_NOT_SUPPORTED;
-	}
-#endif /* CONFIG_IEEE80211AX */
+			sta->mxl_sta_info.linked_sta->mxl_sta_info.linked_sta = sta;
+			memcpy_s(sta->mxl_sta_info.linked_sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN, sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN);
+			sta->mxl_sta_info.linked_sta->mxl_sta_info.ext_flags |= WLAN_STA_MULTILINK;
 
-	if (hapd->iconf->ieee80211be && !hapd->conf->disable_11be) {
-		/* Free eht capabilities when STA has eht capabilities and Linked STA also has eht capabilities */
-		if (elems.eht_capabilities) {
-			if (sta->eht_capab != NULL) {
-				os_free(sta->eht_capab);
-				sta->eht_capab = NULL;
+			if (!sta->mxl_sta_info.sta_profile_ie)
+				sta->mxl_sta_info.sta_profile_ie = os_zalloc(ie_len);
+			if (!sta->mxl_sta_info.sta_profile_ie) {
+				wpa_printf(MSG_ERROR, "Unable to allocate memory for station profile ie");
+				return WLAN_STATUS_UNSPECIFIED_FAILURE;
 			}
-			resp = copy_sta_eht_capab(hapd, sta, IEEE80211_MODE_AP,
-					elems.he_capabilities,
-					elems.he_capabilities_len,
-					elems.eht_capabilities,
-					elems.eht_capabilities_len);
-			if (resp != WLAN_STATUS_SUCCESS)
-				return resp;
-		}
-	}
-
-	ap_copy_sta_supp_op_classes(sta, elems.supp_op_classes,
-			elems.supp_op_classes_len);
 
-	if ((sta->capability & WLAN_CAPABILITY_RADIO_MEASUREMENT) &&
-			elems.rrm_enabled &&
-			elems.rrm_enabled_len >= sizeof(sta->rrm_enabled_capa))
-		memcpy_s(sta->rrm_enabled_capa, sizeof(sta->rrm_enabled_capa), elems.rrm_enabled,
-				sizeof(sta->rrm_enabled_capa));
+			memcpy_s(sta->mxl_sta_info.sta_profile_ie, ie_len, (u8 *)ie, ie_len);
+			sta->mxl_sta_info.sta_profile_ie_len = ie_len;
+			sta->mxl_sta_info.linked_sta->mxl_sta_info.sta_profile_ie = sta->mxl_sta_info.sta_profile_ie;
+			sta->mxl_sta_info.linked_sta->mxl_sta_info.sta_profile_ie_len = ie_len;
+			sta->mxl_sta_info.linked_sta->auth_alg = sta->auth_alg;
+			sta->mxl_sta_info.linked_sta->flags |= WLAN_STA_AUTH;
 
-	if (elems.power_capab) {
-		sta->min_tx_power = elems.power_capab[0];
-		sta->max_tx_power = elems.power_capab[1];
-		sta->power_capab = 1;
+			wpa_printf(MSG_DEBUG, "Multilink: Per STA profile found");
+		} else {
+			wpa_printf(MSG_DEBUG, "NO PerSTA Profile element present in ML IE AssocReq!!!"
+					" Use single link ML association!!!");
+			sta->mxl_sta_info.ext_flags |= WLAN_STA_SINGLE_LINK_ML_ASSOC;
+		}
 	} else {
-		sta->power_capab = 0;
+		wpa_printf(MSG_DEBUG, "NO PerSTA Profile element present in AssocReq!!! Using single link ML association");
+		sta->mxl_sta_info.ext_flags |= WLAN_STA_SINGLE_LINK_ML_ASSOC;
 	}
-
 	return WLAN_STATUS_SUCCESS;
 }
 
@@ -1178,3 +1186,172 @@ int mxl_hostapd_mld_remove(struct hostapd_data *hapd, u8 sendto_fw)
 	return 0;
 }
 
+int mxl_ml_sta_add(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	int res = 0;
+	struct mxl_ml_sta_add_param *ml_sta_params;
+	bool switch_initial_active_link = false;
+	u8 link_id = hapd->conf->mxl_bss_conf.link_id;
+	u8 *ml_sta_addr;
+	u8 sibling_link_id;
+	struct hostapd_data *tmp_hapd;
+
+	ml_sta_params = os_malloc(sizeof(struct mxl_ml_sta_add_param));
+	if (!ml_sta_params)
+		return -ENOMEM;
+
+
+	os_memset(ml_sta_params, 0, sizeof(struct mxl_ml_sta_add_param));
+
+	if (((!(sta->mxl_sta_info.ext_flags & WLAN_STA_SINGLE_LINK_ML_ASSOC)) &&
+				sta->mxl_sta_info.linked_sta == NULL) ||
+			sta->mxl_sta_info.non_ap_mld_mac == NULL) {
+		os_free(ml_sta_params);
+		return -1;
+	}
+	ml_sta_addr = ((link_id == LINK_ID_2G) ? ml_sta_params->sta_addr1 :
+			((link_id == LINK_ID_5G) ? ml_sta_params->sta_addr2 : ml_sta_params->sta_addr3));
+	ml_sta_params->assoc_link_bitmap |= 1 << link_id;
+	memcpy_s(ml_sta_addr, ETH_ALEN, sta->addr, ETH_ALEN);
+
+	if (sta->mxl_sta_info.linked_sta) {
+		sibling_link_id = hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.link_id;
+
+		/* Populate EMLSR transition timeout from config param */
+		if (hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.eml_transition_timeout) {
+			ml_sta_params->eml_capab |= (hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.eml_transition_timeout << MLO_TRANSITION_TIMEOUT_MASK);
+		}
+
+		/* Populate EMLSR Support from STA eml cabap */
+		ml_sta_params->eml_capab |= (sta->mxl_sta_info.sta_ml_capab.eml_capab & MLO_EMLSR);
+
+		/* Populate EMLSR Padding delay from STA eml cabap */
+		ml_sta_params->eml_capab |= (sta->mxl_sta_info.sta_ml_capab.eml_capab & MLO_EMLSR_PADDING_DELAY);
+
+		/* Populate EMLSR Transition delay from STA eml cabap */
+		ml_sta_params->eml_capab |= (sta->mxl_sta_info.sta_ml_capab.eml_capab & MLO_EMLSR_TRANSITION_DELAY);
+
+		/* Populate Number Of Simultaneous Links from STA MLD capab */
+		ml_sta_params->num_of_sim_links = (sta->mxl_sta_info.sta_ml_capab.mld_capab_oper & MLO_MAX_NUM_SIMUL_LINKS);
+
+		ml_sta_addr = ((sibling_link_id == LINK_ID_2G) ? ml_sta_params->sta_addr1 :
+				((sibling_link_id == LINK_ID_5G) ? ml_sta_params->sta_addr2 : ml_sta_params->sta_addr3));
+		ml_sta_params->assoc_link_bitmap |= 1 << sibling_link_id;
+		memcpy_s(ml_sta_addr, ETH_ALEN, sta->mxl_sta_info.linked_sta->addr, ETH_ALEN);
+
+		if (ml_sta_params->num_of_sim_links) /* STR */
+			ml_sta_params->eml_capab = 0;
+	}
+	memcpy_s(ml_sta_params->mld_mac_addr, ETH_ALEN, sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN);
+	ml_sta_params->mld_id = hapd->conf->mld_id;
+
+	if (sta->mxl_sta_info.linked_sta) {
+		if(sta->aid == sta->mxl_sta_info.linked_sta->aid)
+			ml_sta_params->aid = sta->aid;
+	}
+	if (sta->mxl_sta_info.ext_flags & WLAN_STA_SINGLE_LINK_ML_ASSOC)
+		ml_sta_params->aid = sta->aid;
+
+	if (hapd->conf->mxl_bss_conf.switch_initial_active_link || hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.switch_initial_active_link) {
+		/* This is to switch the initial active link
+		 * Testing purpose only */
+		switch_initial_active_link = true;
+	}
+
+	tmp_hapd = hapd;
+	if (switch_initial_active_link)
+		hapd = hapd->mxl_data.sibling_hapd;
+
+	if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_ML_STA_ADD, ml_sta_params, sizeof(struct mxl_ml_sta_add_param))) {
+		wpa_printf(MSG_ERROR, "send LTQ_NL80211_VENDOR_SUBCMD_ML_STA_ADD failed!!!");
+		os_free(ml_sta_params);
+		return -1;
+	}
+	hapd = tmp_hapd;
+
+	sta->mxl_sta_info.ext_flags |= WLAN_STA_MLD_STA;
+	if (sta->mxl_sta_info.linked_sta) {
+		sta->mxl_sta_info.linked_sta->mxl_sta_info.ext_flags |= WLAN_STA_MLD_STA;
+	}
+
+	os_free(ml_sta_params);
+	return res;
+}
+
+int mxl_ml_remove_sta(struct hostapd_data *hapd, u8 *sa, u8 sendto_fw)
+{
+	struct mxl_sta_mld_remove sta_mld;
+	struct sta_info *sta;
+
+	sta = ap_get_sta(hapd, sa);
+	if (sta == NULL) {
+		wpa_printf(MSG_INFO, "Station " MACSTR " trying to remove ml STA, but it is not associated",
+				MAC2STR(sa));
+		return -1;
+	}
+
+	sta_mld.aid = sta->aid;
+	sta_mld.sendto_fw = sendto_fw;
+
+	wpa_printf(MSG_INFO, "Removing ML station %d " MACSTR, sendto_fw,
+			MAC2STR(sta->addr));
+	if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_REMOVE_STA_MLD, &sta_mld, sizeof(struct mxl_sta_mld_remove))) {
+		wpa_printf(MSG_ERROR, " send LTQ_NL80211_VENDOR_SUBCMD_REMOVE_STA_MLD failed!!!");
+		return -1;
+	}
+	return 0;
+}
+
+/* Stop traffic on both STA, remove MLD STA and remove STA */
+int mxl_ml_stop_sta_traffic_remove_mld(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	struct hostapd_data *hapd1 = hapd->mxl_data.sibling_hapd;
+
+	if (mxl_mlo_is_ml_sta(sta) && (sta->mxl_sta_info.ext_flags & WLAN_STA_MLD_STA)) {
+		struct sta_info *sta1 = sta->mxl_sta_info.linked_sta;
+		if (sta->mxl_sta_info.ext_flags & (WLAN_STA_SINGLE_LINK_ML_ASSOC)) {
+			if (mxl_ml_remove_sta(hapd, sta->addr, 1))
+				return -1;
+		} else {
+			if (mxl_ml_remove_sta(hapd, sta->addr, 0))
+				return -1;
+		}
+
+		sta->mxl_sta_info.ext_flags &= ~WLAN_STA_MLD_STA;
+		if (sta1) {
+			if (mxl_ml_remove_sta(hapd1, sta1->addr, 1))
+				return -1;
+			sta1->mxl_sta_info.ext_flags &= ~WLAN_STA_MLD_STA;
+		}
+	}
+	return 0;
+}
+
+int ml_sta_send_t2lm_teardown_frame(struct hostapd_data *hapd, u8 *sta_mac)
+{
+	struct sta_info *sta;
+	struct mxl_ml_sta_t2lm_teardown sta_t2lm;
+
+	sta = ap_get_sta(hapd, sta_mac);
+	if (sta == NULL) {
+		wpa_printf(MSG_ERROR, "SEND_T2LM_TEARDOWN_FRAME - Station not found");
+		return -1;
+	}
+
+	if (!mxl_mlo_is_ml_sta(sta)) {
+		wpa_printf(MSG_ERROR, "SEND_T2LM_TEARDOWN_FRAME - MLO not supported in station");
+		return -1;
+	}
+
+	sta_t2lm.aid = sta->aid;
+
+	wpa_printf(MSG_INFO, "SEND_T2LM_TEARDOWN_FRAME cmd to STA " MACSTR, MAC2STR(sta_mac));
+
+	if (MXL_DRV_VENDOR_SET(LTQ_NL80211_VENDOR_SUBCMD_ML_SEND_T2LM_TEARDOWN_FRAME,
+				&sta_t2lm, sizeof(struct mxl_ml_sta_t2lm_teardown))) {
+		wpa_printf(MSG_ERROR, "send LTQ_NL80211_VENDOR_SUBCMD_ML_SEND_T2LM_TEARDOWN_FRAME failed!!!");
+		return -1;
+	}
+	return 0;
+}
+
diff --git a/src/ap/mxl_mld.h b/src/ap/mxl_mld.h
index 611bebb3f..2435fe0ca 100644
--- a/src/ap/mxl_mld.h
+++ b/src/ap/mxl_mld.h
@@ -12,6 +12,7 @@
 
 #ifdef CONFIG_IEEE80211BE_MXL_MLO
 #include "ap/ap_config.h"
+#include "ap/sta_info.h"
 
 #define MAX_SUPPORTED_MLDS 30
 #define ML_BSS_LIMIT_PER_RADIO 16
@@ -115,6 +116,14 @@ static inline bool mxl_is_mlo_enabled(struct hostapd_bss_config *conf)
 	return (conf->mxl_bss_conf.mlo_enable != 0);
 }
 
+static inline bool mxl_mlo_is_ml_sta(struct sta_info *sta)
+{
+	if (sta->mxl_sta_info.ext_flags & WLAN_STA_MULTILINK)
+		return true;
+
+	return false;
+}
+
 struct hapd_interfaces;
 
 int mxl_get_ml_probe_type_mld_id(const u8 * ml_ie, size_t ml_ie_len);
@@ -156,10 +165,14 @@ bool mxl_hostapd_verify_mld_config(struct p_ap_mld *mld);
 
 /* Setting up all AP MLDs created */
 int mxl_mld_setup_interfaces(struct hapd_interfaces *interfaces);
-/* validate ML STA Info (affiliated STA) */
-u16 mxl_check_assoc_ies_linked_sta(struct hostapd_data *hapd, struct sta_info *sta,
-					const u8 *ies, size_t ies_len);
 void mxl_hostapd_set_eml_capab(struct hostapd_iface *iface);
+u16 mxl_multilink_ie_validate(struct hostapd_data *hapd, struct sta_info *sta,
+				const u8 *ies, size_t ies_len);
+int mxl_ml_set_sid(struct hostapd_data *hapd, struct mxl_ml_sta_info *ml_sta_info);
+int mxl_ml_sta_add(struct hostapd_data *hapd, struct sta_info *sta);
+int mxl_ml_remove_sta(struct hostapd_data *hapd, u8 *sa, u8 sendto_fw);
+int mxl_ml_stop_sta_traffic_remove_mld(struct hostapd_data *hapd, struct sta_info *sta);
+int ml_sta_send_t2lm_teardown_frame(struct hostapd_data *hapd, u8 *sta_mac);
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #endif /* MXL_MLD_H */
 
diff --git a/src/ap/mxl_sta_info.c b/src/ap/mxl_sta_info.c
new file mode 100644
index 000000000..61215c902
--- /dev/null
+++ b/src/ap/mxl_sta_info.c
@@ -0,0 +1,264 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "common/wpa_ctrl.h"
+#include "radius/radius.h"
+#include "hostapd.h"
+#include "accounting.h"
+#include "ieee802_1x.h"
+#include "ieee802_11_auth.h"
+#include "ap_mlme.h"
+#include "ap_drv_ops.h"
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+struct sta_info * mxl_ap_get_sta_by_non_ap_mld_mac(struct hostapd_data *hapd, const u8 *mac)
+{
+	struct sta_info *sta;
+
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		if (!os_memcmp(sta->mxl_sta_info.non_ap_mld_mac, mac, ETH_ALEN))
+			return sta;
+	}
+	return NULL;
+}
+
+void mxl_ml_ap_handle_timer(void *eloop_ctx, void *timeout_ctx)
+{
+	struct hostapd_data *hapd = eloop_ctx;
+	struct sta_info *sta = timeout_ctx;
+	unsigned long next_time = 0;
+	u16 reason;
+	unsigned int disassoc_delay;
+	struct sta_info *sta1 = sta->mxl_sta_info.linked_sta;
+	struct hostapd_data *hapd1 = hapd->mxl_data.sibling_hapd;
+
+	wpa_printf(MSG_DEBUG, "%s: %s: " MACSTR " flags=0x%x timeout_next=%d",
+		   hapd->conf->iface, __func__, MAC2STR(sta->addr), sta->flags,
+		   sta->timeout_next);
+	if (sta->timeout_next == STA_REMOVE) {
+		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+			       HOSTAPD_LEVEL_INFO, "deauthenticated due to "
+			       "local deauth request");
+		if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd)
+			mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+#ifdef UBUS_SUPPORT
+		hostapd_ubus_notify(hapd, "local-deauth", sta->addr);
+#endif /* UBUS_SUPPORT */
+		ap_free_sta(hapd, sta);
+		if (hapd1 && sta1)
+			ap_free_sta(hapd1, sta1);
+		return;
+	}
+
+	if ((sta->flags & WLAN_STA_ASSOC) &&
+	    (sta->timeout_next == STA_NULLFUNC ||
+	     sta->timeout_next == STA_DISASSOC)) {
+		int inactive_sec;
+		/*
+		 * Add random value to timeout so that we don't end up bouncing
+		 * all stations at the same time if we have lots of associated
+		 * stations that are idle (but keep re-associating).
+		 */
+		int fuzz = os_random() % 20;
+		inactive_sec = hostapd_drv_get_inact_sec(hapd, sta->addr);
+		if (inactive_sec == -1) {
+			wpa_msg(hapd->msg_ctx, MSG_DEBUG,
+				"Check inactivity: Could not "
+				"get station info from kernel driver for "
+				MACSTR, MAC2STR(sta->addr));
+			/*
+			 * The driver may not support this functionality.
+			 * Anyway, try again after the next inactivity timeout,
+			 * but do not disconnect the station now.
+			 */
+			next_time = hapd->conf->ap_max_inactivity + fuzz;
+		} else if (inactive_sec == -ENOENT) {
+			wpa_msg(hapd->msg_ctx, MSG_DEBUG,
+				"Station " MACSTR " has lost its driver entry",
+				MAC2STR(sta->addr));
+
+			/* Avoid sending client probe on removed client */
+			sta->timeout_next = STA_DISASSOC;
+			goto skip_poll;
+		} else if (inactive_sec < hapd->conf->ap_max_inactivity) {
+			/* station activity detected; reset timeout state */
+			wpa_msg(hapd->msg_ctx, MSG_DEBUG,
+				"Station " MACSTR " has been active %is ago",
+				MAC2STR(sta->addr), inactive_sec);
+			sta->timeout_next = STA_NULLFUNC;
+			next_time = hapd->conf->ap_max_inactivity + fuzz -
+				inactive_sec;
+		} else {
+			wpa_msg(hapd->msg_ctx, MSG_DEBUG,
+				"Station " MACSTR " has been "
+				"inactive too long: %d sec, max allowed: %d",
+				MAC2STR(sta->addr), inactive_sec,
+				hapd->conf->ap_max_inactivity);
+			if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)) {
+				hapd1 = hapd->mxl_data.sibling_hapd;
+				if (!(sta->mxl_sta_info.ext_flags & WLAN_STA_SINGLE_LINK_ML_ASSOC)) {
+					sta1 = sta->mxl_sta_info.linked_sta;
+					if (sta1) {
+						inactive_sec = hostapd_drv_get_inact_sec(hapd1, sta1->addr);
+						if (inactive_sec != -1 && inactive_sec != -ENOENT) {
+							if (inactive_sec < hapd1->conf->ap_max_inactivity) {
+								sta->timeout_next = STA_NULLFUNC;
+								next_time = hapd->conf->ap_max_inactivity + fuzz;
+								wpa_msg(hapd->msg_ctx, MSG_DEBUG,
+										"Station " MACSTR " is inactive. Do not disconnect as this is ML STA",
+										MAC2STR(sta->addr));
+							}
+						}
+					}
+				}
+			}
+
+			if (hapd->conf->skip_inactivity_poll)
+				sta->timeout_next = STA_DISASSOC;
+		}
+	}
+
+	if ((sta->flags & WLAN_STA_ASSOC) &&
+			sta->timeout_next == STA_DISASSOC &&
+			!(sta->flags & WLAN_STA_PENDING_POLL) &&
+			!hapd->conf->skip_inactivity_poll) {
+		wpa_msg(hapd->msg_ctx, MSG_DEBUG, "Station " MACSTR
+				" has ACKed data poll", MAC2STR(sta->addr));
+		/* data nullfunc frame poll did not produce TX errors; assume
+		 * station ACKed it */
+		sta->timeout_next = STA_NULLFUNC;
+		next_time = hapd->conf->ap_max_inactivity;
+	}
+
+skip_poll:
+	if (next_time) {
+		wpa_printf(MSG_DEBUG, "%s: register ap_handle_timer timeout "
+			   "for " MACSTR " (%lu seconds)",
+			   __func__, MAC2STR(sta->addr), next_time);
+		eloop_register_timeout(next_time, 0, ap_handle_timer, hapd,
+				       sta);
+		return;
+	}
+
+	if (sta->timeout_next == STA_NULLFUNC &&
+	    (sta->flags & WLAN_STA_ASSOC)) {
+		wpa_printf(MSG_DEBUG, "  Polling STA");
+		sta->flags |= WLAN_STA_PENDING_POLL;
+		hostapd_drv_poll_client(hapd, hapd->own_addr, sta->addr,
+					sta->flags & WLAN_STA_WMM);
+	} else if (sta->timeout_next != STA_REMOVE) {
+		int deauth = sta->timeout_next == STA_DEAUTH;
+
+		if (!deauth && !(sta->flags & WLAN_STA_ASSOC)) {
+			/* Cannot disassociate not-associated STA, so move
+			 * directly to deauthentication. */
+			sta->timeout_next = STA_DEAUTH;
+
+			deauth = 1;
+		}
+
+		wpa_dbg(hapd->msg_ctx, MSG_DEBUG,
+			"Timeout, sending %s info to STA " MACSTR,
+			deauth ? "deauthentication" : "disassociation",
+			MAC2STR(sta->addr));
+
+		if (deauth) {
+			hostapd_drv_sta_deauth(
+				hapd, sta->addr,
+				WLAN_REASON_PREV_AUTH_NOT_VALID);
+		} else {
+			reason = (sta->timeout_next == STA_DISASSOC) ?
+				WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY :
+				WLAN_REASON_PREV_AUTH_NOT_VALID;
+
+			hostapd_drv_sta_disassoc(hapd, sta->addr, reason);
+		}
+	}
+
+	switch (sta->timeout_next) {
+	case STA_NULLFUNC:
+		sta->timeout_next = STA_DISASSOC;
+		wpa_printf(MSG_DEBUG, "%s: register ap_handle_timer timeout "
+			   "for " MACSTR " (%d seconds - AP_DISASSOC_DELAY)",
+			   __func__, MAC2STR(sta->addr), AP_DISASSOC_DELAY);
+		/* disassoc delay is maximum of listen interval, 3 seconds */
+		disassoc_delay = MAX(AP_DISASSOC_DELAY, (((sta->listen_interval * hostapd_get_beacon_int(hapd)) / 1000) + 1));
+		eloop_register_timeout(disassoc_delay, 0, ap_handle_timer,
+				       hapd, sta);
+		break;
+	case STA_DISASSOC:
+	case STA_DISASSOC_FROM_CLI:
+		sta->flags &= ~WLAN_STA_BSS_TRANS_MGMT_REQ_TIMEOUT;
+		reason = sta->disassoc_reason = (sta->timeout_next == STA_DISASSOC) ?
+						WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY :
+						WLAN_REASON_PREV_AUTH_NOT_VALID;
+		sta->disconnect_source = DISCONNECT_SOURCE_LOCAL;
+		ap_sta_set_authorized(hapd, sta, 0);
+		sta->flags &= ~WLAN_STA_ASSOC;
+		hostapd_set_sta_flags(hapd, sta);
+		ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+		if (!sta->acct_terminate_cause)
+			sta->acct_terminate_cause =
+				RADIUS_ACCT_TERMINATE_CAUSE_IDLE_TIMEOUT;
+		accounting_sta_stop(hapd, sta);
+		ieee802_1x_free_station(hapd, sta);
+		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+			       HOSTAPD_LEVEL_INFO, "disassociated due to "
+			       "inactivity");
+		sta->timeout_next = STA_DEAUTH;
+		wpa_printf(MSG_DEBUG, "%s: register ap_handle_timer timeout "
+			   "for " MACSTR " (%d seconds - AP_DEAUTH_DELAY)",
+			   __func__, MAC2STR(sta->addr), AP_DEAUTH_DELAY);
+		eloop_register_timeout(AP_DEAUTH_DELAY, 0, ap_handle_timer,
+				       hapd, sta);
+		mlme_disassociate_indication(hapd, sta, reason);
+		if (mxl_is_mlo_enabled(hapd->conf) && hapd->mxl_data.sibling_hapd) {
+			if (mxl_mlo_is_ml_sta(sta)) {
+				sta1 = sta->mxl_sta_info.linked_sta;
+				if (sta1)
+					sta1->timeout_next = sta->timeout_next;
+			}
+		}
+		break;
+	case STA_DEAUTH:
+	case STA_REMOVE:
+		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+			       HOSTAPD_LEVEL_INFO, "deauthenticated due to "
+			       "inactivity (timer DEAUTH/REMOVE)");
+		if (!sta->acct_terminate_cause)
+			sta->acct_terminate_cause =
+				RADIUS_ACCT_TERMINATE_CAUSE_IDLE_TIMEOUT;
+		mlme_deauthenticate_indication(
+			hapd, sta,
+			WLAN_REASON_PREV_AUTH_NOT_VALID);
+		if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+			mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+		}
+#ifdef UBUS_SUPPORT
+		hostapd_ubus_notify(hapd, "inactive-deauth", sta->addr);
+#endif /* UBUS_SUPPORT */
+		ap_free_sta(hapd, sta);
+		if (hapd1 && sta1) {
+			hostapd_logger(hapd1, sta1->addr, HOSTAPD_MODULE_IEEE80211,
+				       HOSTAPD_LEVEL_INFO, "deauthenticated due to "
+				       "inactivity (timer DEAUTH/REMOVE)");
+			if (!sta1->acct_terminate_cause)
+				sta1->acct_terminate_cause =
+					RADIUS_ACCT_TERMINATE_CAUSE_IDLE_TIMEOUT;
+			mlme_deauthenticate_indication(
+				 hapd1, sta1, WLAN_REASON_PREV_AUTH_NOT_VALID);
+			ap_free_sta(hapd1, sta1);
+		}
+		break;
+	}
+}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
diff --git a/src/ap/mxl_sta_info.h b/src/ap/mxl_sta_info.h
new file mode 100644
index 000000000..554c54445
--- /dev/null
+++ b/src/ap/mxl_sta_info.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#ifndef MXL_STA_INFO_H
+#define MXL_STA_INFO_H
+#include "utils/common.h"
+
+struct mxl_sta_info {
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	u8 non_ap_mld_mac[ETH_ALEN];
+	u8 sibling_sta_mac[ETH_ALEN];
+	struct sta_info *linked_sta;
+	u32 ext_flags; /* Bitfield of extended WLAN_STA_* */
+	u8 *sta_profile_ie;
+	size_t sta_profile_ie_len;
+	struct ieee80211_ml_capab sta_ml_capab;
+	u16 sta_profile_status;
+	struct ieee80211_ml_sta_info ml_sta_info;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+};
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+
+#define WLAN_STA_MULTILINK BIT(1)
+#define WLAN_STA_SINGLE_LINK_ML_ASSOC BIT(2)
+#define WLAN_STA_MLD_STA BIT(3) /* To determine MLD STA and also to check the STOP Traffic */
+#define WLAN_STA_MLD_WDS_STR_STA BIT(4)
+
+void mxl_ml_ap_handle_timer(void *eloop_ctx, void *timeout_ctx);
+
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+#endif /* MXL_STA_INFO_H */
diff --git a/src/ap/mxl_utils.c b/src/ap/mxl_utils.c
new file mode 100644
index 000000000..28b557b52
--- /dev/null
+++ b/src/ap/mxl_utils.c
@@ -0,0 +1,125 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#include "includes.h"
+
+#include "common.h"
+#include "common/ieee802_11_defs.h"
+#include "fst/fst.h"
+#include "sta_info.h"
+#include "hostapd.h"
+#include "common/ptksa_cache.h"
+#include "wpa_auth.h"
+#include "ap_mlme.h"
+#include "radius/radius.h"
+#include "ieee802_1x.h"
+#include "ap_drv_ops.h"
+#include "ap/mxl_utils.h"
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+void mxl_mlo_cleanup_mld_sta(struct hostapd_data * hapd, struct sta_info *sta)
+{
+	/* Clear the PTKSA cache entries for PASN */
+	ptksa_cache_flush(hapd->ptksa, sta->addr, WPA_CIPHER_NONE);
+
+	sta->flags &= ~WLAN_STA_BSS_TRANS_MGMT_REQ_TIMEOUT;
+	sta->deauth_reason = WLAN_REASON_UNSPECIFIED;
+	sta->disconnect_source = DISCONNECT_SOURCE_LOCAL;
+	ap_sta_set_authorized(hapd, sta, 0);
+	sta->last_seq_ctrl = WLAN_INVALID_MGMT_SEQ;
+	sta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC |
+			WLAN_STA_ASSOC_REQ_OK);
+	hostapd_set_sta_flags(hapd, sta);
+	wpa_auth_sm_event(sta->wpa_sm, WPA_DEAUTH);
+	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
+			HOSTAPD_LEVEL_DEBUG, "deauthenticated by Prune MLD");
+	mlme_deauthenticate_indication(
+			hapd, sta, WLAN_REASON_UNSPECIFIED);
+	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
+	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+	ap_free_sta(hapd, sta);
+}
+
+static int mxl_mlo_prune_associations_mld(struct hostapd_iface *iface, void *ctx)
+{
+	struct prune_data *data = ctx;
+	struct sta_info *osta, *linked_sta;
+	struct hostapd_data *ohapd;
+	size_t j;
+
+	for (j = 0; j < iface->num_bss; j++) {
+		ohapd = iface->bss[j];
+		if (ohapd == data->hapd)
+			continue;
+
+		osta = ap_get_sta(ohapd, data->addr);
+		if (!osta)
+			continue;
+
+		if (ohapd->conf->mxl_bss_conf.mlo_enable && ohapd->mxl_data.sibling_hapd) {
+			wpa_printf(MSG_INFO, "%s: Prune association MLD Sta " MACSTR,
+					ohapd->conf->iface, MAC2STR(osta->addr));
+			mxl_ml_stop_sta_traffic_remove_mld(ohapd, osta);
+			linked_sta = osta->mxl_sta_info.linked_sta;
+			mxl_mlo_cleanup_mld_sta(ohapd, osta);
+			if (linked_sta)
+				mxl_mlo_cleanup_mld_sta(ohapd->mxl_data.sibling_hapd, linked_sta);
+		}
+	}
+
+	return 0;
+}
+
+void mxl_mlo_hostapd_prune_associations_mld_mac(struct hostapd_data *hapd, struct sta_info *new_sta)
+{
+	struct sta_info *sta, *prev, *linked_sta;
+	/* static variable used to count number of prunes done for debug purpose*/
+	static u32 mld_prune_count = 0;
+
+	sta = hapd->sta_list;
+	while (sta) {
+		prev = sta;
+		sta = sta->next;
+
+		if (new_sta == prev)
+			continue;
+
+		if (mxl_mlo_is_ml_sta(prev)) {
+			if (os_memcmp(prev->mxl_sta_info.non_ap_mld_mac, new_sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN) &&
+					os_memcmp(prev->addr, new_sta->mxl_sta_info.non_ap_mld_mac, ETH_ALEN))
+				continue;
+
+			if (prev->flags & WLAN_STA_AUTH) {
+				mlme_deauthenticate_indication(
+						hapd, prev, WLAN_REASON_UNSPECIFIED);
+			}
+			mld_prune_count++;
+			wpa_printf(MSG_ERROR, "STA with same MLD MAC found. Removing station " MACSTR,
+					MAC2STR(prev->addr));
+			wpa_printf(MSG_ERROR,"MLD prune count %u", mld_prune_count);
+			mxl_ml_stop_sta_traffic_remove_mld(hapd, prev);
+			linked_sta = prev->mxl_sta_info.linked_sta;
+			mxl_mlo_cleanup_mld_sta(hapd, prev);
+			if (linked_sta)
+				mxl_mlo_cleanup_mld_sta(hapd->mxl_data.sibling_hapd, linked_sta);
+		}
+	}
+}
+
+void mxl_mlo_hostapd_prune_associations_mld(struct hostapd_data *hapd, const u8 *addr)
+{
+	struct prune_data data;
+	data.hapd = hapd;
+	data.addr = addr;
+	if (hapd->iface->interfaces &&
+			hapd->iface->interfaces->for_each_interface)
+		hapd->iface->interfaces->for_each_interface(
+				hapd->iface->interfaces, mxl_mlo_prune_associations_mld, &data);
+}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
diff --git a/src/ap/mxl_utils.h b/src/ap/mxl_utils.h
new file mode 100644
index 000000000..3ae7e2961
--- /dev/null
+++ b/src/ap/mxl_utils.h
@@ -0,0 +1,21 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#ifndef MXL_UTILS_H
+#define MXL_UTILS_H
+
+#ifdef CONFIG_VENDOR_MXL
+struct prune_data {
+	struct hostapd_data *hapd;
+	const u8 *addr;
+	int mld_assoc_link_id;
+};
+#endif /* CONFIG_VENDOR_MXL */
+
+#endif /* MXL_UTILS_H */
diff --git a/src/ap/mxl_wpa_auth.c b/src/ap/mxl_wpa_auth.c
index 853ade5f6..86ba8a702 100644
--- a/src/ap/mxl_wpa_auth.c
+++ b/src/ap/mxl_wpa_auth.c
@@ -38,6 +38,82 @@
 #include "wpa_auth_ie.h"
 
 #ifdef CONFIG_IEEE80211BE_MXL_MLO
+#define PN_LENGTH 6
+
+static int wpa_auth_ml_kdes_len(struct wpa_state_machine *sm, struct wpa_authenticator *wpa_auth, u8 *wpa_ie,
+				int wpa_ie_len, size_t gtk_len)
+{
+	int kde_len = 0;
+	const u8 *rsne = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_RSN);
+	const u8 *rsnxe = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_RSNX);
+	size_t len;
+
+	/* GTK = IE_HDR_LEN(2) + RSN_SELECTOR_LEN(4) + GTK_HDR_LEN(1) + PN_LENGTH(6) */
+	kde_len += (2 + RSN_SELECTOR_LEN + 1 + PN_LENGTH + gtk_len);
+
+	/* RSN/RSNX = IE_HDR_LEN(2) + RSN_SELECTOR_LEN(4) + LINK_INFO_LEN(1) + ETH_ALEN(6) */
+	kde_len += (2 + RSN_SELECTOR_LEN + 1 + ETH_ALEN);
+
+	/* RSN */
+	if (rsne)
+		kde_len += (rsne[1] + 2);
+
+	/* RSNX */
+	if (rsnxe)
+		kde_len += (rsnxe[1] + 2);
+
+	/* IGTK = IE_HDR_LEN(2) + RSN_SELECTOR_LEN(4) + IGTK_HDR_LEN(2) + PN_LENGTH(6) + LINK_INFO_LEN(1) + len */
+	len = wpa_cipher_key_len(wpa_auth->conf.group_mgmt_cipher);
+	kde_len += (2 + RSN_SELECTOR_LEN + 2 + PN_LENGTH + 1 + len);
+
+	/* BIGTK */
+	if (wpa_auth->conf.beacon_prot)
+		kde_len += mxl_ieee80211w_kde_len(sm) + mxl_ocv_oci_len(sm) + 1 /*LINK_INFO_LEN(1)*/;
+
+	return kde_len;
+}
+
+static u8 * wpa_auth_ml_kdes(u8 *pos, struct wpa_authenticator *wpa_auth, u8 *wpa_ie, int wpa_ie_len)
+{
+	u8 *kde;
+	u8 kde_len = (1 + ETH_ALEN);
+	const u8 *rsne = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_RSN);
+	const u8 *rsnxe = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_RSNX);
+
+	if (rsne)
+		kde_len = kde_len + rsne[1] + 2;
+	if (rsnxe)
+		kde_len = kde_len + rsnxe[1] + 2;
+
+	kde = os_malloc(kde_len);
+	if (!kde)
+		return NULL;
+
+	/* MLO link ID */
+	kde[0] = wpa_auth->mlo_conf.link1_linkid;
+	if (rsne)
+		kde[0] = kde[0] | (RSN_MLO_LINK_KDE_LI_RSNE_INFO);
+	if (rsnxe)
+		kde[0] = kde[0] | (RSN_MLO_LINK_KDE_LI_RSNXE_INFO);
+
+	/* MLO link MAC */
+	memcpy_s(&kde[1], ETH_ALEN, wpa_auth->mlo_conf.link1_mac, ETH_ALEN);
+
+	/* MLO link RSN */
+	if (rsne)
+		memcpy_s(&kde[1 + ETH_ALEN], rsne[1] + 2, rsne, rsne[1] + 2);
+
+	/* MLO link RSNX */
+	if (rsne && rsnxe)
+		memcpy_s(&kde[1 + ETH_ALEN + rsne[1] + 2], rsnxe[1] + 2, rsnxe, rsnxe[1] + 2);
+
+	pos = wpa_add_kde(pos, RSN_KEY_DATA_MLO_LINK, kde, kde_len, NULL, 0);
+
+	os_free(kde);
+
+	return pos;
+}
+
 void mxl_hostapd_wpa_auth_mlo(struct wpa_authenticator *wpa1, struct wpa_authenticator *wpa2)
 {
 	wpa1->mlo_conf.link2_linkid = wpa2->mlo_conf.link1_linkid;
@@ -58,6 +134,641 @@ void mxl_hostapd_wpa_auth_mlo_clear(struct wpa_authenticator *wpa1, struct wpa_a
 	wpa1->sibling_wpa_auth = NULL;
 	wpa2->sibling_wpa_auth = NULL;
 }
+
+void mxl_hostapd_wpa_auth_mlo_linkid(struct wpa_authenticator *wpa_auth, u8 linkid, u8 sibling_link_id)
+{
+	wpa_auth->mlo_conf.link1_linkid = linkid;
+	wpa_auth->mlo_conf.link2_linkid = sibling_link_id;
+}
+
+u8 * mxl_wpa_auth_ml_group_kdes(struct wpa_state_machine *sm, u8 *pos)
+{
+#define PN_LENGTH 6
+	struct wpa_authenticator *sibling_wpa_auth = sm->wpa_auth->sibling_wpa_auth;
+	struct wpa_group *gsm = NULL, *gsm1 = NULL;
+	size_t gtk_len = 0, gtk_len1 = 0, len = 0;
+	int gtkidx = 0, gtkidx1 = 0;
+	u8 *gtk = NULL, *gtk1 = NULL;
+	u8 gtk_hdr[1 + PN_LENGTH];
+	u8 igtk_hdr[2 + PN_LENGTH + 1 + 32];
+	u8 bigtk_hdr[2 + PN_LENGTH + 1 + 32];;
+	u8 rsc[WPA_KEY_RSC_LEN];
+
+	/* link 1 GTK info */
+	gsm = sm->group;
+	gtk = gsm->GTK[gsm->GN - 1];
+	gtk_len = gsm->GTK_len;
+	gtkidx = gsm->GN;
+
+	/* link 2 GTK info */
+	if (sibling_wpa_auth && !sm->mxl_sm.is_single_link_ml_sta) {
+		gsm1 = sibling_wpa_auth->group;
+		gtk1 = gsm1->GTK[gsm1->GN - 1];
+		gtk_len1 = gsm1->GTK_len;
+		gtkidx1 = gsm1->GN;
+	}
+
+	/* MLO link1 GTK KDE */
+	gtk_hdr[0] = gtkidx & 0x03;
+	gtk_hdr[0] = gtk_hdr[0] | (BIT(2));
+	gtk_hdr[0] |= (sm->wpa_auth->mlo_conf.link1_linkid << 4);
+	os_memset(&gtk_hdr[1], 0, PN_LENGTH);
+	pos = wpa_add_kde(pos, RSN_KEY_DATA_MLO_GTK, gtk_hdr, (1 + PN_LENGTH), gtk, gtk_len);
+
+	/* MLO link2 GTK KDE */
+	if (sibling_wpa_auth && !sm->mxl_sm.is_single_link_ml_sta) {
+		gtk_hdr[0] = gtkidx1 & 0x03;
+		gtk_hdr[0] = gtk_hdr[0] | (BIT(2));
+		gtk_hdr[0] |= (sm->wpa_auth->mlo_conf.link2_linkid << 4);
+		os_memset(&gtk_hdr[1], 0, PN_LENGTH);
+		pos = wpa_add_kde(pos, RSN_KEY_DATA_MLO_GTK, gtk_hdr, (1 + PN_LENGTH), gtk1, gtk_len1);
+	}
+
+	/* MLO link1 IGTK KDE */
+	igtk_hdr[0] = gsm->GN_igtk;
+	igtk_hdr[1] = 0;
+	os_memset(&igtk_hdr[2], 0, PN_LENGTH);
+	igtk_hdr[8] = (sm->wpa_auth->mlo_conf.link1_linkid << 4);
+	len = wpa_cipher_key_len(sm->wpa_auth->conf.group_mgmt_cipher);
+	memcpy_s(&igtk_hdr[9], len, gsm->IGTK[gsm->GN_igtk - 4], len);
+	pos = wpa_add_kde(pos, RSN_KEY_DATA_MLO_IGTK, igtk_hdr, 2 + PN_LENGTH + 1 + len, NULL, 0);
+
+	/* MLO link2 IGTK KDE */
+	if (sibling_wpa_auth && !sm->mxl_sm.is_single_link_ml_sta) {
+		igtk_hdr[0] = gsm1->GN_igtk;
+		igtk_hdr[1] = 0;
+		os_memset(&igtk_hdr[2], 0, PN_LENGTH);
+		igtk_hdr[8] = (sm->wpa_auth->mlo_conf.link2_linkid << 4);
+		memcpy_s(&igtk_hdr[9], len, gsm1->IGTK[gsm1->GN_igtk - 4], len);
+		pos = wpa_add_kde(pos, RSN_KEY_DATA_MLO_IGTK, igtk_hdr, 2 + PN_LENGTH + 1 + len, NULL, 0);
+	}
+
+	/* MLO link1 BIGTK KDE */
+	if (sm->wpa_auth->conf.beacon_prot) {
+		bigtk_hdr[0] = gsm->GN_bigtk;
+		bigtk_hdr[1] = 0;
+		if (gsm->wpa_group_state != WPA_GROUP_SETKEYSDONE ||
+		    mxl_wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_bigtk, rsc) < 0)
+			os_memset(&bigtk_hdr[2], 0, PN_LENGTH);
+		else
+			memcpy_s(&bigtk_hdr[2], PN_LENGTH, rsc, PN_LENGTH);
+
+		bigtk_hdr[8] = (sm->wpa_auth->mlo_conf.link1_linkid << 4);
+		memcpy_s(&bigtk_hdr[9], len, gsm->BIGTK[gsm->GN_bigtk - 6], len);
+		pos = wpa_add_kde(pos, RSN_KEY_DATA_MLO_BIGTK, bigtk_hdr, 2 + PN_LENGTH + 1 + len, NULL, 0);
+	}
+
+	/* MLO link2 BIGTK KDE */
+	if (sibling_wpa_auth && sibling_wpa_auth->conf.beacon_prot && !sm->mxl_sm.is_single_link_ml_sta) {
+		bigtk_hdr[0] = gsm1->GN_bigtk;
+		bigtk_hdr[1] = 0;
+		if (gsm1->wpa_group_state != WPA_GROUP_SETKEYSDONE ||
+		    mxl_wpa_auth_get_seqnum(sibling_wpa_auth, NULL, gsm1->GN_bigtk, rsc) < 0)
+			os_memset(&bigtk_hdr[2], 0, PN_LENGTH);
+		else
+			memcpy_s(&bigtk_hdr[2], PN_LENGTH, rsc, PN_LENGTH);
+
+		bigtk_hdr[8] = (sm->wpa_auth->mlo_conf.link2_linkid << 4);
+		memcpy_s(&bigtk_hdr[9], len, gsm1->BIGTK[gsm1->GN_bigtk - 6], len);
+		pos = wpa_add_kde(pos, RSN_KEY_DATA_MLO_BIGTK, bigtk_hdr, 2 + PN_LENGTH + 1 + len, NULL, 0);
+	}
+	return pos;
+}
+
+void mxl_ml_wpa_ptkinitnegotiating(struct wpa_state_machine *sm)
+{
+	u8 rsc[WPA_KEY_RSC_LEN], *_rsc, *kde = NULL, *pos, dummy_gtk[32];
+	size_t gtk_len, kde_len = 0;
+	struct wpa_group *gsm = sm->group;
+	u8 *wpa_ie;
+	u8 *wpa_ie_buf = NULL;
+	int wpa_ie_len, secure, encr = 0;
+	struct wpa_auth_config *conf = &sm->wpa_auth->conf;
+	struct wpa_authenticator *sibling_wpa_auth = sm->wpa_auth->sibling_wpa_auth;
+	size_t gtk_len1 = 0;
+	struct wpa_group *gsm1 = NULL;
+	u8 *sib_wpa_ie = NULL;
+	int sib_wpa_ie_len = 0;
+
+	sm->TimeoutEvt = false;
+
+	sm->TimeoutCtr++;
+	if (sm->wpa_auth->conf.wpa_disable_eapol_key_retries &&
+	    sm->TimeoutCtr > 1) {
+		/* Do not allow retransmission of EAPOL-Key msg 3/4 */
+		return;
+	}
+	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
+		/* No point in sending the EAPOL-Key - we will disconnect
+		 * immediately following this. */
+		return;
+	}
+
+	/* Send EAPOL(1, 1, 1, Pair, P, RSC, ANonce, MIC(PTK), RSNIE, [MDIE],
+	   GTK[GN], IGTK, [FTIE], [TIE * 2])
+	 */
+	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
+	mxl_wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, rsc);
+	/* If FT is used, wpa_auth->wpa_ie includes both RSNIE and MDIE */
+	wpa_ie = sm->wpa_auth->wpa_ie;
+	wpa_ie_len = sm->wpa_auth->wpa_ie_len;
+#ifdef CONFIG_TESTING_OPTIONS
+	if (sm->wpa_auth->conf.rsnxe_override_eapol_len) {
+		u8 *obuf = sm->wpa_auth->conf.rsnxe_override_eapol;
+		size_t olen = sm->wpa_auth->conf.rsnxe_override_eapol_len;
+		const u8 *rsnxe;
+
+		wpa_hexdump(MSG_DEBUG,
+			    "TESTING: wpa_ie before RSNXE EAPOL override",
+			    wpa_ie, wpa_ie_len);
+		wpa_ie_buf = os_malloc(wpa_ie_len + olen);
+		if (!wpa_ie_buf)
+			return;
+		os_memcpy(wpa_ie_buf, wpa_ie, wpa_ie_len);
+		wpa_ie = wpa_ie_buf;
+		rsnxe = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_RSNX);
+		if (rsnxe) {
+			u8 rsnxe_len = 2 + rsnxe[1];
+
+			os_memmove((void *) rsnxe, rsnxe + rsnxe_len,
+				   wpa_ie_len - (rsnxe - wpa_ie) - rsnxe_len);
+			wpa_ie_len -= rsnxe_len;
+		}
+		os_memcpy(wpa_ie + wpa_ie_len, obuf, olen);
+		wpa_ie_len += olen;
+		wpa_hexdump(MSG_DEBUG,
+			    "TESTING: wpa_ie after RSNXE EAPOL override",
+			    wpa_ie, wpa_ie_len);
+	}
+#endif /* CONFIG_TESTING_OPTIONS */
+	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
+			"sending 3/4 msg of 4-Way Handshake");
+	if (sm->wpa == WPA_VERSION_WPA2) {
+		/* WPA2 send GTK in the 4-way handshake */
+		secure = 1;
+		gtk_len = gsm->GTK_len;
+		if (sm->wpa_auth->conf.disable_gtk ||
+		    sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN) {
+			/*
+			 * Provide unique random GTK to each STA to prevent use
+			 * of GTK in the BSS.
+			 */
+			if (random_get_bytes(dummy_gtk, gtk_len) < 0)
+				goto done;
+		}
+		if (sibling_wpa_auth && !sm->mxl_sm.is_single_link_ml_sta) {
+			gsm1 = sibling_wpa_auth->group;
+			gtk_len1 = gsm1->GTK_len;
+		}
+		_rsc = rsc;
+		encr = 1;
+	} else {
+		/* WPA does not include GTK in msg 3/4 */
+		secure = 0;
+		gtk_len = 0;
+		_rsc = NULL;
+		if (sm->rx_eapol_key_secure) {
+			/*
+			 * It looks like Windows 7 supplicant tries to use
+			 * Secure bit in msg 2/4 after having reported Michael
+			 * MIC failure and it then rejects the 4-way handshake
+			 * if msg 3/4 does not set Secure bit. Work around this
+			 * by setting the Secure bit here even in the case of
+			 * WPA if the supplicant used it first.
+			 */
+			wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
+					"STA used Secure bit in WPA msg 2/4 - "
+					"set Secure for 3/4 as workaround");
+			secure = 1;
+		}
+	}
+
+	kde_len += mxl_ocv_oci_len(sm);
+
+#ifdef CONFIG_IEEE80211R_AP
+	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
+		kde_len += 2 + PMKID_LEN; /* PMKR1Name into RSN IE */
+		kde_len += 300; /* FTIE + 2 * TIE */
+	}
+#endif /* CONFIG_IEEE80211R_AP */
+#ifdef CONFIG_P2P
+	if (WPA_GET_BE32(sm->ip_addr) > 0)
+		kde_len += 2 + RSN_SELECTOR_LEN + 3 * 4;
+#endif /* CONFIG_P2P */
+
+	if (conf->transition_disable)
+		kde_len += 2 + RSN_SELECTOR_LEN + 1;
+
+	if (sm->mxl_sm.is_ml_sta) {
+		/* For the MAC address KDE */
+		kde_len += (2 + RSN_SELECTOR_LEN + ETH_ALEN);
+		/* MLO link 1 KDE len */
+		kde_len += wpa_auth_ml_kdes_len(sm, sm->wpa_auth, wpa_ie, wpa_ie_len, gtk_len);
+		if (sibling_wpa_auth) {
+			sib_wpa_ie = sibling_wpa_auth->wpa_ie;
+			sib_wpa_ie_len = sibling_wpa_auth->wpa_ie_len;
+
+		}
+		/* MLO link 2 KDE len */
+		if (sibling_wpa_auth && !sm->mxl_sm.is_single_link_ml_sta)
+			kde_len += wpa_auth_ml_kdes_len(sm, sibling_wpa_auth, sib_wpa_ie, sib_wpa_ie_len, gtk_len1);
+	}
+	kde = os_malloc(kde_len);
+	if (kde == NULL)
+		goto done;
+
+	pos = kde;
+
+#ifdef CONFIG_IEEE80211R_AP
+	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
+		int res;
+		size_t elen;
+
+		elen = pos - kde;
+		res = wpa_insert_pmkid(kde, &elen, sm->pmk_r1_name);
+		if (res < 0) {
+			wpa_printf(MSG_ERROR, "FT: Failed to insert "
+				   "PMKR1Name into RSN IE in EAPOL-Key data");
+			goto done;
+		}
+		pos -= wpa_ie_len;
+		pos += elen;
+	}
+#endif /* CONFIG_IEEE80211R_AP */
+	if (mxl_ocv_oci_add(sm, &pos, sm->wpa_auth->conf.oci_freq_override_eapol_m3) < 0)
+		goto done;
+
+#ifdef CONFIG_IEEE80211R_AP
+	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
+		int res;
+
+		if (sm->assoc_resp_ftie &&
+		    kde + kde_len - pos >= 2 + sm->assoc_resp_ftie[1]) {
+			os_memcpy(pos, sm->assoc_resp_ftie,
+				  2 + sm->assoc_resp_ftie[1]);
+			res = 2 + sm->assoc_resp_ftie[1];
+		} else {
+			int use_sha384 = wpa_key_mgmt_sha384(sm->wpa_key_mgmt);
+
+			res = wpa_write_ftie(conf, use_sha384,sm->xxkey_len,
+					     conf->r0_key_holder,
+					     conf->r0_key_holder_len,
+					     NULL, NULL, pos,
+					     kde + kde_len - pos,
+					     NULL, 0, 0);
+		}
+		if (res < 0) {
+			wpa_printf(MSG_ERROR, "FT: Failed to insert FTIE "
+				   "into EAPOL-Key Key Data");
+			goto done;
+		}
+		pos += res;
+
+		/* TIE[ReassociationDeadline] (TU) */
+		*pos++ = WLAN_EID_TIMEOUT_INTERVAL;
+		*pos++ = 5;
+		*pos++ = WLAN_TIMEOUT_REASSOC_DEADLINE;
+		WPA_PUT_LE32(pos, conf->reassociation_deadline);
+		pos += 4;
+
+		/* TIE[KeyLifetime] (seconds) */
+		*pos++ = WLAN_EID_TIMEOUT_INTERVAL;
+		*pos++ = 5;
+		*pos++ = WLAN_TIMEOUT_KEY_LIFETIME;
+		WPA_PUT_LE32(pos, conf->r0_key_lifetime);
+		pos += 4;
+	}
+#endif /* CONFIG_IEEE80211R_AP */
+#ifdef CONFIG_P2P
+	if (WPA_GET_BE32(sm->ip_addr) > 0) {
+		u8 addr[3 * 4];
+		os_memcpy(addr, sm->ip_addr, 4);
+		os_memcpy(addr + 4, sm->wpa_auth->conf.ip_addr_mask, 4);
+		os_memcpy(addr + 8, sm->wpa_auth->conf.ip_addr_go, 4);
+		pos = wpa_add_kde(pos, WFA_KEY_DATA_IP_ADDR_ALLOC,
+				  addr, sizeof(addr), NULL, 0);
+	}
+#endif /* CONFIG_P2P */
+
+#ifdef CONFIG_DPP2
+	if (DPP_VERSION > 1 && sm->wpa_key_mgmt == WPA_KEY_MGMT_DPP) {
+		u8 payload[2];
+
+		payload[0] = DPP_VERSION; /* Protocol Version */
+		payload[1] = 0; /* Flags */
+		if (conf->dpp_pfs == 0)
+			payload[1] |= DPP_KDE_PFS_ALLOWED;
+		else if (conf->dpp_pfs == 1)
+			payload[1] |= DPP_KDE_PFS_ALLOWED |
+				DPP_KDE_PFS_REQUIRED;
+		pos = wpa_add_kde(pos, WFA_KEY_DATA_DPP,
+				  payload, sizeof(payload), NULL, 0);
+	}
+#endif /* CONFIG_DPP2 */
+	if (conf->transition_disable)
+		pos = wpa_add_kde(pos, WFA_KEY_DATA_TRANSITION_DISABLE,
+				  &conf->transition_disable, 1, NULL, 0);
+
+	if (sm->mxl_sm.is_ml_sta) {
+		/* For the MAC Address KDE */
+		pos = wpa_add_kde(pos, RSN_KEY_DATA_MAC_ADDR, sm->wpa_auth->mlo_conf.ap_mld_mac, ETH_ALEN, NULL, 0);
+
+		/* MLO link 1 RSN/RSNX KDE */
+		pos = wpa_auth_ml_kdes(pos, sm->wpa_auth, wpa_ie, wpa_ie_len);
+		if (!pos) {
+			wpa_printf(MSG_ERROR, "Failed to pack MLO link 1 KDEs in 3/4 msg of 4-Way Handshake");
+			goto done;
+		}
+
+		if (sibling_wpa_auth && !sm->mxl_sm.is_single_link_ml_sta) {
+			/* MLO link 2 RSN/RSNX KDE */
+			pos = wpa_auth_ml_kdes(pos, sibling_wpa_auth, sib_wpa_ie, sib_wpa_ie_len);
+			if (!pos) {
+				wpa_printf(MSG_ERROR, "Failed to pack MLO link 2 KDEs in 3/4 msg of 4-Way Handshake");
+				goto done;
+			}
+		}
+
+		/* MLO Group KDEs */
+		pos = mxl_wpa_auth_ml_group_kdes(sm, pos);
+	}
+
+	mxl_wpa_send_eapol(sm->wpa_auth, sm,
+		       (secure ? WPA_KEY_INFO_SECURE : 0) |
+		       (wpa_mic_len(sm->wpa_key_mgmt, sm->pmk_len) ?
+		       WPA_KEY_INFO_MIC : 0) |
+		       WPA_KEY_INFO_ACK | WPA_KEY_INFO_INSTALL |
+		       WPA_KEY_INFO_KEY_TYPE,
+		       _rsc, sm->ANonce, kde, pos - kde, 0, encr);
+done:
+	os_free(kde);
+	os_free(wpa_ie_buf);
+}
+
+#define GROUP_KEY_SEQ_INIT 1
+void mxl_ml_wpa_ptk_group_rekeynegotiating(struct wpa_state_machine *sm)
+{
+	u8 rsc[WPA_KEY_RSC_LEN];
+	struct wpa_group *gsm = sm->group;
+	const u8 *kde;
+	u8 *kde_buf = NULL, *pos;
+	size_t kde_len;
+	u8 *gtk, dummy_gtk[32];
+	bool is_mld = false;
+	struct wpa_authenticator *sibling_wpa_auth = sm->wpa_auth->sibling_wpa_auth;
+	struct wpa_group *gsm1;
+	is_mld = sm->mxl_sm.is_ml_sta;
+
+
+	sm->GTimeoutCtr++;
+	if (sm->wpa_auth->conf.wpa_disable_eapol_key_retries &&
+	    sm->GTimeoutCtr > 1) {
+		/* Do not allow retransmission of EAPOL-Key group msg 1/2 */
+		return;
+	}
+	if (sm->GTimeoutCtr > sm->wpa_auth->conf.wpa_group_update_count) {
+		/* No point in sending the EAPOL-Key - we will disconnect
+		 * immediately following this. */
+		return;
+	}
+
+	if (sm->wpa == WPA_VERSION_WPA)
+		sm->PInitAKeys = false;
+	sm->TimeoutEvt = false;
+	/* Send EAPOL(1, 1, 1, !Pair, G, RSC, GNonce, MIC(PTK), GTK[GN]) */
+	/* Initialize group key seq/rsc during group key update */
+	/* No need to fetch RSC from downlayer.it would not have reset it to 1 during Group key msg 1
+	 * it will be reset after GTK update.
+	 */
+	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
+	rsc[0] = GROUP_KEY_SEQ_INIT;
+
+	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
+			"sending 1/2 msg of Group Key Handshake");
+
+	gtk = gsm->GTK[gsm->GN - 1];
+	if (sm->wpa_auth->conf.disable_gtk ||
+	    sm->wpa_key_mgmt == WPA_KEY_MGMT_OSEN) {
+		/*
+		 * Provide unique random GTK to each STA to prevent use
+		 * of GTK in the BSS.
+		 */
+		if (random_get_bytes(dummy_gtk, gsm->GTK_len) < 0)
+			return;
+		gtk = dummy_gtk;
+	}
+	if (sm->wpa == WPA_VERSION_WPA2 && is_mld) {
+		/* MLO Link1 GTK KDE length */
+		kde_len = (2 + 4 + 1 + PN_LENGTH + gsm->GTK_len);
+
+		/* MLO Link1 IGTK KDE length */
+		kde_len += mxl_ieee80211w_kde_len(sm) + 1; /* Link info */
+
+		/* MLO Link1 BIGTK KDE length */
+		if (sm->wpa_auth->conf.beacon_prot)
+			kde_len += mxl_ieee80211w_kde_len(sm) + mxl_ocv_oci_len(sm) + 1; /* Link info */
+
+		if (sibling_wpa_auth && !sm->mxl_sm.is_single_link_ml_sta) {
+			/* MLO Link2 GTK KDE length */
+			gsm1 = sibling_wpa_auth->group;
+			kde_len += (2 + 4 + 1 + PN_LENGTH + gsm1->GTK_len);
+
+			/* MLO Link2 IGTK KDE length */
+			kde_len += mxl_ieee80211w_kde_len(sm) + 1; /* Link info */
+
+			/* MLO Link2 BIGTK KDE length */
+			if (sibling_wpa_auth->conf.beacon_prot)
+				kde_len += mxl_ieee80211w_kde_len(sm) + mxl_ocv_oci_len(sm) + 1; /* Link info */
+		}
+
+		kde_buf = os_malloc(kde_len);
+		if (kde_buf == NULL)
+			return;
+
+		kde = pos = kde_buf;
+
+		/* MLO GROUP KDES */
+		pos = mxl_wpa_auth_ml_group_kdes(sm, pos);
+	} else {
+		kde = gtk;
+		kde_len = gsm->GTK_len;
+	}
+
+	mxl_wpa_send_eapol(sm->wpa_auth, sm,
+			WPA_KEY_INFO_SECURE |
+			(wpa_mic_len(sm->wpa_key_mgmt, sm->pmk_len) ?
+			 WPA_KEY_INFO_MIC : 0) |
+			WPA_KEY_INFO_ACK |
+			(!sm->Pair ? WPA_KEY_INFO_INSTALL : 0),
+			rsc, NULL, kde, kde_len, gsm->GN, 1);
+
+	os_free(kde_buf);
+}
+
+int mxl_ml_error_handling(struct wpa_eapol_ie_parse kde, struct wpa_state_machine *sm)
+{
+	if (kde.mac_addr) {
+		if (os_memcmp(kde.mac_addr, sm->mxl_sm.non_ap_mld_mac, ETH_ALEN)) {
+			wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
+					"received EAPOL-Key msg 2/4 with missmatch MLD ADDRESS!!!");
+			return -1;
+		}
+	}
+	if (kde.mlo_link_kde_ie) {
+		u8 link_id = (kde.mlo_link_kde_ie[0] & 0x3);
+		if ((link_id != sm->wpa_auth->mlo_conf.link1_linkid) && (link_id != sm->wpa_auth->mlo_conf.link2_linkid)) {
+			wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
+					"received EAPOL-Key msg 2/4 with missmatch MLD link_id!!!");
+			return -1;
+		}
+		/* To-do: we may compare the RSNE and RSNXE from MLO LINK KDE */
+	}
+	return 0;
+}
+
+void mxl_ml_wpa_ptkstart (struct wpa_state_machine *sm)
+{
+	u8 buf[4 + 2*RSN_SELECTOR_LEN + PMKID_LEN + ETH_ALEN], *pmkid = NULL, *kde = NULL;
+	size_t pmkid_len = 0, kde_len = 0;
+	u8 wpa_auth_addr[ETH_ALEN] = {0};
+
+	sm->PTKRequest = false;
+	sm->TimeoutEvt = false;
+	sm->alt_snonce_valid = false;
+	kde = buf;
+
+	sm->TimeoutCtr++;
+	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
+		/* No point in sending the EAPOL-Key - we will disconnect
+		 * immediately following this. */
+		return;
+	}
+
+	wpa_auth_logger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
+			"sending 1/4 msg of 4-Way Handshake");
+	/* MAC ADDRESS(AP_MLD_MAC) KDE */
+	kde_len = 2 + RSN_SELECTOR_LEN + ETH_ALEN;
+	kde[0] = WLAN_EID_VENDOR_SPECIFIC;
+	kde[1] = RSN_SELECTOR_LEN + ETH_ALEN;
+	RSN_SELECTOR_PUT(&kde[2], RSN_KEY_DATA_MAC_ADDR);
+	memcpy_s(&kde[2 + RSN_SELECTOR_LEN], ETH_ALEN, sm->wpa_auth->mlo_conf.ap_mld_mac, ETH_ALEN);
+	/*
+	 * For infrastructure BSS cases, it is better for the AP not to include
+	 * the PMKID KDE in EAPOL-Key msg 1/4 since it could be used to initiate
+	 * offline search for the passphrase/PSK without having to be able to
+	 * capture a 4-way handshake from a STA that has access to the network.
+	 *
+	 * For IBSS cases, addition of PMKID KDE could be considered even with
+	 * WPA2-PSK cases that use multiple PSKs, but only if there is a single
+	 * possible PSK for this STA. However, this should not be done unless
+	 * there is support for using that information on the supplicant side.
+	 * The concern about exposing PMKID unnecessarily in infrastructure BSS
+	 * cases would also apply here, but at least in the IBSS case, this
+	 * would cover a potential real use case.
+	 */
+	if (sm->wpa == WPA_VERSION_WPA2 &&
+			(wpa_key_mgmt_wpa_ieee8021x(sm->wpa_key_mgmt) ||
+			 (sm->wpa_key_mgmt == WPA_KEY_MGMT_OWE && sm->pmksa) ||
+			 wpa_key_mgmt_sae(sm->wpa_key_mgmt)) &&
+			sm->wpa_key_mgmt != WPA_KEY_MGMT_OSEN) {
+		pmkid = kde + kde_len;
+		pmkid_len = 2 + RSN_SELECTOR_LEN + PMKID_LEN;
+		pmkid[0] = WLAN_EID_VENDOR_SPECIFIC;
+		pmkid[1] = RSN_SELECTOR_LEN + PMKID_LEN;
+		RSN_SELECTOR_PUT(&pmkid[2], RSN_KEY_DATA_PMKID);
+		if (sm->pmksa) {
+			wpa_hexdump(MSG_DEBUG,
+					"RSN: Message 1/4 PMKID from PMKSA entry",
+					sm->pmksa->pmkid, PMKID_LEN);
+			os_memcpy(&pmkid[2 + RSN_SELECTOR_LEN],
+					sm->pmksa->pmkid, PMKID_LEN);
+		} else if (wpa_key_mgmt_suite_b(sm->wpa_key_mgmt)) {
+			/* No KCK available to derive PMKID */
+			wpa_printf(MSG_DEBUG,
+					"RSN: No KCK available to derive PMKID for message 1/4");
+			pmkid = NULL;
+#ifdef CONFIG_FILS
+		} else if (wpa_key_mgmt_fils(sm->wpa_key_mgmt)) {
+			if (sm->pmkid_set) {
+				wpa_hexdump(MSG_DEBUG,
+						"RSN: Message 1/4 PMKID from FILS/ERP",
+						sm->pmkid, PMKID_LEN);
+				os_memcpy(&pmkid[2 + RSN_SELECTOR_LEN],
+						sm->pmkid, PMKID_LEN);
+			} else {
+				/* No PMKID available */
+				wpa_printf(MSG_DEBUG,
+						"RSN: No FILS/ERP PMKID available for message 1/4");
+				pmkid = NULL;
+			}
+#endif /* CONFIG_FILS */
+#ifdef CONFIG_IEEE80211R_AP
+		} else if (wpa_key_mgmt_ft(sm->wpa_key_mgmt) &&
+				sm->ft_completed) {
+			wpa_printf(MSG_DEBUG,
+					"FT: No PMKID in message 1/4 when using FT protocol");
+			pmkid = NULL;
+#endif /* CONFIG_IEEE80211R_AP */
+#ifdef CONFIG_SAE
+		} else if (wpa_key_mgmt_sae(sm->wpa_key_mgmt)) {
+			if (sm->pmkid_set) {
+				wpa_hexdump(MSG_DEBUG,
+						"RSN: Message 1/4 PMKID from SAE",
+						sm->pmkid, PMKID_LEN);
+				os_memcpy(&pmkid[2 + RSN_SELECTOR_LEN],
+						sm->pmkid, PMKID_LEN);
+			} else {
+				/* No PMKID available */
+				wpa_printf(MSG_DEBUG,
+						"RSN: No SAE PMKID available for message 1/4");
+				pmkid = NULL;
+			}
+#endif /* CONFIG_SAE */
+		} else {
+			/*
+			 * Calculate PMKID since no PMKSA cache entry was
+			 * available with pre-calculated PMKID.
+			 */
+			memcpy_s(wpa_auth_addr, ETH_ALEN, sm->wpa_auth->addr, ETH_ALEN);
+			memcpy_s(wpa_auth_addr, ETH_ALEN, sm->wpa_auth->mlo_conf.ap_mld_mac, ETH_ALEN);
+			rsn_pmkid(sm->PMK, sm->pmk_len, /*sm->wpa_auth->addr*/wpa_auth_addr,
+					sm->addr, &pmkid[2 + RSN_SELECTOR_LEN],
+					sm->wpa_key_mgmt);
+			wpa_hexdump(MSG_DEBUG,
+					"RSN: Message 1/4 PMKID derived from PMK",
+					&pmkid[2 + RSN_SELECTOR_LEN], PMKID_LEN);
+		}
+	}
+	if (!pmkid)
+		pmkid_len = 0;
+	kde_len = kde_len + pmkid_len;
+	mxl_wpa_send_eapol(sm->wpa_auth, sm,
+			WPA_KEY_INFO_ACK | WPA_KEY_INFO_KEY_TYPE, NULL,
+			sm->ANonce, kde, kde_len, 0, 0);
+}
+
+struct rsn_pmksa_cache_entry *mxl_pmksa_cache_auth_get(struct wpa_state_machine *sm, struct rsn_pmksa_cache *pmksa,
+						u8 *spa, const u8 *pmkid)
+{
+	u8 *spa_addr = spa;
+	if (sm->mxl_sm.is_ml_sta)
+		spa_addr = sm->mxl_sm.non_ap_mld_mac;
+	return pmksa_cache_auth_get(pmksa, spa_addr, pmkid);
+}
+
+void mxl_wpa_auth_pmksa_add_sae_sibling(struct wpa_authenticator *wpa_auth, const u8 *addr,
+			   const u8 *pmk, size_t pmk_len, const u8 *pmkid,
+			   int akmp)
+{
+	struct rsn_pmksa_cache_entry *pos;
+
+	pos = pmksa_cache_auth_get(wpa_auth->pmksa, addr, NULL);
+	if (!pos) {
+		wpa_auth_pmksa_add_sae(wpa_auth, addr, pmk, pmk_len, pmkid, akmp);
+	} else {
+		wpa_printf(MSG_DEBUG, "RSN: linked_sta PMK already cached");
+	}
+}
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 /* Purpose of the API is to clear the "first_sta_seen" when all the STA's are flushed,
diff --git a/src/ap/mxl_wpa_auth.h b/src/ap/mxl_wpa_auth.h
index 645593d77..62810ccd1 100644
--- a/src/ap/mxl_wpa_auth.h
+++ b/src/ap/mxl_wpa_auth.h
@@ -17,6 +17,9 @@
 
 #ifdef CONFIG_IEEE80211BE_MXL_MLO
 struct wpa_authenticator;
+struct wpa_state_machine;
+struct rsn_pmksa_cache_entry;
+struct rsn_pmksa_cache;
 
 struct wpa_auth_mlo_conf {
 	u8 link1_linkid;
@@ -26,8 +29,34 @@ struct wpa_auth_mlo_conf {
 	u8 link2_mac[ETH_ALEN];
 };
 
+struct mxl_wpa_sm_mlo {
+	bool is_ml_sta;
+	bool is_single_link_ml_sta;
+	u8 non_ap_mld_mac[ETH_ALEN];
+	u8 sibling_sta_mac[ETH_ALEN];
+};
+
 void mxl_hostapd_wpa_auth_mlo(struct wpa_authenticator *wpa1, struct wpa_authenticator *wpa2);
 void mxl_hostapd_wpa_auth_mlo_clear(struct wpa_authenticator *wpa1, struct wpa_authenticator *wpa2);
+void mxl_hostapd_wpa_auth_mlo_linkid(struct wpa_authenticator *wpa_auth, u8 linkid, u8 sibling_link_id);
+int mxl_ocv_oci_len(struct wpa_state_machine *sm);
+int mxl_ocv_oci_add(struct wpa_state_machine *sm, u8 **argpos, unsigned int freq);
+void mxl_wpa_send_eapol(struct wpa_authenticator *wpa_auth,
+		struct wpa_state_machine *sm, int key_info,
+		const u8 *key_rsc, const u8 *nonce,
+		const u8 *kde, size_t kde_len,
+		int keyidx, int encr);
+int mxl_ieee80211w_kde_len(struct wpa_state_machine *sm);
+u8 * mxl_wpa_auth_ml_group_kdes(struct wpa_state_machine *sm, u8 *pos);
+int mxl_wpa_auth_get_seqnum(struct wpa_authenticator *wpa_auth,const u8 *addr, int idx, u8 *seq);
+void mxl_ml_wpa_ptkinitnegotiating(struct wpa_state_machine *sm);
+void mxl_ml_wpa_ptk_group_rekeynegotiating(struct wpa_state_machine *sm);
+int mxl_ml_error_handling(struct wpa_eapol_ie_parse kde, struct wpa_state_machine *sm);
+void mxl_ml_wpa_ptkstart (struct wpa_state_machine *sm);
+struct rsn_pmksa_cache_entry *mxl_pmksa_cache_auth_get(struct wpa_state_machine *sm, struct rsn_pmksa_cache *pmksa,
+						u8 *spa, const u8 *pmkid);
+void mxl_wpa_auth_pmksa_add_sae_sibling(struct wpa_authenticator *wpa_auth, const u8 *addr,
+						const u8 *pmk, size_t pmk_len, const u8 *pmkid, int akmp);
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 /* broadcast deauth reason - Recovery */
diff --git a/src/ap/mxl_wpa_auth_glue.c b/src/ap/mxl_wpa_auth_glue.c
index 0d7d5bbdd..e66061fbb 100644
--- a/src/ap/mxl_wpa_auth_glue.c
+++ b/src/ap/mxl_wpa_auth_glue.c
@@ -63,4 +63,46 @@ void mxl_hostapd_setup_wpa_mlo(struct hostapd_data *hapd, struct wpa_auth_config
 		}
 	}
 }
+
+void mxl_hostapd_setup_wpa_mlo_linkid(struct hostapd_data *hapd)
+{
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		mxl_hostapd_wpa_auth_mlo_linkid(hapd->wpa_auth, hapd->conf->mxl_bss_conf.link_id,
+						hapd->mxl_data.sibling_hapd->conf->mxl_bss_conf.link_id);
+	}
+}
+
+void mxl_mlo_hostapd_wpa_auth_disconnect(struct hostapd_data *hapd, const u8 *addr, u16 reason)
+{
+	struct hostapd_data *hapd1;
+	struct sta_info *sta, *sta1;
+
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		sta = ap_get_sta(hapd, addr);
+		if (sta && mxl_mlo_is_ml_sta(sta)) {
+			sta1 = sta->mxl_sta_info.linked_sta;
+			if (sta1 && (sta1 == ap_get_sta(hapd1, sta1->addr))) {
+				ap_sta_disconnect(hapd1, NULL, sta1->addr, reason);
+			}
+
+		}
+	}
+}
+
+void mxl_mlo_ieee802_1x_set_sta_authorized(struct hostapd_data *hapd, struct sta_info *sta, int value)
+{
+	struct hostapd_data *hapd1;
+	struct sta_info *sta1;
+
+	if (hapd->conf->mxl_bss_conf.mlo_enable && hapd->mxl_data.sibling_hapd) {
+		hapd1 = hapd->mxl_data.sibling_hapd;
+		if (mxl_mlo_is_ml_sta(sta)) {
+			sta1 = sta->mxl_sta_info.linked_sta;
+			if (sta1 && (sta1 == ap_get_sta(hapd1, sta1->addr))) {
+				ieee802_1x_set_sta_authorized(hapd1, sta1, value);
+			}
+		}
+	}
+}
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
diff --git a/src/ap/mxl_wpa_auth_glue.h b/src/ap/mxl_wpa_auth_glue.h
index 175910825..1896cfb07 100644
--- a/src/ap/mxl_wpa_auth_glue.h
+++ b/src/ap/mxl_wpa_auth_glue.h
@@ -14,5 +14,8 @@
 void mxl_hostapd_setup_mlo_wpa(struct hostapd_data *hapd);
 void mxl_hostapd_clear_mlo_wpa(struct hostapd_data *hapd);
 void mxl_hostapd_setup_wpa_mlo(struct hostapd_data *hapd, struct wpa_auth_config *conf);
+void mxl_hostapd_setup_wpa_mlo_linkid(struct hostapd_data *hapd);
+void mxl_mlo_hostapd_wpa_auth_disconnect(struct hostapd_data *hapd, const u8 *addr, u16 reason);
+void mxl_mlo_ieee802_1x_set_sta_authorized(struct hostapd_data *hapd, struct sta_info *sta, int value);
 #endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #endif /* MXL_WPA_AUTH_GLUE_H */
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index 86eb8836c..0b6dc4eea 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -41,6 +41,7 @@
 #include "wps_hostapd.h"
 #ifdef CONFIG_VENDOR_MXL
 #include "mxl_hostapd.h"
+#include "mxl_ieee802_11.h"
 #endif /* CONFIG_VENDOR_MXL */
 #ifdef CONFIG_WDS_WPA
 #include "rsn_supp/wpa.h"
@@ -241,6 +242,7 @@ void ap_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	ap_sta_list_del(hapd, sta);
 
 #ifdef CONFIG_VENDOR_MXL
+if (!mxl_hostapd_is_recovery(hapd->iface))
 	mxl_hostapd_free_aid(hapd, sta);
 #endif /* CONFIG_VENDOR_MXL */
 
@@ -372,6 +374,13 @@ void ap_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	}
 #endif /* CONFIG_NO_VLAN */
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && sta->mxl_sta_info.linked_sta) {
+		/* Unlink this STA from it's sibling STA */
+		sta->mxl_sta_info.linked_sta->mxl_sta_info.linked_sta = NULL;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 	os_free(sta->challenge);
 
 	os_free(sta->sa_query_trans_id);
@@ -413,6 +422,10 @@ void ap_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	wpabuf_free(sta->hs20_deauth_req);
 	os_free(sta->hs20_session_info_url);
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	mxl_free_sta_profile(hapd, sta);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef CONFIG_SAE
 	sae_clear_data(sta->sae);
 	os_free(sta->sae);
@@ -502,6 +515,12 @@ void ap_handle_timer(void *eloop_ctx, void *timeout_ctx)
 	u16 reason;
 	unsigned int disassoc_delay;
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf)) {
+		mxl_ml_ap_handle_timer(eloop_ctx, timeout_ctx);
+		return;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	wpa_printf(MSG_DEBUG, "%s: %s: " MACSTR " flags=0x%x timeout_next=%d",
 		   hapd->conf->iface, __func__, MAC2STR(sta->addr), sta->flags,
 		   sta->timeout_next);
@@ -892,6 +911,9 @@ static int ap_sta_remove(struct hostapd_data *hapd, struct sta_info *sta)
 			   hapd->conf->iface, MAC2STR(sta->addr));
 		return -1;
 	}
+#ifdef CONFIG_VENDOR_MXL
+	mxl_hostapd_free_aid(hapd, sta);
+#endif /* CONFIG_VENDOR_MXL */
 	sta->added_unassoc = 0;
 	return 0;
 }
@@ -933,6 +955,11 @@ static void ap_sta_disassoc_cb_timeout(void *eloop_ctx, void *timeout_ctx)
 
 	wpa_printf(MSG_DEBUG, "%s: Disassociation callback for STA " MACSTR,
 		   hapd->conf->iface, MAC2STR(sta->addr));
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && hapd->mxl_data.sibling_hapd) {
+		mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	ap_sta_remove(hapd, sta);
 	mlme_disassociate_indication(hapd, sta, sta->disassoc_reason);
 }
@@ -994,6 +1021,11 @@ static void ap_sta_deauth_cb_timeout(void *eloop_ctx, void *timeout_ctx)
 
 	wpa_printf(MSG_DEBUG, "%s: Deauthentication callback for STA " MACSTR,
 		   hapd->conf->iface, MAC2STR(sta->addr));
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (mxl_is_mlo_enabled(hapd->conf) && hapd->mxl_data.sibling_hapd) {
+		mxl_ml_stop_sta_traffic_remove_mld(hapd, sta);
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	ap_sta_remove(hapd, sta);
 	mlme_deauthenticate_indication(hapd, sta, sta->deauth_reason);
 }
@@ -1823,6 +1855,14 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 		if (mld_assoc_link_id != -2)
 			hostapd_prune_associations(hapd, sta->addr,
 						   mld_assoc_link_id);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (mxl_mlo_is_ml_sta(sta)) {
+			/* Purge existing STA entry which matches with the current STA's MLD MAC */
+			if (sta->mxl_sta_info.linked_sta &&
+				os_memcmp(sta->mxl_sta_info.non_ap_mld_mac, sta->mxl_sta_info.linked_sta->addr, ETH_ALEN))
+				hostapd_prune_associations(hapd, sta->mxl_sta_info.non_ap_mld_mac, mld_assoc_link_id);
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		sta->flags |= WLAN_STA_AUTHORIZED;
 	} else {
 		sta->flags &= ~WLAN_STA_AUTHORIZED;
diff --git a/src/ap/sta_info.h b/src/ap/sta_info.h
index dab35f392..6d704219d 100644
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -17,6 +17,9 @@
 #include "common/sae.h"
 #include "crypto/sha384.h"
 #include "pasn/pasn_common.h"
+#ifdef CONFIG_VENDOR_MXL
+#include "mxl_sta_info.h"
+#endif /* CONFIG_VENDOR_MXL */
 
 /* STA flags */
 #define WLAN_STA_AUTH BIT(0)
@@ -368,6 +371,9 @@ struct sta_info {
 	struct ieee80211_mgmt *last_assoc_req;
 	size_t last_assoc_req_len;
 	enum sta_disconnect_source disconnect_source;
+#ifdef CONFIG_VENDOR_MXL
+	struct mxl_sta_info mxl_sta_info;
+#endif /* CONFIG_VENDOR_MXL */
 };
 
 
diff --git a/src/ap/utils.c b/src/ap/utils.c
index 3ba746775..0938e2398 100644
--- a/src/ap/utils.c
+++ b/src/ap/utils.c
@@ -13,6 +13,9 @@
 #include "fst/fst.h"
 #include "sta_info.h"
 #include "hostapd.h"
+#ifdef CONFIG_VENDOR_MXL
+#include "ap/mxl_utils.h"
+#endif /* CONFIG_VENDOR_MXL */
 
 
 int hostapd_register_probereq_cb(struct hostapd_data *hapd,
@@ -40,11 +43,13 @@ int hostapd_register_probereq_cb(struct hostapd_data *hapd,
 }
 
 
+#ifndef CONFIG_VENDOR_MXL
 struct prune_data {
 	struct hostapd_data *hapd;
 	const u8 *addr;
 	int mld_assoc_link_id;
 };
+#endif /* CONFIG_VENDOR_MXL */
 
 static int prune_associations(struct hostapd_iface *iface, void *ctx)
 {
diff --git a/src/ap/wnm_ap.c b/src/ap/wnm_ap.c
index cc5ad3bbd..832d3994a 100644
--- a/src/ap/wnm_ap.c
+++ b/src/ap/wnm_ap.c
@@ -1089,6 +1089,15 @@ static void set_disassoc_timer(struct hostapd_data *hapd, struct sta_info *sta,
 	 * full authentication with the authentication server (which may
 	 * decide to reject the connection),
 	 */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	u8 *spa_addr;
+	if (mxl_is_mlo_enabled(hapd->conf) && mxl_mlo_is_ml_sta(sta)){
+		spa_addr = sta->mxl_sta_info.non_ap_mld_mac;
+		if (sta->mxl_sta_info.linked_sta) {
+			wpa_auth_pmksa_remove(hapd->mxl_data.sibling_hapd->wpa_auth, spa_addr);
+		}
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	wpa_auth_pmksa_remove(hapd->wpa_auth, sta->addr);
 
 	beacon_int = hostapd_get_beacon_int(hapd);
@@ -1236,6 +1245,9 @@ int wnm_send_bss_tm_req(struct hostapd_data *hapd, struct sta_info *sta,
 	os_free(buf);
 
 	if (disassoc_timer) {
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (!hapd->conf->mxl_bss_conf.mlo_t2lm_support)
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		/* send disassociation frame after time-out */
 		set_disassoc_timer(hapd, sta, disassoc_timer);
 	}
diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
index b4846cf98..ea60b38a2 100644
--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -89,6 +89,10 @@ static const u8 * wpa_auth_get_aa(const struct wpa_state_machine *sm)
 	if (sm->mld_assoc_link_id >= 0)
 		return sm->own_mld_addr;
 #endif /* CONFIG_IEEE80211BE */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta)
+		return sm->wpa_auth->mlo_conf.ap_mld_mac;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	return sm->wpa_auth->addr;
 }
 
@@ -99,6 +103,10 @@ static const u8 * wpa_auth_get_spa(const struct wpa_state_machine *sm)
 	if (sm->mld_assoc_link_id >= 0)
 		return sm->peer_mld_addr;
 #endif /* CONFIG_IEEE80211BE */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta)
+		return sm->mxl_sm.non_ap_mld_mac;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	return sm->addr;
 }
 
@@ -1105,6 +1113,9 @@ void wpa_receive(struct wpa_authenticator *wpa_auth,
 #ifdef CONFIG_IEEE80211BE
 	is_mld = sm->mld_assoc_link_id >= 0;
 #endif /* CONFIG_IEEE80211BE */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	is_mld = sm->mxl_sm.is_ml_sta;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 	wpa_hexdump(MSG_MSGDUMP, "WPA: RX EAPOL data", data, data_len);
 
@@ -1924,6 +1935,14 @@ void wpa_remove_ptk(struct wpa_state_machine *sm)
 			     0, KEY_FLAG_PAIRWISE))
 		wpa_printf(MSG_DEBUG,
 			   "RSN: PTK Key ID 1 removal from the driver failed");
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta && !sm->mxl_sm.is_single_link_ml_sta) {
+		if (wpa_auth_set_key(sm->wpa_auth->sibling_wpa_auth, 0, WPA_ALG_NONE, sm->mxl_sm.sibling_sta_mac, 0, NULL,
+					0, KEY_FLAG_PAIRWISE)) {
+			wpa_printf(MSG_DEBUG, "RSN: PTK removal from the driver failed for sibling STA");
+		}
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	sm->pairwise_set = false;
 	eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
 }
@@ -2180,6 +2199,10 @@ SM_STATE(WPA_PTK, AUTHENTICATION2)
 	SM_ENTRY_MA(WPA_PTK, AUTHENTICATION2, wpa_ptk);
 
 	wpa_group_ensure_init(sm->wpa_auth, sm->group);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta && !sm->mxl_sm.is_single_link_ml_sta)
+		wpa_group_ensure_init(sm->wpa_auth->sibling_wpa_auth, sm->wpa_auth->sibling_wpa_auth->group);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	sm->ReAuthenticationRequest = false;
 
 	/*
@@ -2341,6 +2364,12 @@ SM_STATE(WPA_PTK, PTKSTART)
 	u16 key_info;
 
 	SM_ENTRY_MA(WPA_PTK, PTKSTART, wpa_ptk);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta) {
+		mxl_ml_wpa_ptkstart(sm);
+		return;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	sm->PTKRequest = false;
 	sm->TimeoutEvt = false;
 	sm->alt_snonce_valid = false;
@@ -3100,6 +3129,15 @@ int fils_set_tk(struct wpa_state_machine *sm)
 		return -1;
 	}
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta && !sm->mxl_sm.is_single_link_ml_sta) {
+		if (wpa_auth_set_key(sm->wpa_auth->sibling_wpa_auth, 0, alg, sm->mxl_sm.sibling_sta_mac, 0,
+					sm->PTK.tk, klen, KEY_FLAG_PAIRWISE_RX_TX)) {
+			wpa_printf(MSG_DEBUG, "FILS: Failed to set TK to the driver for sibling STA");
+			return -1;
+		}
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #ifdef CONFIG_PASN
 	if (sm->wpa_auth->conf.secure_ltf &&
 	    ieee802_11_rsnx_capab(sm->rsnxe, WLAN_RSNX_CAPAB_SECURE_LTF) &&
@@ -3383,6 +3421,12 @@ SM_STATE(WPA_PTK, PTKCALCNEGOTIATING)
 		eapol_key_ie = kde.wpa_ie;
 		eapol_key_ie_len = kde.wpa_ie_len;
 	}
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta){
+		if (mxl_ml_error_handling(kde, sm))
+			return;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	ft = sm->wpa == WPA_VERSION_WPA2 && wpa_key_mgmt_ft(sm->wpa_key_mgmt);
 	if (!sm->wpa_ie ||
 	    wpa_compare_rsn_ie(ft, sm->wpa_ie, sm->wpa_ie_len,
@@ -4116,6 +4160,12 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 #endif /* CONFIG_IEEE80211BE */
 
 	SM_ENTRY_MA(WPA_PTK, PTKINITNEGOTIATING, wpa_ptk);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta) {
+		mxl_ml_wpa_ptkinitnegotiating(sm);
+		return;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	sm->TimeoutEvt = false;
 
 	sm->TimeoutCtr++;
@@ -4489,6 +4539,16 @@ SM_STATE(WPA_PTK, PTKINITDONE)
 		}
 #endif /* CONFIG_PASN */
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (sm->mxl_sm.is_ml_sta && !sm->mxl_sm.is_single_link_ml_sta) {
+			if (wpa_auth_set_key(sm->wpa_auth->sibling_wpa_auth, 0, alg, sm->mxl_sm.sibling_sta_mac, 0,
+						sm->PTK.tk, klen, KEY_FLAG_PAIRWISE_RX_TX)) {
+				wpa_sta_disconnect(sm->wpa_auth->sibling_wpa_auth, sm->mxl_sm.sibling_sta_mac,
+						WLAN_REASON_PREV_AUTH_NOT_VALID);
+				return;
+			}
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		/* FIX: MLME-SetProtection.Request(TA, Tx_Rx) */
 		sm->pairwise_set = true;
 
@@ -4704,6 +4764,12 @@ SM_STATE(WPA_PTK_GROUP, REKEYNEGOTIATING)
 
 	SM_ENTRY_MA(WPA_PTK_GROUP, REKEYNEGOTIATING, wpa_ptk_group);
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta) {
+		mxl_ml_wpa_ptk_group_rekeynegotiating(sm);
+		return;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 	sm->GTimeoutCtr++;
 	if (conf->wpa_disable_eapol_key_retries && sm->GTimeoutCtr > 1) {
 		/* Do not allow retransmission of EAPOL-Key group msg 1/2 */
@@ -6844,6 +6910,39 @@ fail:
 	return NULL;
 }
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+int mxl_ocv_oci_len(struct wpa_state_machine *sm)
+{
+	return ocv_oci_len(sm);
+}
+
+int mxl_ocv_oci_add(struct wpa_state_machine *sm, u8 **argpos,
+		unsigned int freq)
+{
+	return ocv_oci_add(sm, argpos, freq);
+}
+
+void mxl_wpa_send_eapol(struct wpa_authenticator *wpa_auth,
+			struct wpa_state_machine *sm, int key_info,
+			const u8 *key_rsc, const u8 *nonce,
+			const u8 *kde, size_t kde_len,
+			int keyidx, int encr)
+{
+	return wpa_send_eapol(wpa_auth, sm, key_info, key_rsc, nonce, kde, kde_len, keyidx, encr);
+}
+
+int mxl_wpa_auth_get_seqnum(struct wpa_authenticator *wpa_auth,
+		const u8 *addr, int idx, u8 *seq)
+{
+	return wpa_auth_get_seqnum(wpa_auth, addr, idx, seq);
+}
+
+int mxl_ieee80211w_kde_len(struct wpa_state_machine *sm)
+{
+	return ieee80211w_kde_len(sm);
+}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
 #ifdef AES_GMAC_AVAILABLE
 u8 * bip_gmac_protect(struct wpa_authenticator *wpa_auth,
 		u8 *frame, size_t len, size_t *prot_len)
diff --git a/src/ap/wpa_auth_ft.c b/src/ap/wpa_auth_ft.c
index daf4cab46..aa6a71e7a 100644
--- a/src/ap/wpa_auth_ft.c
+++ b/src/ap/wpa_auth_ft.c
@@ -2946,6 +2946,13 @@ void wpa_ft_install_ptk(struct wpa_state_machine *sm, int retry)
 			     sm->PTK.tk, klen, KEY_FLAG_PAIRWISE_RX_TX))
 		return;
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (sm->mxl_sm.is_ml_sta && !sm->mxl_sm.is_single_link_ml_sta) {
+		if (wpa_auth_set_key(sm->wpa_auth->sibling_wpa_auth, 0, alg, sm->wpa_auth->sibling_wpa_auth->addr, 0,
+					sm->PTK.tk, klen, KEY_FLAG_PAIRWISE_RX_TX))
+			return;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #ifdef CONFIG_PASN
 	if (sm->wpa_auth->conf.secure_ltf &&
 	    ieee802_11_rsnx_capab(sm->rsnxe, WLAN_RSNX_CAPAB_SECURE_LTF) &&
diff --git a/src/ap/wpa_auth_glue.c b/src/ap/wpa_auth_glue.c
index d11390b25..c6a53b80f 100644
--- a/src/ap/wpa_auth_glue.c
+++ b/src/ap/wpa_auth_glue.c
@@ -33,6 +33,7 @@
 #include "pmksa_cache_auth.h"
 #include "wpa_auth.h"
 #include "wpa_auth_glue.h"
+#include "wpa_auth_i.h"
 #ifdef CONFIG_VENDOR_MXL
 #include "mxl_wpa_auth_glue.h"
 #endif /* CONFIG_VENDOR_MXL */
@@ -256,6 +257,9 @@ static void hostapd_wpa_auth_disconnect(void *ctx, const u8 *addr,
 		   "STA " MACSTR " reason %d",
 		   __func__, MAC2STR(addr), reason);
 	ap_sta_disconnect(hapd, NULL, addr, reason);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	mxl_mlo_hostapd_wpa_auth_disconnect(hapd, addr, reason);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 }
 
 
@@ -293,6 +297,10 @@ static void hostapd_wpa_auth_set_eapol(void *ctx, const u8 *addr,
 		break;
 	case WPA_EAPOL_authorized:
 		ieee802_1x_set_sta_authorized(hapd, sta, value);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (sta->mxl_sta_info.ext_flags & WLAN_STA_MLD_STA)
+			mxl_mlo_ieee802_1x_set_sta_authorized(hapd, sta, value);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		break;
 	case WPA_EAPOL_portControl_Auto:
 		if (sta->eapol_sm)
diff --git a/src/ap/wpa_auth_i.h b/src/ap/wpa_auth_i.h
index 6998e79cc..e0d6a3504 100644
--- a/src/ap/wpa_auth_i.h
+++ b/src/ap/wpa_auth_i.h
@@ -192,6 +192,9 @@ struct wpa_state_machine {
 		const u8 *rsnxe;
 		size_t rsnxe_len;
 	} mld_links[MAX_NUM_MLD_LINKS];
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	struct mxl_wpa_sm_mlo mxl_sm;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 #endif /* CONFIG_IEEE80211BE */
 };
 
diff --git a/src/ap/wpa_auth_ie.c b/src/ap/wpa_auth_ie.c
index 92f379961..c91e41195 100644
--- a/src/ap/wpa_auth_ie.c
+++ b/src/ap/wpa_auth_ie.c
@@ -1003,8 +1003,17 @@ wpa_validate_wpa_ie(struct wpa_authenticator *wpa_auth,
 	for (i = 0; i < data.num_pmkid; i++) {
 		wpa_hexdump(MSG_DEBUG, "RSN IE: STA PMKID",
 			    &data.pmkid[i * PMKID_LEN], PMKID_LEN);
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		u8 *spa_addr;
+		spa_addr = sm->addr;
+		if (sm->mxl_sm.is_ml_sta)
+			spa_addr = sm->mxl_sm.non_ap_mld_mac;
+		sm->pmksa = mxl_pmksa_cache_auth_get(sm, wpa_auth->pmksa, spa_addr,
+						 &data.pmkid[i * PMKID_LEN]);
+#else /* CONFIG_IEEE80211BE_MXL_MLO */
 		sm->pmksa = pmksa_cache_auth_get(wpa_auth->pmksa, sm->addr,
 						 &data.pmkid[i * PMKID_LEN]);
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		if (sm->pmksa) {
 			pmkid = sm->pmksa->pmkid;
 			break;
@@ -1058,6 +1067,17 @@ wpa_validate_wpa_ie(struct wpa_authenticator *wpa_auth,
 		if (!ap_sae_offload && data.num_pmkid && !sm->pmksa) {
 			wpa_auth_vlogger(wpa_auth, sm->addr, LOGGER_DEBUG,
 					 "No PMKSA cache entry found for SAE");
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+			/* IN ML assoc, PMK is not cached in other link
+			 * in case of double link ML association
+			 * Do not fail assoc for missing PMKID in cache
+			 * for double link ML association
+			 * TODO - to revisit the implementation to check
+			 * add/remove PMKID in sibling link cache as well
+			 */
+			if (!sm->mxl_sm.is_ml_sta ||
+					(sm->mxl_sm.is_ml_sta && sm->mxl_sm.is_single_link_ml_sta))
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 			return WPA_INVALID_PMKID;
 		}
 	}
diff --git a/src/common/mxl_defs.h b/src/common/mxl_defs.h
index af45247dc..136699b5e 100644
--- a/src/common/mxl_defs.h
+++ b/src/common/mxl_defs.h
@@ -29,4 +29,8 @@
 #define SUBBAND_DFS_MIN			0
 #define SUBBAND_DFS_MAX			60
 
+//These are arbitrarily calculated values
+#define ML_IE_LINK_INFO_TSF_OFFSET_MIN  (-500)
+#define ML_IE_LINK_INFO_TSF_OFFSET_MAX  500
+
 #endif /* MXL_DEFS_H */
diff --git a/src/common/mxl_ieee802_11_defs.h b/src/common/mxl_ieee802_11_defs.h
index 354e737e8..d19dea30d 100644
--- a/src/common/mxl_ieee802_11_defs.h
+++ b/src/common/mxl_ieee802_11_defs.h
@@ -120,6 +120,19 @@ struct beacon_body {
 	le16 capab_info;
 };
 
+struct ieee80211_ml_capab {
+	u16 ml_control_field;
+	u16 eml_capab;
+	u16 mld_capab_oper;
+	u8 mld_id;
+} STRUCT_PACKED;
+
+struct ieee80211_ml_sta_info {
+	bool is_ml;
+	u8 mld_mac[ETH_ALEN];
+	u8 linked_sta_mac[ETH_ALEN];
+} STRUCT_PACKED;
+
 struct beacon_request {
 	u8 src_addr[ETH_ALEN];
 	u8 dialog_token;
diff --git a/src/common/mxl_sae.h b/src/common/mxl_sae.h
new file mode 100644
index 000000000..723dd3568
--- /dev/null
+++ b/src/common/mxl_sae.h
@@ -0,0 +1,20 @@
+/******************************************************************************
+
+         Copyright (c) 2023 - 2024, MaxLinear, Inc.
+
+  This software may be distributed under the terms of the BSD license.
+  See README for more details.
+
+*******************************************************************************/
+
+#ifndef MXL_SAE_H
+#define MXL_SAE_H
+
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+struct mxl_sae_temporary_data {
+	u8 own_mld_addr[ETH_ALEN];
+	u8 peer_mld_addr[ETH_ALEN];
+};
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+
+#endif /* MXL_SAE_H */
diff --git a/src/common/sae.h b/src/common/sae.h
index c446da396..ecc3b6915 100644
--- a/src/common/sae.h
+++ b/src/common/sae.h
@@ -9,6 +9,10 @@
 #ifndef SAE_H
 #define SAE_H
 
+#ifdef CONFIG_VENDOR_MXL
+#include "common/mxl_sae.h"
+#endif /* CONFIG_VENDOR_MXL */
+
 #define SAE_KCK_LEN 32
 #define SAE_PMK_LEN 32
 #define SAE_PMK_LEN_MAX 64
@@ -82,6 +86,9 @@ struct sae_temporary_data {
 	bool omit_pk_elem;
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_SAE_PK */
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	struct mxl_sae_temporary_data mxl_sae_tmp_data;
+#endif
 };
 
 struct sae_pt {
diff --git a/src/common/vendor_cmds_copy.h b/src/common/vendor_cmds_copy.h
index 622f53466..1c45835f9 100644
--- a/src/common/vendor_cmds_copy.h
+++ b/src/common/vendor_cmds_copy.h
@@ -411,6 +411,7 @@ enum ltq_nl80211_vendor_subcmds {
   LTQ_NL80211_VENDOR_SUBCMD_SET_STR_TID_LINK_SPREADING,
   LTQ_NL80211_VENDOR_SUBCMD_REG_UPDATE_6GHZ_OPER_POWER_MODE,
   LTQ_NL80211_VENDOR_SUBCMD_UPDATE_AFC_INFO,
+  LTQ_NL80211_VENDOR_SUBCMD_ML_STA_REASSOC_NOTIFY,
   /* add new iw sub commands here */
 
   /* used to define LTQ_NL80211_VENDOR_SUBCMD_MAX below */
@@ -653,6 +654,38 @@ struct mxl_mld_remove {
   u8 sendto_fw;
 } __attribute__ ((packed));
 
+struct mxl_sta_mld_remove {
+  u16 aid;
+  u8 sendto_fw;
+} __attribute__ ((packed));
+
+struct mxl_vendor_ml_sid {
+  u16 sid[3];
+} __attribute__ ((packed));
+
+struct mxl_ml_sta_mac_addr {
+  u8 addr1[ETH_ALEN];
+  u8 addr2[ETH_ALEN];
+  u8 addr3[ETH_ALEN];
+  u8 assoc_link_bitmap;
+} __attribute__ ((packed));
+
+struct mxl_ml_sta_add_param {
+  u8 sta_addr1[ETH_ALEN];
+  u8 sta_addr2[ETH_ALEN];
+  u8 sta_addr3[ETH_ALEN];
+  u8 mld_mac_addr[ETH_ALEN];
+  u8 assoc_link_bitmap;
+  u16 eml_capab;
+  u8 num_of_sim_links;
+  u8 mld_id;
+  u16 aid;
+} __attribute__ ((packed));
+
+struct mxl_ml_sta_t2lm_teardown {
+  u16 aid;
+} __attribute__ ((packed));
+
 /* Data for channel switch vendor implementation */
 struct intel_vendor_channel_switch_cfg {
   u8 csaDeauthMode; /* 0-disabled, 1-unicast, 2-multicast */
@@ -815,4 +848,8 @@ typedef struct wave_radio_reg_data {
   u8 flags;
 } wave_radio_reg_data_t;
 
+struct mxl_ml_sta_reassoc_notify {
+  u16 aid;
+} __attribute__ ((packed));
+
 #endif /* _VENDOR_CMDS_H_ */
diff --git a/src/common/wpa_common.c b/src/common/wpa_common.c
index 45d0e447e..c858f0a77 100644
--- a/src/common/wpa_common.c
+++ b/src/common/wpa_common.c
@@ -3730,6 +3730,16 @@ static int wpa_parse_generic(const u8 *pos, struct wpa_eapol_ie_parse *ie)
 			wpa_hexdump(MSG_DEBUG, title, pos, dlen);
 		return 0;
 	}
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	if (p[1] >= RSN_SELECTOR_LEN + 2 &&
+			RSN_SELECTOR_GET(p + 2) == RSN_KEY_DATA_MLO_LINK) {
+		ie->mlo_link_kde_ie = p + 2 + RSN_SELECTOR_LEN;
+		ie->mlo_link_kde_ie_len = p[1] - RSN_SELECTOR_LEN;
+		wpa_hexdump(MSG_DEBUG, "WPA: KEY_DATA_MLO_LINK in EAPOL-Key",
+				pos, pos[1] + 2);
+		return 0;
+	}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 
 	return 2;
 }
diff --git a/src/common/wpa_common.h b/src/common/wpa_common.h
index 30b57b5e2..b65c8541a 100644
--- a/src/common/wpa_common.h
+++ b/src/common/wpa_common.h
@@ -715,6 +715,10 @@ struct wpa_eapol_ie_parse {
 	u16 valid_mlo_links; /* bitmap of valid MLO link KDEs */
 	const u8 *mlo_link[MAX_NUM_MLO_LINKS];
 	size_t mlo_link_len[MAX_NUM_MLO_LINKS];
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	const u8 *mlo_link_kde_ie;
+	size_t mlo_link_kde_ie_len;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 };
 
 int wpa_parse_kde_ies(const u8 *buf, size_t len, struct wpa_eapol_ie_parse *ie);
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index fe859157a..450587467 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -2573,6 +2573,9 @@ struct hostapd_sta_add_params {
 	int ssi_signal;
 	struct ieee80211_mgmt *last_assoc_req;
 	size_t last_assoc_req_len;
+#ifdef CONFIG_VENDOR_MXL
+	struct mxl_sta_add_params mxl_params;
+#endif /* CONFIG_VENDOR_MXL */
 };
 
 struct mac_address {
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index d36ca42c4..ef61c201c 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -5862,6 +5862,15 @@ static int wpa_driver_nl80211_sta_add(void *priv,
 				goto fail;
 		}
 
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+		if (params->mxl_params.ml_sta_info) {
+			wpa_hexdump(MSG_DEBUG, "  * Multi-Link STA info",
+					params->mxl_params.ml_sta_info, sizeof(*params->mxl_params.ml_sta_info));
+			if (nla_put(msg, NL80211_ATTR_ML_STA_INFO,
+						sizeof(*params->mxl_params.ml_sta_info), params->mxl_params.ml_sta_info))
+				goto fail;
+		}
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
 		if (is_ap_interface(drv->nlmode) &&
 		    nla_put_u8(msg, NL80211_ATTR_STA_SUPPORT_P2P_PS,
 			       params->support_p2p_ps ?
diff --git a/src/drivers/mxl_driver.h b/src/drivers/mxl_driver.h
index cf27c09b0..db3e917c7 100644
--- a/src/drivers/mxl_driver.h
+++ b/src/drivers/mxl_driver.h
@@ -42,6 +42,12 @@ struct ieee80211_multilink_capa {
 	enum multi_link_support_e ml_support;
 };
 
+struct mxl_sta_add_params {
+#ifdef CONFIG_IEEE80211BE_MXL_MLO
+	struct ieee80211_ml_sta_info *ml_sta_info;
+#endif /* CONFIG_IEEE80211BE_MXL_MLO */
+};
+
 /** Driver supports background CAC */
 #define MXL_WPA_DRIVER_FLAGS_BACKGROUND_CAC	0x0000000000000001ULL
 
-- 
2.43.0

